try {
  ;(() => {
    const P1 = Object.defineProperty
    const Ke = (e =>
      typeof require < 'u'
        ? require
        : typeof Proxy < 'u'
          ? new Proxy(e, {
              get: (t, r) => (typeof require < 'u' ? require : t)[r],
            })
          : e)(function (e) {
      if (typeof require < 'u') return require.apply(this, arguments)
      throw new Error('Dynamic require of "' + e + '" is not supported')
    })
    const co = (e, t) => () => (e && (t = e((e = 0))), t)
    const N1 = (e, t) => {
      for (const r in t) P1(e, r, { get: t[r], enumerable: !0 })
    }
    const te = co(() => {})
    const re = co(() => {})
    const ne = co(() => {})
    const xc = {}
    N1(xc, {
      A: () => j1,
      ActionBar: () => Cn,
      AddonPanel: () => Dn,
      Badge: () => gr,
      Bar: () => Tn,
      Blockquote: () => M1,
      Button: () => Je,
      ClipboardCode: () => $1,
      Code: () => q1,
      DL: () => U1,
      Div: () => H1,
      DocumentWrapper: () => V1,
      EmptyTabContent: () => kn,
      ErrorFormatter: () => z1,
      FlexBar: () => Ai,
      Form: () => $e,
      H1: () => G1,
      H2: () => W1,
      H3: () => Y1,
      H4: () => K1,
      H5: () => X1,
      H6: () => J1,
      HR: () => Z1,
      IconButton: () => ce,
      Img: () => Q1,
      LI: () => eE,
      Link: () => Ze,
      ListItem: () => tE,
      Loader: () => rE,
      Modal: () => It,
      OL: () => nE,
      P: () => xi,
      Placeholder: () => oE,
      Pre: () => aE,
      ProgressSpinner: () => iE,
      ResetWrapper: () => wi,
      ScrollArea: () => Si,
      Separator: () => Ci,
      Spaced: () => sE,
      Span: () => lE,
      StorybookIcon: () => uE,
      StorybookLogo: () => cE,
      SyntaxHighlighter: () => On,
      TT: () => dE,
      TabBar: () => pE,
      TabButton: () => mE,
      TabWrapper: () => hE,
      Table: () => fE,
      Tabs: () => gE,
      TabsState: () => yE,
      TooltipLinkList: () => In,
      TooltipMessage: () => bE,
      TooltipNote: () => vt,
      UL: () => EE,
      WithTooltip: () => De,
      WithTooltipPure: () => Di,
      Zoom: () => Ti,
      codeCommon: () => Qt,
      components: () => vE,
      createCopyToClipboardFunction: () => AE,
      default: () => L1,
      getStoryHref: () => xE,
      interleaveSeparators: () => wE,
      nameSpaceClassNames: () => SE,
      resetComponents: () => CE,
      withReset: () => er,
    })
    let L1
    let j1
    let Cn
    let Dn
    let gr
    let Tn
    let M1
    let Je
    let $1
    let q1
    let U1
    let H1
    let V1
    let kn
    let z1
    let Ai
    let $e
    let G1
    let W1
    let Y1
    let K1
    let X1
    let J1
    let Z1
    let ce
    let Q1
    let eE
    let Ze
    let tE
    let rE
    let It
    let nE
    let xi
    let oE
    let aE
    let iE
    let wi
    let Si
    let Ci
    let sE
    let lE
    let uE
    let cE
    let On
    let dE
    let pE
    let mE
    let hE
    let fE
    let gE
    let yE
    let In
    let bE
    let vt
    let EE
    let De
    let Di
    let Ti
    let Qt
    let vE
    let AE
    let xE
    let wE
    let SE
    let CE
    let er
    const J = co(() => {
      te()
      re()
      ne()
      ;((L1 = __STORYBOOK_COMPONENTS__),
        ({
          A: j1,
          ActionBar: Cn,
          AddonPanel: Dn,
          Badge: gr,
          Bar: Tn,
          Blockquote: M1,
          Button: Je,
          ClipboardCode: $1,
          Code: q1,
          DL: U1,
          Div: H1,
          DocumentWrapper: V1,
          EmptyTabContent: kn,
          ErrorFormatter: z1,
          FlexBar: Ai,
          Form: $e,
          H1: G1,
          H2: W1,
          H3: Y1,
          H4: K1,
          H5: X1,
          H6: J1,
          HR: Z1,
          IconButton: ce,
          Img: Q1,
          LI: eE,
          Link: Ze,
          ListItem: tE,
          Loader: rE,
          Modal: It,
          OL: nE,
          P: xi,
          Placeholder: oE,
          Pre: aE,
          ProgressSpinner: iE,
          ResetWrapper: wi,
          ScrollArea: Si,
          Separator: Ci,
          Spaced: sE,
          Span: lE,
          StorybookIcon: uE,
          StorybookLogo: cE,
          SyntaxHighlighter: On,
          TT: dE,
          TabBar: pE,
          TabButton: mE,
          TabWrapper: hE,
          Table: fE,
          Tabs: gE,
          TabsState: yE,
          TooltipLinkList: In,
          TooltipMessage: bE,
          TooltipNote: vt,
          UL: EE,
          WithTooltip: De,
          WithTooltipPure: Di,
          Zoom: Ti,
          codeCommon: Qt,
          components: vE,
          createCopyToClipboardFunction: AE,
          getStoryHref: xE,
          interleaveSeparators: wE,
          nameSpaceClassNames: SE,
          resetComponents: CE,
          withReset: er,
        } = __STORYBOOK_COMPONENTS__))
    })
    te()
    re()
    ne()
    te()
    re()
    ne()
    te()
    re()
    ne()
    const c = __REACT__
    const {
      Children: po,
      Component: Et,
      Fragment: ft,
      Profiler: mI,
      PureComponent: hI,
      StrictMode: fI,
      Suspense: Ec,
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: gI,
      act: yI,
      cloneElement: Pe,
      createContext: Lr,
      createElement: Y,
      createFactory: bI,
      createRef: EI,
      forwardRef: vc,
      isValidElement: vI,
      lazy: Ac,
      memo: Xe,
      startTransition: AI,
      unstable_act: xI,
      useCallback: Q,
      useContext: mo,
      useDebugValue: wI,
      useDeferredValue: SI,
      useEffect: X,
      useId: CI,
      useImperativeHandle: DI,
      useInsertionEffect: TI,
      useLayoutEffect: ho,
      useMemo: Me,
      useReducer: kI,
      useRef: ye,
      useState: z,
      useSyncExternalStore: OI,
      useTransition: II,
      version: RI,
    } = __REACT__
    J()
    te()
    re()
    ne()
    const jI = __STORYBOOK_ICONS__
    const {
      AccessibilityAltIcon: MI,
      AccessibilityIcon: $I,
      AccessibilityIgnoredIcon: qI,
      AddIcon: go,
      AdminIcon: UI,
      AlertAltIcon: HI,
      AlertIcon: VI,
      AlignLeftIcon: zI,
      AlignRightIcon: GI,
      AppleIcon: WI,
      ArrowBottomLeftIcon: YI,
      ArrowBottomRightIcon: KI,
      ArrowDownIcon: XI,
      ArrowLeftIcon: JI,
      ArrowRightIcon: ZI,
      ArrowSolidDownIcon: QI,
      ArrowSolidLeftIcon: eR,
      ArrowSolidRightIcon: tR,
      ArrowSolidUpIcon: rR,
      ArrowTopLeftIcon: nR,
      ArrowTopRightIcon: oR,
      ArrowUpIcon: aR,
      AzureDevOpsIcon: iR,
      BackIcon: sR,
      BasketIcon: lR,
      BatchAcceptIcon: uR,
      BatchDenyIcon: cR,
      BeakerIcon: dR,
      BellIcon: pR,
      BitbucketIcon: mR,
      BoldIcon: hR,
      BookIcon: fR,
      BookmarkHollowIcon: gR,
      BookmarkIcon: yR,
      BottomBarIcon: bR,
      BottomBarToggleIcon: ER,
      BoxIcon: vR,
      BranchIcon: AR,
      BrowserIcon: wc,
      ButtonIcon: xR,
      CPUIcon: wR,
      CalendarIcon: SR,
      CameraIcon: CR,
      CameraStabilizeIcon: DR,
      CategoryIcon: TR,
      CertificateIcon: kR,
      ChangedIcon: OR,
      ChatIcon: IR,
      CheckIcon: yo,
      ChevronDownIcon: bo,
      ChevronLeftIcon: RR,
      ChevronRightIcon: Sc,
      ChevronSmallDownIcon: Eo,
      ChevronSmallLeftIcon: BR,
      ChevronSmallRightIcon: _R,
      ChevronSmallUpIcon: Cc,
      ChevronUpIcon: Dc,
      ChromaticIcon: FR,
      ChromeIcon: PR,
      CircleHollowIcon: NR,
      CircleIcon: vo,
      ClearIcon: LR,
      CloseAltIcon: jR,
      CloseIcon: MR,
      CloudHollowIcon: $R,
      CloudIcon: qR,
      CogIcon: UR,
      CollapseIcon: HR,
      CommandIcon: VR,
      CommentAddIcon: zR,
      CommentIcon: GR,
      CommentsIcon: WR,
      CommitIcon: YR,
      CompassIcon: KR,
      ComponentDrivenIcon: XR,
      ComponentIcon: JR,
      ContrastIcon: ZR,
      ContrastIgnoredIcon: QR,
      ControlsIcon: eB,
      CopyIcon: tB,
      CreditIcon: rB,
      CrossIcon: nB,
      DashboardIcon: oB,
      DatabaseIcon: aB,
      DeleteIcon: iB,
      DiamondIcon: sB,
      DirectionIcon: lB,
      DiscordIcon: uB,
      DocChartIcon: cB,
      DocListIcon: dB,
      DocumentIcon: yr,
      DownloadIcon: pB,
      DragIcon: mB,
      EditIcon: hB,
      EllipsisIcon: fB,
      EmailIcon: gB,
      ExpandAltIcon: yB,
      ExpandIcon: bB,
      EyeCloseIcon: Tc,
      EyeIcon: kc,
      FaceHappyIcon: EB,
      FaceNeutralIcon: vB,
      FaceSadIcon: AB,
      FacebookIcon: xB,
      FailedIcon: Oc,
      FastForwardIcon: Ic,
      FigmaIcon: wB,
      FilterIcon: SB,
      FlagIcon: CB,
      FolderIcon: DB,
      FormIcon: TB,
      GDriveIcon: kB,
      GithubIcon: OB,
      GitlabIcon: IB,
      GlobeIcon: RB,
      GoogleIcon: BB,
      GraphBarIcon: _B,
      GraphLineIcon: FB,
      GraphqlIcon: PB,
      GridAltIcon: NB,
      GridIcon: Rc,
      GrowIcon: Bc,
      HeartHollowIcon: LB,
      HeartIcon: jB,
      HomeIcon: MB,
      HourglassIcon: $B,
      InfoIcon: qB,
      ItalicIcon: UB,
      JumpToIcon: HB,
      KeyIcon: VB,
      LightningIcon: zB,
      LightningOffIcon: GB,
      LinkBrokenIcon: WB,
      LinkIcon: YB,
      LinkedinIcon: KB,
      LinuxIcon: XB,
      ListOrderedIcon: JB,
      ListUnorderedIcon: ZB,
      LocationIcon: QB,
      LockIcon: e_,
      MarkdownIcon: t_,
      MarkupIcon: _c,
      MediumIcon: r_,
      MemoryIcon: n_,
      MenuIcon: o_,
      MergeIcon: a_,
      MirrorIcon: i_,
      MobileIcon: Fc,
      MoonIcon: s_,
      NutIcon: l_,
      OutboxIcon: u_,
      OutlineIcon: Pc,
      PaintBrushIcon: c_,
      PaperClipIcon: d_,
      ParagraphIcon: p_,
      PassedIcon: ki,
      PhoneIcon: m_,
      PhotoDragIcon: h_,
      PhotoIcon: Nc,
      PhotoStabilizeIcon: f_,
      PinAltIcon: g_,
      PinIcon: y_,
      PlayAllHollowIcon: b_,
      PlayBackIcon: Lc,
      PlayHollowIcon: E_,
      PlayIcon: jc,
      PlayNextIcon: Mc,
      PlusIcon: v_,
      PointerDefaultIcon: A_,
      PointerHandIcon: x_,
      PowerIcon: w_,
      PrintIcon: S_,
      ProceedIcon: C_,
      ProfileIcon: D_,
      PullRequestIcon: T_,
      QuestionIcon: k_,
      RSSIcon: O_,
      RedirectIcon: I_,
      ReduxIcon: R_,
      RefreshIcon: Ao,
      ReplyIcon: B_,
      RepoIcon: __,
      RequestChangeIcon: F_,
      RewindIcon: $c,
      RulerIcon: qc,
      SaveIcon: P_,
      SearchIcon: N_,
      ShareAltIcon: L_,
      ShareIcon: j_,
      ShieldIcon: M_,
      SideBySideIcon: $_,
      SidebarAltIcon: q_,
      SidebarAltToggleIcon: U_,
      SidebarIcon: H_,
      SidebarToggleIcon: V_,
      SpeakerIcon: z_,
      StackedIcon: G_,
      StarHollowIcon: W_,
      StarIcon: Y_,
      StatusFailIcon: K_,
      StatusIcon: X_,
      StatusPassIcon: J_,
      StatusWarnIcon: Z_,
      StickerIcon: Q_,
      StopAltHollowIcon: eF,
      StopAltIcon: Uc,
      StopIcon: tF,
      StorybookIcon: rF,
      StructureIcon: nF,
      SubtractIcon: Hc,
      SunIcon: oF,
      SupportIcon: aF,
      SweepIcon: iF,
      SwitchAltIcon: sF,
      SyncIcon: Vc,
      TabletIcon: zc,
      ThumbsUpIcon: lF,
      TimeIcon: uF,
      TimerIcon: cF,
      TransferIcon: Gc,
      TrashIcon: dF,
      TwitterIcon: pF,
      TypeIcon: mF,
      UbuntuIcon: hF,
      UndoIcon: xo,
      UnfoldIcon: fF,
      UnlockIcon: gF,
      UnpinIcon: yF,
      UploadIcon: bF,
      UserAddIcon: EF,
      UserAltIcon: vF,
      UserIcon: AF,
      UsersIcon: xF,
      VSCodeIcon: wF,
      VerifiedIcon: SF,
      VideoIcon: CF,
      WandIcon: DF,
      WatchIcon: TF,
      WindowsIcon: kF,
      WrenchIcon: OF,
      XIcon: IF,
      YoutubeIcon: RF,
      ZoomIcon: Wc,
      ZoomOutIcon: Yc,
      ZoomResetIcon: Kc,
      iconList: BF,
    } = __STORYBOOK_ICONS__
    te()
    re()
    ne()
    const LF = __STORYBOOK_THEMING__
    const {
      CacheProvider: jF,
      ClassNames: MF,
      Global: Xc,
      ThemeProvider: Jc,
      background: $F,
      color: wo,
      convert: Zc,
      create: qF,
      createCache: UF,
      createGlobal: HF,
      createReset: VF,
      css: zF,
      darken: GF,
      ensure: WF,
      ignoreSsrWarning: Qc,
      isPropValid: YF,
      jsx: KF,
      keyframes: Oi,
      lighten: XF,
      styled: R,
      themes: Ii,
      typography: At,
      useTheme: Qe,
      withTheme: ed,
    } = __STORYBOOK_THEMING__
    te()
    re()
    ne()
    const H = (() => {
      let e
      return (
        typeof window < 'u'
          ? (e = window)
          : typeof globalThis < 'u'
            ? (e = globalThis)
            : typeof window < 'u'
              ? (e = window)
              : typeof self < 'u'
                ? (e = self)
                : (e = {}),
        e
      )
    })()
    te()
    re()
    ne()
    const a4 = __STORYBOOK_API__
    const {
      ActiveTabs: i4,
      Consumer: td,
      ManagerContext: s4,
      Provider: l4,
      RequestResponseError: u4,
      addons: ve,
      combineParameters: c4,
      controlOrMetaKey: d4,
      controlOrMetaSymbol: p4,
      eventMatchesShortcut: m4,
      eventToShortcut: h4,
      experimental_MockUniversalStore: f4,
      experimental_UniversalStore: g4,
      experimental_getStatusStore: y4,
      experimental_getTestProviderStore: b4,
      experimental_requestResponse: Ri,
      experimental_useStatusStore: rd,
      experimental_useTestProviderStore: E4,
      experimental_useUniversalStore: v4,
      internal_fullStatusStore: A4,
      internal_fullTestProviderStore: x4,
      internal_universalStatusStore: w4,
      internal_universalTestProviderStore: S4,
      isMacLike: C4,
      isShortcutTaken: D4,
      keyToSymbol: T4,
      merge: k4,
      mockChannel: O4,
      optionOrAltSymbol: I4,
      shortcutMatchesShortcut: R4,
      shortcutToHumanString: B4,
      types: et,
      useAddonState: jr,
      useArgTypes: So,
      useArgs: nd,
      useChannel: Co,
      useGlobalTypes: _4,
      useGlobals: Rt,
      useParameter: tr,
      useSharedState: F4,
      useStoryPrepared: P4,
      useStorybookApi: tt,
      useStorybookState: od,
    } = __STORYBOOK_API__
    J()
    te()
    re()
    ne()
    const $4 = __STORYBOOK_CORE_EVENTS__
    const {
      ARGTYPES_INFO_REQUEST: ad,
      ARGTYPES_INFO_RESPONSE: Bi,
      CHANNEL_CREATED: q4,
      CHANNEL_WS_DISCONNECT: U4,
      CONFIG_ERROR: id,
      CREATE_NEW_STORYFILE_REQUEST: H4,
      CREATE_NEW_STORYFILE_RESPONSE: V4,
      CURRENT_STORY_WAS_SET: _i,
      DOCS_PREPARED: sd,
      DOCS_RENDERED: Do,
      FILE_COMPONENT_SEARCH_REQUEST: z4,
      FILE_COMPONENT_SEARCH_RESPONSE: G4,
      FORCE_REMOUNT: br,
      FORCE_RE_RENDER: To,
      GLOBALS_UPDATED: Mr,
      NAVIGATE_URL: W4,
      PLAY_FUNCTION_THREW_EXCEPTION: ko,
      PRELOAD_ENTRIES: ld,
      PREVIEW_BUILDER_PROGRESS: Y4,
      PREVIEW_KEYDOWN: ud,
      REGISTER_SUBSCRIPTION: K4,
      REQUEST_WHATS_NEW_DATA: X4,
      RESET_STORY_ARGS: Oo,
      RESULT_WHATS_NEW_DATA: J4,
      SAVE_STORY_REQUEST: Fi,
      SAVE_STORY_RESPONSE: Io,
      SELECT_STORY: Z4,
      SET_CONFIG: Q4,
      SET_CURRENT_STORY: Ro,
      SET_FILTER: e9,
      SET_GLOBALS: cd,
      SET_INDEX: t9,
      SET_STORIES: r9,
      SET_WHATS_NEW_CACHE: n9,
      SHARED_STATE_CHANGED: o9,
      SHARED_STATE_SET: a9,
      STORIES_COLLAPSE_ALL: i9,
      STORIES_EXPAND_ALL: s9,
      STORY_ARGS_UPDATED: dd,
      STORY_CHANGED: Er,
      STORY_ERRORED: pd,
      STORY_FINISHED: Pi,
      STORY_HOT_UPDATED: md,
      STORY_INDEX_INVALIDATED: hd,
      STORY_MISSING: Ni,
      STORY_PREPARED: fd,
      STORY_RENDERED: rr,
      STORY_RENDER_PHASE_CHANGED: gt,
      STORY_SPECIFIED: gd,
      STORY_THREW_EXCEPTION: Bo,
      STORY_UNCHANGED: yd,
      TELEMETRY_ERROR: l9,
      TOGGLE_WHATS_NEW_NOTIFICATIONS: u9,
      UNHANDLED_ERRORS_WHILE_PLAYING: _o,
      UPDATE_GLOBALS: Fo,
      UPDATE_QUERY_PARAMS: bd,
      UPDATE_STORY_ARGS: Po,
    } = __STORYBOOK_CORE_EVENTS__
    te()
    re()
    ne()
    const h9 = __STORYBOOK_CLIENT_LOGGER__
    const {
      deprecate: $r,
      logger: Z,
      once: yt,
      pretty: f9,
    } = __STORYBOOK_CLIENT_LOGGER__
    J()
    te()
    re()
    ne()
    te()
    re()
    ne()
    const v9 = __STORYBOOK_CHANNELS__
    const {
      Channel: No,
      HEARTBEAT_INTERVAL: A9,
      HEARTBEAT_MAX_LATENCY: x9,
      PostMessageTransport: w9,
      WebsocketTransport: S9,
      createBrowserChannel: C9,
    } = __STORYBOOK_CHANNELS__
    te()
    re()
    ne()
    const DE = Object.defineProperty
    const Ae = (e, t) => DE(e, 'name', { value: t, configurable: !0 })
    function ke(e) {
      for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r]
      let n = Array.from(typeof e === 'string' ? [e] : e)
      n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, '')
      const o = n.reduce(function (s, l) {
        const u = l.match(/\n([\t ]+|(?!\s).)/g)
        return u
          ? s.concat(
              u.map(function (d) {
                let m, p
                return (p =
                  (m = d.match(/[\t ]/g)) === null || m === void 0
                    ? void 0
                    : m.length) !== null && p !== void 0
                  ? p
                  : 0
              })
            )
          : s
      }, [])
      if (o.length) {
        const a = new RegExp(
          `
[	 ]{` +
            Math.min.apply(Math, o) +
            '}',
          'g'
        )
        n = n.map(function (s) {
          return s.replace(
            a,
            `
`
          )
        })
      }
      n[0] = n[0].replace(/^\r?\n/, '')
      let i = n[0]
      return (
        t.forEach(function (s, l) {
          const u = i.match(/(?:^|\n)( *)$/)
          const d = u ? u[1] : ''
          let m = s
          ;(typeof s === 'string' &&
            s.includes(`
`) &&
            (m = String(s)
              .split(
                `
`
              )
              .map(function (p, f) {
                return f === 0 ? p : '' + d + p
              }).join(`
`)),
            (i += m + n[l + 1]))
        }),
        i
      )
    }
    Ae(ke, 'dedent')
    function Li({ code: e, category: t }) {
      const r = String(e).padStart(4, '0')
      return `SB_${t}_${r}`
    }
    Ae(Li, 'parseErrorCode')
    const Ed = class vd extends Error {
      constructor(t) {
        ;(super(vd.getFullMessage(t)),
          (this.data = {}),
          (this.fromStorybook = !0),
          (this.category = t.category),
          (this.documentation = t.documentation ?? !1),
          (this.code = t.code))
      }
      get fullErrorCode() {
        return Li({ code: this.code, category: this.category })
      }
      get name() {
        const t = this.constructor.name
        return `${this.fullErrorCode} (${t})`
      }
      static getFullMessage({
        documentation: t,
        code: r,
        category: n,
        message: o,
      }) {
        let a
        return (
          t === !0
            ? (a = `https://storybook.js.org/error/${Li({ code: r, category: n })}`)
            : typeof t === 'string'
              ? (a = t)
              : Array.isArray(t) &&
                (a = `
${t.map(i => `	- ${i}`).join(`
`)}`),
          `${o}${
            a != null
              ? `

More info: ${a}
`
              : ''
          }`
        )
      }
    }
    Ae(Ed, 'StorybookError')
    const Te = Ed
    var TE = (e => (
      (e.BLOCKS = 'BLOCKS'),
      (e.DOCS_TOOLS = 'DOCS-TOOLS'),
      (e.PREVIEW_CLIENT_LOGGER = 'PREVIEW_CLIENT-LOGGER'),
      (e.PREVIEW_CHANNELS = 'PREVIEW_CHANNELS'),
      (e.PREVIEW_CORE_EVENTS = 'PREVIEW_CORE-EVENTS'),
      (e.PREVIEW_INSTRUMENTER = 'PREVIEW_INSTRUMENTER'),
      (e.PREVIEW_API = 'PREVIEW_API'),
      (e.PREVIEW_REACT_DOM_SHIM = 'PREVIEW_REACT-DOM-SHIM'),
      (e.PREVIEW_ROUTER = 'PREVIEW_ROUTER'),
      (e.PREVIEW_THEMING = 'PREVIEW_THEMING'),
      (e.RENDERER_HTML = 'RENDERER_HTML'),
      (e.RENDERER_PREACT = 'RENDERER_PREACT'),
      (e.RENDERER_REACT = 'RENDERER_REACT'),
      (e.RENDERER_SERVER = 'RENDERER_SERVER'),
      (e.RENDERER_SVELTE = 'RENDERER_SVELTE'),
      (e.RENDERER_VUE = 'RENDERER_VUE'),
      (e.RENDERER_VUE3 = 'RENDERER_VUE3'),
      (e.RENDERER_WEB_COMPONENTS = 'RENDERER_WEB-COMPONENTS'),
      (e.FRAMEWORK_NEXTJS = 'FRAMEWORK_NEXTJS'),
      (e.ADDON_VITEST = 'ADDON_VITEST'),
      (e.ADDON_A11Y = 'ADDON_A11Y'),
      e
    ))(TE || {})
    const Ad = class extends Te {
      constructor(t) {
        ;(super({
          category: 'PREVIEW_API',
          code: 1,
          message: ke`
        Couldn't find story matching id '${t.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${t.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`,
        }),
          (this.data = t))
      }
    }
    Ae(Ad, 'MissingStoryAfterHmrError')
    const xd = Ad
    const wd = class extends Te {
      constructor(t) {
        ;(super({
          category: 'PREVIEW_API',
          code: 2,
          documentation:
            'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function',
          message: ke`
        We detected that you use an implicit action arg while ${t.phase} of your story.  
        ${
          t.deprecated
            ? `
This is deprecated and won't work in Storybook 8 anymore.
`
            : ''
        }
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${t.name}: fn()
          }`,
        }),
          (this.data = t))
      }
    }
    Ae(wd, 'ImplicitActionsDuringRendering')
    const Sd = wd
    const Cd = class extends Te {
      constructor() {
        super({
          category: 'PREVIEW_API',
          code: 3,
          message: ke`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`,
        })
      }
    }
    Ae(Cd, 'CalledExtractOnStoreError')
    const Dd = Cd
    const Td = class extends Te {
      constructor() {
        super({
          category: 'PREVIEW_API',
          code: 4,
          message: ke`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
          documentation:
            'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field',
        })
      }
    }
    Ae(Td, 'MissingRenderToCanvasError')
    const kd = Td
    const Od = class extends Te {
      constructor(t) {
        ;(super({
          category: 'PREVIEW_API',
          code: 5,
          message: ke`
        Called \`Preview.${t.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${t.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`,
        }),
          (this.data = t))
      }
    }
    Ae(Od, 'CalledPreviewMethodBeforeInitializationError')
    const rt = Od
    const Id = class extends Te {
      constructor(t) {
        ;(super({
          category: 'PREVIEW_API',
          code: 6,
          message: ke`
        Error fetching \`/index.json\`:
        
        ${t.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`,
        }),
          (this.data = t))
      }
    }
    Ae(Id, 'StoryIndexFetchError')
    const Rd = Id
    const Bd = class extends Te {
      constructor(t) {
        ;(super({
          category: 'PREVIEW_API',
          code: 7,
          message: ke`
        Tried to render docs entry ${t.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`,
        }),
          (this.data = t))
      }
    }
    Ae(Bd, 'MdxFileWithNoCsfReferencesError')
    const _d = Bd
    const Fd = class extends Te {
      constructor() {
        super({
          category: 'PREVIEW_API',
          code: 8,
          message: ke`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`,
        })
      }
    }
    Ae(Fd, 'EmptyIndexError')
    const Pd = Fd
    const Nd = class extends Te {
      constructor(t) {
        ;(super({
          category: 'PREVIEW_API',
          code: 9,
          message: ke`
        Couldn't find story matching '${t.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`,
        }),
          (this.data = t))
      }
    }
    Ae(Nd, 'NoStoryMatchError')
    const Ld = Nd
    const jd = class extends Te {
      constructor(t) {
        ;(super({
          category: 'PREVIEW_API',
          code: 10,
          message: ke`
        Couldn't find story matching id '${t.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`,
        }),
          (this.data = t))
      }
    }
    Ae(jd, 'MissingStoryFromCsfFileError')
    const Md = jd
    const $d = class extends Te {
      constructor() {
        super({
          category: 'PREVIEW_API',
          code: 11,
          message: ke`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`,
        })
      }
    }
    Ae($d, 'StoryStoreAccessedBeforeInitializationError')
    const qd = $d
    const Ud = class extends Te {
      constructor(t) {
        ;(super({
          category: 'PREVIEW_API',
          code: 12,
          message: ke`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${t.playFunction}`,
        }),
          (this.data = t))
      }
    }
    Ae(Ud, 'MountMustBeDestructuredError')
    const qr = Ud
    const Hd = class extends Te {
      constructor(t) {
        ;(super({
          category: 'PREVIEW_API',
          code: 14,
          message: ke`
        No render function available for storyId '${t.id}'
      `,
        }),
          (this.data = t))
      }
    }
    Ae(Hd, 'NoRenderFunctionError')
    const Lo = Hd
    const Vd = class extends Te {
      constructor() {
        super({
          category: 'PREVIEW_API',
          code: 15,
          message: ke`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          // ðŸ‘ˆ mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `,
        })
      }
    }
    Ae(Vd, 'NoStoryMountedError')
    const zd = Vd
    const kE = class extends Te {
      constructor(t) {
        ;(super({
          category: 'PREVIEW_API',
          code: 16,
          message: `Status has typeId "${t.status.typeId}" but was added to store with typeId "${t.typeId}". Full status: ${JSON.stringify(t.status, null, 2)}`,
        }),
          (this.data = t))
      }
    }
    Ae(kE, 'StatusTypeIdMismatchError')
    const OE = class extends Te {
      constructor() {
        super({
          category: 'FRAMEWORK_NEXTJS',
          code: 1,
          documentation: 'https://storybook.js.org/docs/get-started/nextjs#faq',
          message: ke`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `,
        })
      }
    }
    Ae(OE, 'NextJsSharpError')
    const IE = class extends Te {
      constructor(t) {
        ;(super({
          category: 'FRAMEWORK_NEXTJS',
          code: 2,
          message: ke`
        Tried to access router mocks from "${t.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `,
        }),
          (this.data = t))
      }
    }
    Ae(IE, 'NextjsRouterMocksNotAvailable')
    const RE = class extends Te {
      constructor(t) {
        ;(super({
          category: 'DOCS-TOOLS',
          code: 1,
          documentation:
            'https://github.com/storybookjs/storybook/issues/26606',
          message: ke`
        There was a failure when generating detailed ArgTypes in ${t.language} for:
        ${JSON.stringify(t.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `,
        }),
          (this.data = t))
      }
    }
    Ae(RE, 'UnknownArgTypesError')
    const BE = class extends Te {
      constructor(t) {
        ;(super({
          category: 'ADDON_VITEST',
          code: 1,
          message: ke`
        Encountered an unsupported value "${t.value}" when setting the viewport ${t.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `,
        }),
          (this.data = t))
      }
    }
    Ae(BE, 'UnsupportedViewportDimensionError')
    const _E = class extends Te {
      constructor() {
        super({
          category: 'ADDON_A11Y',
          code: 1,
          documentation:
            'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter',
          message:
            'The "element" parameter in parameters.a11y has been removed. Use "context" instead.',
        })
      }
    }
    Ae(_E, 'ElementA11yParameterError')
    te()
    re()
    ne()
    const FE = Object.create
    const os = Object.defineProperty
    const PE = Object.getOwnPropertyDescriptor
    const NE = Object.getOwnPropertyNames
    const LE = Object.getPrototypeOf
    const jE = Object.prototype.hasOwnProperty
    const w = (e, t) => os(e, 'name', { value: t, configurable: !0 })
    const jo = (e =>
      typeof Ke < 'u'
        ? Ke
        : typeof Proxy < 'u'
          ? new Proxy(e, { get: (t, r) => (typeof Ke < 'u' ? Ke : t)[r] })
          : e)(function (e) {
      if (typeof Ke < 'u') return Ke.apply(this, arguments)
      throw new Error('Dynamic require of "' + e + '" is not supported')
    })
    const Ne = (e, t) => () => (
      t || e((t = { exports: {} }).exports, t),
      t.exports
    )
    const ME = (e, t, r, n) => {
      if ((t && typeof t === 'object') || typeof t === 'function')
        for (const o of NE(t))
          !jE.call(e, o) &&
            o !== r &&
            os(e, o, {
              get: () => t[o],
              enumerable: !(n = PE(t, o)) || n.enumerable,
            })
      return e
    }
    const Jr = (e, t, r) => (
      (r = e != null ? FE(LE(e)) : {}),
      ME(
        t || !e || !e.__esModule
          ? os(r, 'default', { value: e, enumerable: !0 })
          : r,
        e
      )
    )
    const ip = Ne((e, t) => {
      ;(function (r) {
        if (typeof e === 'object' && typeof t < 'u') t.exports = r()
        else if (typeof define === 'function' && define.amd) define([], r)
        else {
          let n
          ;(typeof window < 'u' || typeof window < 'u'
            ? (n = window)
            : typeof self < 'u'
              ? (n = self)
              : (n = this),
            (n.memoizerific = r()))
        }
      })(function () {
        let r, n, o
        return w(function a(i, s, l) {
          function u(p, f) {
            if (!s[p]) {
              if (!i[p]) {
                const g = typeof jo === 'function' && jo
                if (!f && g) return g(p, !0)
                if (d) return d(p, !0)
                const y = new Error("Cannot find module '" + p + "'")
                throw ((y.code = 'MODULE_NOT_FOUND'), y)
              }
              const E = (s[p] = { exports: {} })
              i[p][0].call(
                E.exports,
                function (b) {
                  const x = i[p][1][b]
                  return u(x || b)
                },
                E,
                E.exports,
                a,
                i,
                s,
                l
              )
            }
            return s[p].exports
          }
          w(u, 's')
          for (var d = typeof jo === 'function' && jo, m = 0; m < l.length; m++)
            u(l[m])
          return u
        }, 'e')(
          {
            1: [
              function (a, i, s) {
                i.exports = function (l) {
                  if (typeof Map !== 'function' || l) {
                    const u = a('./similar')
                    return new u()
                  } else return new Map()
                }
              },
              { './similar': 2 },
            ],
            2: [
              function (a, i, s) {
                function l() {
                  return (
                    (this.list = []),
                    (this.lastItem = void 0),
                    (this.size = 0),
                    this
                  )
                }
                ;(w(l, 'Similar'),
                  (l.prototype.get = function (u) {
                    let d
                    if (this.lastItem && this.isEqual(this.lastItem.key, u))
                      return this.lastItem.val
                    if (((d = this.indexOf(u)), d >= 0))
                      return ((this.lastItem = this.list[d]), this.list[d].val)
                  }),
                  (l.prototype.set = function (u, d) {
                    let m
                    return this.lastItem && this.isEqual(this.lastItem.key, u)
                      ? ((this.lastItem.val = d), this)
                      : ((m = this.indexOf(u)),
                        m >= 0
                          ? ((this.lastItem = this.list[m]),
                            (this.list[m].val = d),
                            this)
                          : ((this.lastItem = { key: u, val: d }),
                            this.list.push(this.lastItem),
                            this.size++,
                            this))
                  }),
                  (l.prototype.delete = function (u) {
                    let d
                    if (
                      (this.lastItem &&
                        this.isEqual(this.lastItem.key, u) &&
                        (this.lastItem = void 0),
                      (d = this.indexOf(u)),
                      d >= 0)
                    )
                      return (this.size--, this.list.splice(d, 1)[0])
                  }),
                  (l.prototype.has = function (u) {
                    let d
                    return this.lastItem && this.isEqual(this.lastItem.key, u)
                      ? !0
                      : ((d = this.indexOf(u)),
                        d >= 0 ? ((this.lastItem = this.list[d]), !0) : !1)
                  }),
                  (l.prototype.forEach = function (u, d) {
                    let m
                    for (m = 0; m < this.size; m++)
                      u.call(
                        d || this,
                        this.list[m].val,
                        this.list[m].key,
                        this
                      )
                  }),
                  (l.prototype.indexOf = function (u) {
                    let d
                    for (d = 0; d < this.size; d++)
                      if (this.isEqual(this.list[d].key, u)) return d
                    return -1
                  }),
                  (l.prototype.isEqual = function (u, d) {
                    return u === d || (u !== u && d !== d)
                  }),
                  (i.exports = l))
              },
              {},
            ],
            3: [
              function (a, i, s) {
                const l = a('map-or-similar')
                i.exports = function (p) {
                  const f = new l(!1)
                  const g = []
                  return function (y) {
                    var E = w(function () {
                      let b = f
                      let x
                      let S
                      const T = arguments.length - 1
                      const _ = Array(T + 1)
                      let O = !0
                      let k
                      if ((E.numArgs || E.numArgs === 0) && E.numArgs !== T + 1)
                        throw new Error(
                          'Memoizerific functions should always be called with the same number of arguments'
                        )
                      for (k = 0; k < T; k++) {
                        if (
                          ((_[k] = { cacheItem: b, arg: arguments[k] }),
                          b.has(arguments[k]))
                        ) {
                          b = b.get(arguments[k])
                          continue
                        }
                        ;((O = !1),
                          (x = new l(!1)),
                          b.set(arguments[k], x),
                          (b = x))
                      }
                      return (
                        O &&
                          (b.has(arguments[T])
                            ? (S = b.get(arguments[T]))
                            : (O = !1)),
                        O ||
                          ((S = y.apply(null, arguments)),
                          b.set(arguments[T], S)),
                        p > 0 &&
                          ((_[T] = { cacheItem: b, arg: arguments[T] }),
                          O ? u(g, _) : g.push(_),
                          g.length > p && d(g.shift())),
                        (E.wasMemoized = O),
                        (E.numArgs = T + 1),
                        S
                      )
                    }, 'memoizerific')
                    return (
                      (E.limit = p),
                      (E.wasMemoized = !1),
                      (E.cache = f),
                      (E.lru = g),
                      E
                    )
                  }
                }
                function u(p, f) {
                  const g = p.length
                  const y = f.length
                  let E
                  let b
                  let x
                  for (b = 0; b < g; b++) {
                    for (E = !0, x = 0; x < y; x++)
                      if (!m(p[b][x].arg, f[x].arg)) {
                        E = !1
                        break
                      }
                    if (E) break
                  }
                  p.push(p.splice(b, 1)[0])
                }
                w(u, 'moveToMostRecentLru')
                function d(p) {
                  const f = p.length
                  let g = p[f - 1]
                  let y
                  let E
                  for (
                    g.cacheItem.delete(g.arg), E = f - 2;
                    E >= 0 &&
                    ((g = p[E]), (y = g.cacheItem.get(g.arg)), !y || !y.size);
                    E--
                  )
                    g.cacheItem.delete(g.arg)
                }
                w(d, 'removeCachedResult')
                function m(p, f) {
                  return p === f || (p !== p && f !== f)
                }
                w(m, 'isEqual')
              },
              { 'map-or-similar': 1 },
            ],
          },
          {},
          [3]
        )(3)
      })
    })
    const sp = Ne(e => {
      'use strict'
      ;(Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.encodeString = n))
      const t = Array.from(
        { length: 256 },
        (o, a) => '%' + ((a < 16 ? '0' : '') + a.toString(16)).toUpperCase()
      )
      const r = new Int8Array([
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 1, 0,
      ])
      function n(o) {
        const a = o.length
        if (a === 0) return ''
        let i = ''
        let s = 0
        let l = 0
        e: for (; l < a; l++) {
          let u = o.charCodeAt(l)
          for (; u < 128; ) {
            if (
              (r[u] !== 1 &&
                (s < l && (i += o.slice(s, l)), (s = l + 1), (i += t[u])),
              ++l === a)
            )
              break e
            u = o.charCodeAt(l)
          }
          if ((s < l && (i += o.slice(s, l)), u < 2048)) {
            ;((s = l + 1), (i += t[192 | (u >> 6)] + t[128 | (u & 63)]))
            continue
          }
          if (u < 55296 || u >= 57344) {
            ;((s = l + 1),
              (i +=
                t[224 | (u >> 12)] +
                t[128 | ((u >> 6) & 63)] +
                t[128 | (u & 63)]))
            continue
          }
          if ((++l, l >= a)) throw new Error('URI malformed')
          const d = o.charCodeAt(l) & 1023
          ;((s = l + 1),
            (u = 65536 + (((u & 1023) << 10) | d)),
            (i +=
              t[240 | (u >> 18)] +
              t[128 | ((u >> 12) & 63)] +
              t[128 | ((u >> 6) & 63)] +
              t[128 | (u & 63)]))
        }
        return s === 0 ? o : s < a ? i + o.slice(s) : i
      }
      w(n, 'encodeString')
    })
    const as = Ne(e => {
      'use strict'
      ;(Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.defaultOptions =
          e.defaultShouldSerializeObject =
          e.defaultValueSerializer =
            void 0))
      const t = sp()
      const r = w(a => {
        switch (typeof a) {
          case 'string':
            return (0, t.encodeString)(a)
          case 'bigint':
          case 'boolean':
            return '' + a
          case 'number':
            if (Number.isFinite(a))
              return a < 1e21 ? '' + a : (0, t.encodeString)('' + a)
            break
        }
        return a instanceof Date ? (0, t.encodeString)(a.toISOString()) : ''
      }, 'defaultValueSerializer')
      e.defaultValueSerializer = r
      const n = w(a => a instanceof Date, 'defaultShouldSerializeObject')
      e.defaultShouldSerializeObject = n
      const o = w(a => a, 'identityFunc')
      e.defaultOptions = {
        nesting: !0,
        nestingSyntax: 'dot',
        arrayRepeat: !1,
        arrayRepeatSyntax: 'repeat',
        delimiter: 38,
        valueDeserializer: o,
        valueSerializer: e.defaultValueSerializer,
        keyDeserializer: o,
        shouldSerializeObject: e.defaultShouldSerializeObject,
      }
    })
    const lp = Ne(e => {
      'use strict'
      ;(Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.getDeepObject = o),
        (e.stringifyObject = d))
      const t = as()
      const r = sp()
      function n(m) {
        return m === '__proto__' || m === 'constructor' || m === 'prototype'
      }
      w(n, 'isPrototypeKey')
      function o(m, p, f, g, y) {
        if (n(p)) return m
        const E = m[p]
        return typeof E === 'object' && E !== null
          ? E
          : !g &&
              (y ||
                typeof f === 'number' ||
                (typeof f === 'string' && f * 0 === 0 && !f.includes('.')))
            ? (m[p] = [])
            : (m[p] = {})
      }
      w(o, 'getDeepObject')
      const a = 20
      const i = '[]'
      const s = '['
      const l = ']'
      const u = '.'
      function d(m, p, f = 0, g, y) {
        const {
          nestingSyntax: E = t.defaultOptions.nestingSyntax,
          arrayRepeat: b = t.defaultOptions.arrayRepeat,
          arrayRepeatSyntax: x = t.defaultOptions.arrayRepeatSyntax,
          nesting: S = t.defaultOptions.nesting,
          delimiter: T = t.defaultOptions.delimiter,
          valueSerializer: _ = t.defaultOptions.valueSerializer,
          shouldSerializeObject: O = t.defaultOptions.shouldSerializeObject,
        } = p
        const k = typeof T === 'number' ? String.fromCharCode(T) : T
        const B = y === !0 && b
        const P = E === 'dot' || (E === 'js' && !y)
        if (f > a) return ''
        let L = ''
        let j = !0
        let U = !1
        for (const $ in m) {
          const v = m[$]
          let A
          ;(g
            ? ((A = g),
              B
                ? x === 'bracket' && (A += i)
                : P
                  ? ((A += u), (A += $))
                  : ((A += s), (A += $), (A += l)))
            : (A = $),
            j || (L += k),
            typeof v === 'object' && v !== null && !O(v)
              ? ((U = v.pop !== void 0),
                (S || (b && U)) && (L += d(v, p, f + 1, A, U)))
              : ((L += (0, r.encodeString)(A)), (L += '='), (L += _(v, $))),
            j && (j = !1))
        }
        return L
      }
      w(d, 'stringifyObject')
    })
    const $E = Ne((e, t) => {
      'use strict'
      const r = 12
      const n = 0
      const o = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,
        10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12,
        12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24,
        24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15,
        15, 7, 7, 7,
      ]
      function a(l) {
        let u = l.indexOf('%')
        if (u === -1) return l
        for (
          var d = l.length, m = '', p = 0, f = 0, g = u, y = r;
          u > -1 && u < d;

        ) {
          const E = s(l[u + 1], 4)
          const b = s(l[u + 2], 0)
          const x = E | b
          const S = o[x]
          if (
            ((y = o[256 + y + S]), (f = (f << 6) | (x & o[364 + S])), y === r)
          )
            ((m += l.slice(p, g)),
              (m +=
                f <= 65535
                  ? String.fromCharCode(f)
                  : String.fromCharCode(55232 + (f >> 10), 56320 + (f & 1023))),
              (f = 0),
              (p = u + 3),
              (u = g = l.indexOf('%', p)))
          else {
            if (y === n) return null
            if (((u += 3), u < d && l.charCodeAt(u) === 37)) continue
            return null
          }
        }
        return m + l.slice(p)
      }
      w(a, 'decodeURIComponent')
      const i = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15,
      }
      function s(l, u) {
        const d = i[l]
        return d === void 0 ? 255 : d << u
      }
      ;(w(s, 'hexCodeToInt'), (t.exports = a))
    })
    const qE = Ne(e => {
      'use strict'
      const t =
        (e && e.__importDefault) ||
        function (m) {
          return m && m.__esModule ? m : { default: m }
        }
      ;(Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.numberValueDeserializer = e.numberKeyDeserializer = void 0),
        (e.parse = d))
      const r = lp()
      const n = as()
      const o = t($E())
      const a = w(m => {
        const p = Number(m)
        return Number.isNaN(p) ? m : p
      }, 'numberKeyDeserializer')
      e.numberKeyDeserializer = a
      const i = w(m => {
        const p = Number(m)
        return Number.isNaN(p) ? m : p
      }, 'numberValueDeserializer')
      e.numberValueDeserializer = i
      const s = /\+/g
      const l = w(function () {}, 'Empty')
      l.prototype = Object.create(null)
      function u(m, p, f, g, y) {
        let E = m.substring(p, f)
        return (
          g && (E = E.replace(s, ' ')),
          y && (E = (0, o.default)(E) || E),
          E
        )
      }
      w(u, 'computeKeySlice')
      function d(m, p) {
        const {
          valueDeserializer: f = n.defaultOptions.valueDeserializer,
          keyDeserializer: g = n.defaultOptions.keyDeserializer,
          arrayRepeatSyntax: y = n.defaultOptions.arrayRepeatSyntax,
          nesting: E = n.defaultOptions.nesting,
          arrayRepeat: b = n.defaultOptions.arrayRepeat,
          nestingSyntax: x = n.defaultOptions.nestingSyntax,
          delimiter: S = n.defaultOptions.delimiter,
        } = p ?? {}
        const T = typeof S === 'string' ? S.charCodeAt(0) : S
        const _ = x === 'js'
        const O = new l()
        if (typeof m !== 'string') return O
        const k = m.length
        let B = ''
        let P = -1
        let L = -1
        let j = -1
        let U = O
        let $
        let v = ''
        let A = ''
        let D = !1
        let N = !1
        let F = !1
        let M = !1
        let q = !1
        let V = !1
        let G = !1
        let se = 0
        let pe = -1
        let ae = -1
        let we = -1
        for (let ee = 0; ee < k + 1; ee++) {
          if (((se = ee !== k ? m.charCodeAt(ee) : T), se === T)) {
            if (
              ((G = L > P),
              G || (L = ee),
              j !== L - 1 &&
                ((A = u(m, j + 1, pe > -1 ? pe : L, F, D)),
                (v = g(A)),
                $ !== void 0 &&
                  (U = (0, r.getDeepObject)(U, $, v, _ && q, _ && V))),
              G || v !== '')
            ) {
              G &&
                ((B = m.slice(L + 1, ee)),
                M && (B = B.replace(s, ' ')),
                N && (B = (0, o.default)(B) || B))
              const Ce = f(B, v)
              if (b) {
                const Ve = U[v]
                Ve === void 0
                  ? pe > -1
                    ? (U[v] = [Ce])
                    : (U[v] = Ce)
                  : Ve.pop
                    ? Ve.push(Ce)
                    : (U[v] = [Ve, Ce])
              } else U[v] = Ce
            }
            ;((B = ''),
              (P = ee),
              (L = ee),
              (D = !1),
              (N = !1),
              (F = !1),
              (M = !1),
              (q = !1),
              (V = !1),
              (pe = -1),
              (j = ee),
              (U = O),
              ($ = void 0),
              (v = ''))
          } else
            se === 93
              ? (b && y === 'bracket' && we === 91 && (pe = ae),
                E &&
                  (x === 'index' || _) &&
                  L <= P &&
                  (j !== ae &&
                    ((A = u(m, j + 1, ee, F, D)),
                    (v = g(A)),
                    $ !== void 0 &&
                      (U = (0, r.getDeepObject)(U, $, v, void 0, _)),
                    ($ = v),
                    (F = !1),
                    (D = !1)),
                  (j = ee),
                  (V = !0),
                  (q = !1)))
              : se === 46
                ? E &&
                  (x === 'dot' || _) &&
                  L <= P &&
                  (j !== ae &&
                    ((A = u(m, j + 1, ee, F, D)),
                    (v = g(A)),
                    $ !== void 0 && (U = (0, r.getDeepObject)(U, $, v, _)),
                    ($ = v),
                    (F = !1),
                    (D = !1)),
                  (q = !0),
                  (V = !1),
                  (j = ee))
                : se === 91
                  ? E &&
                    (x === 'index' || _) &&
                    L <= P &&
                    (j !== ae &&
                      ((A = u(m, j + 1, ee, F, D)),
                      (v = g(A)),
                      _ &&
                        $ !== void 0 &&
                        (U = (0, r.getDeepObject)(U, $, v, _)),
                      ($ = v),
                      (F = !1),
                      (D = !1),
                      (q = !1),
                      (V = !0)),
                    (j = ee))
                  : se === 61
                    ? L <= P
                      ? (L = ee)
                      : (N = !0)
                    : se === 43
                      ? L > P
                        ? (M = !0)
                        : (F = !0)
                      : se === 37 && (L > P ? (N = !0) : (D = !0))
          ;((ae = ee), (we = se))
        }
        return O
      }
      w(d, 'parse')
    })
    const UE = Ne(e => {
      'use strict'
      ;(Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.stringify = r))
      const t = lp()
      function r(n, o) {
        if (n === null || typeof n !== 'object') return ''
        const a = o ?? {}
        return (0, t.stringifyObject)(n, a)
      }
      w(r, 'stringify')
    })
    const is = Ne(e => {
      'use strict'
      const t =
        (e && e.__createBinding) ||
        (Object.create
          ? function (a, i, s, l) {
              l === void 0 && (l = s)
              let u = Object.getOwnPropertyDescriptor(i, s)
              ;((!u ||
                ('get' in u ? !i.__esModule : u.writable || u.configurable)) &&
                (u = {
                  enumerable: !0,
                  get: w(function () {
                    return i[s]
                  }, 'get'),
                }),
                Object.defineProperty(a, l, u))
            }
          : function (a, i, s, l) {
              ;(l === void 0 && (l = s), (a[l] = i[s]))
            })
      const r =
        (e && e.__exportStar) ||
        function (a, i) {
          for (const s in a)
            s !== 'default' &&
              !Object.prototype.hasOwnProperty.call(i, s) &&
              t(i, a, s)
        }
      ;(Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.stringify = e.parse = void 0))
      const n = qE()
      Object.defineProperty(e, 'parse', {
        enumerable: !0,
        get: w(function () {
          return n.parse
        }, 'get'),
      })
      const o = UE()
      ;(Object.defineProperty(e, 'stringify', {
        enumerable: !0,
        get: w(function () {
          return o.stringify
        }, 'get'),
      }),
        r(as(), e))
    })
    const up = Ne((e, t) => {
      t.exports = {
        Aacute: '\xC1',
        aacute: '\xE1',
        Abreve: '\u0102',
        abreve: '\u0103',
        ac: '\u223E',
        acd: '\u223F',
        acE: '\u223E\u0333',
        Acirc: '\xC2',
        acirc: '\xE2',
        acute: '\xB4',
        Acy: '\u0410',
        acy: '\u0430',
        AElig: '\xC6',
        aelig: '\xE6',
        af: '\u2061',
        Afr: '\u{1D504}',
        afr: '\u{1D51E}',
        Agrave: '\xC0',
        agrave: '\xE0',
        alefsym: '\u2135',
        aleph: '\u2135',
        Alpha: '\u0391',
        alpha: '\u03B1',
        Amacr: '\u0100',
        amacr: '\u0101',
        amalg: '\u2A3F',
        amp: '&',
        AMP: '&',
        andand: '\u2A55',
        And: '\u2A53',
        and: '\u2227',
        andd: '\u2A5C',
        andslope: '\u2A58',
        andv: '\u2A5A',
        ang: '\u2220',
        ange: '\u29A4',
        angle: '\u2220',
        angmsdaa: '\u29A8',
        angmsdab: '\u29A9',
        angmsdac: '\u29AA',
        angmsdad: '\u29AB',
        angmsdae: '\u29AC',
        angmsdaf: '\u29AD',
        angmsdag: '\u29AE',
        angmsdah: '\u29AF',
        angmsd: '\u2221',
        angrt: '\u221F',
        angrtvb: '\u22BE',
        angrtvbd: '\u299D',
        angsph: '\u2222',
        angst: '\xC5',
        angzarr: '\u237C',
        Aogon: '\u0104',
        aogon: '\u0105',
        Aopf: '\u{1D538}',
        aopf: '\u{1D552}',
        apacir: '\u2A6F',
        ap: '\u2248',
        apE: '\u2A70',
        ape: '\u224A',
        apid: '\u224B',
        apos: "'",
        ApplyFunction: '\u2061',
        approx: '\u2248',
        approxeq: '\u224A',
        Aring: '\xC5',
        aring: '\xE5',
        Ascr: '\u{1D49C}',
        ascr: '\u{1D4B6}',
        Assign: '\u2254',
        ast: '*',
        asymp: '\u2248',
        asympeq: '\u224D',
        Atilde: '\xC3',
        atilde: '\xE3',
        Auml: '\xC4',
        auml: '\xE4',
        awconint: '\u2233',
        awint: '\u2A11',
        backcong: '\u224C',
        backepsilon: '\u03F6',
        backprime: '\u2035',
        backsim: '\u223D',
        backsimeq: '\u22CD',
        Backslash: '\u2216',
        Barv: '\u2AE7',
        barvee: '\u22BD',
        barwed: '\u2305',
        Barwed: '\u2306',
        barwedge: '\u2305',
        bbrk: '\u23B5',
        bbrktbrk: '\u23B6',
        bcong: '\u224C',
        Bcy: '\u0411',
        bcy: '\u0431',
        bdquo: '\u201E',
        becaus: '\u2235',
        because: '\u2235',
        Because: '\u2235',
        bemptyv: '\u29B0',
        bepsi: '\u03F6',
        bernou: '\u212C',
        Bernoullis: '\u212C',
        Beta: '\u0392',
        beta: '\u03B2',
        beth: '\u2136',
        between: '\u226C',
        Bfr: '\u{1D505}',
        bfr: '\u{1D51F}',
        bigcap: '\u22C2',
        bigcirc: '\u25EF',
        bigcup: '\u22C3',
        bigodot: '\u2A00',
        bigoplus: '\u2A01',
        bigotimes: '\u2A02',
        bigsqcup: '\u2A06',
        bigstar: '\u2605',
        bigtriangledown: '\u25BD',
        bigtriangleup: '\u25B3',
        biguplus: '\u2A04',
        bigvee: '\u22C1',
        bigwedge: '\u22C0',
        bkarow: '\u290D',
        blacklozenge: '\u29EB',
        blacksquare: '\u25AA',
        blacktriangle: '\u25B4',
        blacktriangledown: '\u25BE',
        blacktriangleleft: '\u25C2',
        blacktriangleright: '\u25B8',
        blank: '\u2423',
        blk12: '\u2592',
        blk14: '\u2591',
        blk34: '\u2593',
        block: '\u2588',
        bne: '=\u20E5',
        bnequiv: '\u2261\u20E5',
        bNot: '\u2AED',
        bnot: '\u2310',
        Bopf: '\u{1D539}',
        bopf: '\u{1D553}',
        bot: '\u22A5',
        bottom: '\u22A5',
        bowtie: '\u22C8',
        boxbox: '\u29C9',
        boxdl: '\u2510',
        boxdL: '\u2555',
        boxDl: '\u2556',
        boxDL: '\u2557',
        boxdr: '\u250C',
        boxdR: '\u2552',
        boxDr: '\u2553',
        boxDR: '\u2554',
        boxh: '\u2500',
        boxH: '\u2550',
        boxhd: '\u252C',
        boxHd: '\u2564',
        boxhD: '\u2565',
        boxHD: '\u2566',
        boxhu: '\u2534',
        boxHu: '\u2567',
        boxhU: '\u2568',
        boxHU: '\u2569',
        boxminus: '\u229F',
        boxplus: '\u229E',
        boxtimes: '\u22A0',
        boxul: '\u2518',
        boxuL: '\u255B',
        boxUl: '\u255C',
        boxUL: '\u255D',
        boxur: '\u2514',
        boxuR: '\u2558',
        boxUr: '\u2559',
        boxUR: '\u255A',
        boxv: '\u2502',
        boxV: '\u2551',
        boxvh: '\u253C',
        boxvH: '\u256A',
        boxVh: '\u256B',
        boxVH: '\u256C',
        boxvl: '\u2524',
        boxvL: '\u2561',
        boxVl: '\u2562',
        boxVL: '\u2563',
        boxvr: '\u251C',
        boxvR: '\u255E',
        boxVr: '\u255F',
        boxVR: '\u2560',
        bprime: '\u2035',
        breve: '\u02D8',
        Breve: '\u02D8',
        brvbar: '\xA6',
        bscr: '\u{1D4B7}',
        Bscr: '\u212C',
        bsemi: '\u204F',
        bsim: '\u223D',
        bsime: '\u22CD',
        bsolb: '\u29C5',
        bsol: '\\',
        bsolhsub: '\u27C8',
        bull: '\u2022',
        bullet: '\u2022',
        bump: '\u224E',
        bumpE: '\u2AAE',
        bumpe: '\u224F',
        Bumpeq: '\u224E',
        bumpeq: '\u224F',
        Cacute: '\u0106',
        cacute: '\u0107',
        capand: '\u2A44',
        capbrcup: '\u2A49',
        capcap: '\u2A4B',
        cap: '\u2229',
        Cap: '\u22D2',
        capcup: '\u2A47',
        capdot: '\u2A40',
        CapitalDifferentialD: '\u2145',
        caps: '\u2229\uFE00',
        caret: '\u2041',
        caron: '\u02C7',
        Cayleys: '\u212D',
        ccaps: '\u2A4D',
        Ccaron: '\u010C',
        ccaron: '\u010D',
        Ccedil: '\xC7',
        ccedil: '\xE7',
        Ccirc: '\u0108',
        ccirc: '\u0109',
        Cconint: '\u2230',
        ccups: '\u2A4C',
        ccupssm: '\u2A50',
        Cdot: '\u010A',
        cdot: '\u010B',
        cedil: '\xB8',
        Cedilla: '\xB8',
        cemptyv: '\u29B2',
        cent: '\xA2',
        centerdot: '\xB7',
        CenterDot: '\xB7',
        cfr: '\u{1D520}',
        Cfr: '\u212D',
        CHcy: '\u0427',
        chcy: '\u0447',
        check: '\u2713',
        checkmark: '\u2713',
        Chi: '\u03A7',
        chi: '\u03C7',
        circ: '\u02C6',
        circeq: '\u2257',
        circlearrowleft: '\u21BA',
        circlearrowright: '\u21BB',
        circledast: '\u229B',
        circledcirc: '\u229A',
        circleddash: '\u229D',
        CircleDot: '\u2299',
        circledR: '\xAE',
        circledS: '\u24C8',
        CircleMinus: '\u2296',
        CirclePlus: '\u2295',
        CircleTimes: '\u2297',
        cir: '\u25CB',
        cirE: '\u29C3',
        cire: '\u2257',
        cirfnint: '\u2A10',
        cirmid: '\u2AEF',
        cirscir: '\u29C2',
        ClockwiseContourIntegral: '\u2232',
        CloseCurlyDoubleQuote: '\u201D',
        CloseCurlyQuote: '\u2019',
        clubs: '\u2663',
        clubsuit: '\u2663',
        colon: ':',
        Colon: '\u2237',
        Colone: '\u2A74',
        colone: '\u2254',
        coloneq: '\u2254',
        comma: ',',
        commat: '@',
        comp: '\u2201',
        compfn: '\u2218',
        complement: '\u2201',
        complexes: '\u2102',
        cong: '\u2245',
        congdot: '\u2A6D',
        Congruent: '\u2261',
        conint: '\u222E',
        Conint: '\u222F',
        ContourIntegral: '\u222E',
        copf: '\u{1D554}',
        Copf: '\u2102',
        coprod: '\u2210',
        Coproduct: '\u2210',
        copy: '\xA9',
        COPY: '\xA9',
        copysr: '\u2117',
        CounterClockwiseContourIntegral: '\u2233',
        crarr: '\u21B5',
        cross: '\u2717',
        Cross: '\u2A2F',
        Cscr: '\u{1D49E}',
        cscr: '\u{1D4B8}',
        csub: '\u2ACF',
        csube: '\u2AD1',
        csup: '\u2AD0',
        csupe: '\u2AD2',
        ctdot: '\u22EF',
        cudarrl: '\u2938',
        cudarrr: '\u2935',
        cuepr: '\u22DE',
        cuesc: '\u22DF',
        cularr: '\u21B6',
        cularrp: '\u293D',
        cupbrcap: '\u2A48',
        cupcap: '\u2A46',
        CupCap: '\u224D',
        cup: '\u222A',
        Cup: '\u22D3',
        cupcup: '\u2A4A',
        cupdot: '\u228D',
        cupor: '\u2A45',
        cups: '\u222A\uFE00',
        curarr: '\u21B7',
        curarrm: '\u293C',
        curlyeqprec: '\u22DE',
        curlyeqsucc: '\u22DF',
        curlyvee: '\u22CE',
        curlywedge: '\u22CF',
        curren: '\xA4',
        curvearrowleft: '\u21B6',
        curvearrowright: '\u21B7',
        cuvee: '\u22CE',
        cuwed: '\u22CF',
        cwconint: '\u2232',
        cwint: '\u2231',
        cylcty: '\u232D',
        dagger: '\u2020',
        Dagger: '\u2021',
        daleth: '\u2138',
        darr: '\u2193',
        Darr: '\u21A1',
        dArr: '\u21D3',
        dash: '\u2010',
        Dashv: '\u2AE4',
        dashv: '\u22A3',
        dbkarow: '\u290F',
        dblac: '\u02DD',
        Dcaron: '\u010E',
        dcaron: '\u010F',
        Dcy: '\u0414',
        dcy: '\u0434',
        ddagger: '\u2021',
        ddarr: '\u21CA',
        DD: '\u2145',
        dd: '\u2146',
        DDotrahd: '\u2911',
        ddotseq: '\u2A77',
        deg: '\xB0',
        Del: '\u2207',
        Delta: '\u0394',
        delta: '\u03B4',
        demptyv: '\u29B1',
        dfisht: '\u297F',
        Dfr: '\u{1D507}',
        dfr: '\u{1D521}',
        dHar: '\u2965',
        dharl: '\u21C3',
        dharr: '\u21C2',
        DiacriticalAcute: '\xB4',
        DiacriticalDot: '\u02D9',
        DiacriticalDoubleAcute: '\u02DD',
        DiacriticalGrave: '`',
        DiacriticalTilde: '\u02DC',
        diam: '\u22C4',
        diamond: '\u22C4',
        Diamond: '\u22C4',
        diamondsuit: '\u2666',
        diams: '\u2666',
        die: '\xA8',
        DifferentialD: '\u2146',
        digamma: '\u03DD',
        disin: '\u22F2',
        div: '\xF7',
        divide: '\xF7',
        divideontimes: '\u22C7',
        divonx: '\u22C7',
        DJcy: '\u0402',
        djcy: '\u0452',
        dlcorn: '\u231E',
        dlcrop: '\u230D',
        dollar: '$',
        Dopf: '\u{1D53B}',
        dopf: '\u{1D555}',
        Dot: '\xA8',
        dot: '\u02D9',
        DotDot: '\u20DC',
        doteq: '\u2250',
        doteqdot: '\u2251',
        DotEqual: '\u2250',
        dotminus: '\u2238',
        dotplus: '\u2214',
        dotsquare: '\u22A1',
        doublebarwedge: '\u2306',
        DoubleContourIntegral: '\u222F',
        DoubleDot: '\xA8',
        DoubleDownArrow: '\u21D3',
        DoubleLeftArrow: '\u21D0',
        DoubleLeftRightArrow: '\u21D4',
        DoubleLeftTee: '\u2AE4',
        DoubleLongLeftArrow: '\u27F8',
        DoubleLongLeftRightArrow: '\u27FA',
        DoubleLongRightArrow: '\u27F9',
        DoubleRightArrow: '\u21D2',
        DoubleRightTee: '\u22A8',
        DoubleUpArrow: '\u21D1',
        DoubleUpDownArrow: '\u21D5',
        DoubleVerticalBar: '\u2225',
        DownArrowBar: '\u2913',
        downarrow: '\u2193',
        DownArrow: '\u2193',
        Downarrow: '\u21D3',
        DownArrowUpArrow: '\u21F5',
        DownBreve: '\u0311',
        downdownarrows: '\u21CA',
        downharpoonleft: '\u21C3',
        downharpoonright: '\u21C2',
        DownLeftRightVector: '\u2950',
        DownLeftTeeVector: '\u295E',
        DownLeftVectorBar: '\u2956',
        DownLeftVector: '\u21BD',
        DownRightTeeVector: '\u295F',
        DownRightVectorBar: '\u2957',
        DownRightVector: '\u21C1',
        DownTeeArrow: '\u21A7',
        DownTee: '\u22A4',
        drbkarow: '\u2910',
        drcorn: '\u231F',
        drcrop: '\u230C',
        Dscr: '\u{1D49F}',
        dscr: '\u{1D4B9}',
        DScy: '\u0405',
        dscy: '\u0455',
        dsol: '\u29F6',
        Dstrok: '\u0110',
        dstrok: '\u0111',
        dtdot: '\u22F1',
        dtri: '\u25BF',
        dtrif: '\u25BE',
        duarr: '\u21F5',
        duhar: '\u296F',
        dwangle: '\u29A6',
        DZcy: '\u040F',
        dzcy: '\u045F',
        dzigrarr: '\u27FF',
        Eacute: '\xC9',
        eacute: '\xE9',
        easter: '\u2A6E',
        Ecaron: '\u011A',
        ecaron: '\u011B',
        Ecirc: '\xCA',
        ecirc: '\xEA',
        ecir: '\u2256',
        ecolon: '\u2255',
        Ecy: '\u042D',
        ecy: '\u044D',
        eDDot: '\u2A77',
        Edot: '\u0116',
        edot: '\u0117',
        eDot: '\u2251',
        ee: '\u2147',
        efDot: '\u2252',
        Efr: '\u{1D508}',
        efr: '\u{1D522}',
        eg: '\u2A9A',
        Egrave: '\xC8',
        egrave: '\xE8',
        egs: '\u2A96',
        egsdot: '\u2A98',
        el: '\u2A99',
        Element: '\u2208',
        elinters: '\u23E7',
        ell: '\u2113',
        els: '\u2A95',
        elsdot: '\u2A97',
        Emacr: '\u0112',
        emacr: '\u0113',
        empty: '\u2205',
        emptyset: '\u2205',
        EmptySmallSquare: '\u25FB',
        emptyv: '\u2205',
        EmptyVerySmallSquare: '\u25AB',
        emsp13: '\u2004',
        emsp14: '\u2005',
        emsp: '\u2003',
        ENG: '\u014A',
        eng: '\u014B',
        ensp: '\u2002',
        Eogon: '\u0118',
        eogon: '\u0119',
        Eopf: '\u{1D53C}',
        eopf: '\u{1D556}',
        epar: '\u22D5',
        eparsl: '\u29E3',
        eplus: '\u2A71',
        epsi: '\u03B5',
        Epsilon: '\u0395',
        epsilon: '\u03B5',
        epsiv: '\u03F5',
        eqcirc: '\u2256',
        eqcolon: '\u2255',
        eqsim: '\u2242',
        eqslantgtr: '\u2A96',
        eqslantless: '\u2A95',
        Equal: '\u2A75',
        equals: '=',
        EqualTilde: '\u2242',
        equest: '\u225F',
        Equilibrium: '\u21CC',
        equiv: '\u2261',
        equivDD: '\u2A78',
        eqvparsl: '\u29E5',
        erarr: '\u2971',
        erDot: '\u2253',
        escr: '\u212F',
        Escr: '\u2130',
        esdot: '\u2250',
        Esim: '\u2A73',
        esim: '\u2242',
        Eta: '\u0397',
        eta: '\u03B7',
        ETH: '\xD0',
        eth: '\xF0',
        Euml: '\xCB',
        euml: '\xEB',
        euro: '\u20AC',
        excl: '!',
        exist: '\u2203',
        Exists: '\u2203',
        expectation: '\u2130',
        exponentiale: '\u2147',
        ExponentialE: '\u2147',
        fallingdotseq: '\u2252',
        Fcy: '\u0424',
        fcy: '\u0444',
        female: '\u2640',
        ffilig: '\uFB03',
        fflig: '\uFB00',
        ffllig: '\uFB04',
        Ffr: '\u{1D509}',
        ffr: '\u{1D523}',
        filig: '\uFB01',
        FilledSmallSquare: '\u25FC',
        FilledVerySmallSquare: '\u25AA',
        fjlig: 'fj',
        flat: '\u266D',
        fllig: '\uFB02',
        fltns: '\u25B1',
        fnof: '\u0192',
        Fopf: '\u{1D53D}',
        fopf: '\u{1D557}',
        forall: '\u2200',
        ForAll: '\u2200',
        fork: '\u22D4',
        forkv: '\u2AD9',
        Fouriertrf: '\u2131',
        fpartint: '\u2A0D',
        frac12: '\xBD',
        frac13: '\u2153',
        frac14: '\xBC',
        frac15: '\u2155',
        frac16: '\u2159',
        frac18: '\u215B',
        frac23: '\u2154',
        frac25: '\u2156',
        frac34: '\xBE',
        frac35: '\u2157',
        frac38: '\u215C',
        frac45: '\u2158',
        frac56: '\u215A',
        frac58: '\u215D',
        frac78: '\u215E',
        frasl: '\u2044',
        frown: '\u2322',
        fscr: '\u{1D4BB}',
        Fscr: '\u2131',
        gacute: '\u01F5',
        Gamma: '\u0393',
        gamma: '\u03B3',
        Gammad: '\u03DC',
        gammad: '\u03DD',
        gap: '\u2A86',
        Gbreve: '\u011E',
        gbreve: '\u011F',
        Gcedil: '\u0122',
        Gcirc: '\u011C',
        gcirc: '\u011D',
        Gcy: '\u0413',
        gcy: '\u0433',
        Gdot: '\u0120',
        gdot: '\u0121',
        ge: '\u2265',
        gE: '\u2267',
        gEl: '\u2A8C',
        gel: '\u22DB',
        geq: '\u2265',
        geqq: '\u2267',
        geqslant: '\u2A7E',
        gescc: '\u2AA9',
        ges: '\u2A7E',
        gesdot: '\u2A80',
        gesdoto: '\u2A82',
        gesdotol: '\u2A84',
        gesl: '\u22DB\uFE00',
        gesles: '\u2A94',
        Gfr: '\u{1D50A}',
        gfr: '\u{1D524}',
        gg: '\u226B',
        Gg: '\u22D9',
        ggg: '\u22D9',
        gimel: '\u2137',
        GJcy: '\u0403',
        gjcy: '\u0453',
        gla: '\u2AA5',
        gl: '\u2277',
        glE: '\u2A92',
        glj: '\u2AA4',
        gnap: '\u2A8A',
        gnapprox: '\u2A8A',
        gne: '\u2A88',
        gnE: '\u2269',
        gneq: '\u2A88',
        gneqq: '\u2269',
        gnsim: '\u22E7',
        Gopf: '\u{1D53E}',
        gopf: '\u{1D558}',
        grave: '`',
        GreaterEqual: '\u2265',
        GreaterEqualLess: '\u22DB',
        GreaterFullEqual: '\u2267',
        GreaterGreater: '\u2AA2',
        GreaterLess: '\u2277',
        GreaterSlantEqual: '\u2A7E',
        GreaterTilde: '\u2273',
        Gscr: '\u{1D4A2}',
        gscr: '\u210A',
        gsim: '\u2273',
        gsime: '\u2A8E',
        gsiml: '\u2A90',
        gtcc: '\u2AA7',
        gtcir: '\u2A7A',
        gt: '>',
        GT: '>',
        Gt: '\u226B',
        gtdot: '\u22D7',
        gtlPar: '\u2995',
        gtquest: '\u2A7C',
        gtrapprox: '\u2A86',
        gtrarr: '\u2978',
        gtrdot: '\u22D7',
        gtreqless: '\u22DB',
        gtreqqless: '\u2A8C',
        gtrless: '\u2277',
        gtrsim: '\u2273',
        gvertneqq: '\u2269\uFE00',
        gvnE: '\u2269\uFE00',
        Hacek: '\u02C7',
        hairsp: '\u200A',
        half: '\xBD',
        hamilt: '\u210B',
        HARDcy: '\u042A',
        hardcy: '\u044A',
        harrcir: '\u2948',
        harr: '\u2194',
        hArr: '\u21D4',
        harrw: '\u21AD',
        Hat: '^',
        hbar: '\u210F',
        Hcirc: '\u0124',
        hcirc: '\u0125',
        hearts: '\u2665',
        heartsuit: '\u2665',
        hellip: '\u2026',
        hercon: '\u22B9',
        hfr: '\u{1D525}',
        Hfr: '\u210C',
        HilbertSpace: '\u210B',
        hksearow: '\u2925',
        hkswarow: '\u2926',
        hoarr: '\u21FF',
        homtht: '\u223B',
        hookleftarrow: '\u21A9',
        hookrightarrow: '\u21AA',
        hopf: '\u{1D559}',
        Hopf: '\u210D',
        horbar: '\u2015',
        HorizontalLine: '\u2500',
        hscr: '\u{1D4BD}',
        Hscr: '\u210B',
        hslash: '\u210F',
        Hstrok: '\u0126',
        hstrok: '\u0127',
        HumpDownHump: '\u224E',
        HumpEqual: '\u224F',
        hybull: '\u2043',
        hyphen: '\u2010',
        Iacute: '\xCD',
        iacute: '\xED',
        ic: '\u2063',
        Icirc: '\xCE',
        icirc: '\xEE',
        Icy: '\u0418',
        icy: '\u0438',
        Idot: '\u0130',
        IEcy: '\u0415',
        iecy: '\u0435',
        iexcl: '\xA1',
        iff: '\u21D4',
        ifr: '\u{1D526}',
        Ifr: '\u2111',
        Igrave: '\xCC',
        igrave: '\xEC',
        ii: '\u2148',
        iiiint: '\u2A0C',
        iiint: '\u222D',
        iinfin: '\u29DC',
        iiota: '\u2129',
        IJlig: '\u0132',
        ijlig: '\u0133',
        Imacr: '\u012A',
        imacr: '\u012B',
        image: '\u2111',
        ImaginaryI: '\u2148',
        imagline: '\u2110',
        imagpart: '\u2111',
        imath: '\u0131',
        Im: '\u2111',
        imof: '\u22B7',
        imped: '\u01B5',
        Implies: '\u21D2',
        incare: '\u2105',
        in: '\u2208',
        infin: '\u221E',
        infintie: '\u29DD',
        inodot: '\u0131',
        intcal: '\u22BA',
        int: '\u222B',
        Int: '\u222C',
        integers: '\u2124',
        Integral: '\u222B',
        intercal: '\u22BA',
        Intersection: '\u22C2',
        intlarhk: '\u2A17',
        intprod: '\u2A3C',
        InvisibleComma: '\u2063',
        InvisibleTimes: '\u2062',
        IOcy: '\u0401',
        iocy: '\u0451',
        Iogon: '\u012E',
        iogon: '\u012F',
        Iopf: '\u{1D540}',
        iopf: '\u{1D55A}',
        Iota: '\u0399',
        iota: '\u03B9',
        iprod: '\u2A3C',
        iquest: '\xBF',
        iscr: '\u{1D4BE}',
        Iscr: '\u2110',
        isin: '\u2208',
        isindot: '\u22F5',
        isinE: '\u22F9',
        isins: '\u22F4',
        isinsv: '\u22F3',
        isinv: '\u2208',
        it: '\u2062',
        Itilde: '\u0128',
        itilde: '\u0129',
        Iukcy: '\u0406',
        iukcy: '\u0456',
        Iuml: '\xCF',
        iuml: '\xEF',
        Jcirc: '\u0134',
        jcirc: '\u0135',
        Jcy: '\u0419',
        jcy: '\u0439',
        Jfr: '\u{1D50D}',
        jfr: '\u{1D527}',
        jmath: '\u0237',
        Jopf: '\u{1D541}',
        jopf: '\u{1D55B}',
        Jscr: '\u{1D4A5}',
        jscr: '\u{1D4BF}',
        Jsercy: '\u0408',
        jsercy: '\u0458',
        Jukcy: '\u0404',
        jukcy: '\u0454',
        Kappa: '\u039A',
        kappa: '\u03BA',
        kappav: '\u03F0',
        Kcedil: '\u0136',
        kcedil: '\u0137',
        Kcy: '\u041A',
        kcy: '\u043A',
        Kfr: '\u{1D50E}',
        kfr: '\u{1D528}',
        kgreen: '\u0138',
        KHcy: '\u0425',
        khcy: '\u0445',
        KJcy: '\u040C',
        kjcy: '\u045C',
        Kopf: '\u{1D542}',
        kopf: '\u{1D55C}',
        Kscr: '\u{1D4A6}',
        kscr: '\u{1D4C0}',
        lAarr: '\u21DA',
        Lacute: '\u0139',
        lacute: '\u013A',
        laemptyv: '\u29B4',
        lagran: '\u2112',
        Lambda: '\u039B',
        lambda: '\u03BB',
        lang: '\u27E8',
        Lang: '\u27EA',
        langd: '\u2991',
        langle: '\u27E8',
        lap: '\u2A85',
        Laplacetrf: '\u2112',
        laquo: '\xAB',
        larrb: '\u21E4',
        larrbfs: '\u291F',
        larr: '\u2190',
        Larr: '\u219E',
        lArr: '\u21D0',
        larrfs: '\u291D',
        larrhk: '\u21A9',
        larrlp: '\u21AB',
        larrpl: '\u2939',
        larrsim: '\u2973',
        larrtl: '\u21A2',
        latail: '\u2919',
        lAtail: '\u291B',
        lat: '\u2AAB',
        late: '\u2AAD',
        lates: '\u2AAD\uFE00',
        lbarr: '\u290C',
        lBarr: '\u290E',
        lbbrk: '\u2772',
        lbrace: '{',
        lbrack: '[',
        lbrke: '\u298B',
        lbrksld: '\u298F',
        lbrkslu: '\u298D',
        Lcaron: '\u013D',
        lcaron: '\u013E',
        Lcedil: '\u013B',
        lcedil: '\u013C',
        lceil: '\u2308',
        lcub: '{',
        Lcy: '\u041B',
        lcy: '\u043B',
        ldca: '\u2936',
        ldquo: '\u201C',
        ldquor: '\u201E',
        ldrdhar: '\u2967',
        ldrushar: '\u294B',
        ldsh: '\u21B2',
        le: '\u2264',
        lE: '\u2266',
        LeftAngleBracket: '\u27E8',
        LeftArrowBar: '\u21E4',
        leftarrow: '\u2190',
        LeftArrow: '\u2190',
        Leftarrow: '\u21D0',
        LeftArrowRightArrow: '\u21C6',
        leftarrowtail: '\u21A2',
        LeftCeiling: '\u2308',
        LeftDoubleBracket: '\u27E6',
        LeftDownTeeVector: '\u2961',
        LeftDownVectorBar: '\u2959',
        LeftDownVector: '\u21C3',
        LeftFloor: '\u230A',
        leftharpoondown: '\u21BD',
        leftharpoonup: '\u21BC',
        leftleftarrows: '\u21C7',
        leftrightarrow: '\u2194',
        LeftRightArrow: '\u2194',
        Leftrightarrow: '\u21D4',
        leftrightarrows: '\u21C6',
        leftrightharpoons: '\u21CB',
        leftrightsquigarrow: '\u21AD',
        LeftRightVector: '\u294E',
        LeftTeeArrow: '\u21A4',
        LeftTee: '\u22A3',
        LeftTeeVector: '\u295A',
        leftthreetimes: '\u22CB',
        LeftTriangleBar: '\u29CF',
        LeftTriangle: '\u22B2',
        LeftTriangleEqual: '\u22B4',
        LeftUpDownVector: '\u2951',
        LeftUpTeeVector: '\u2960',
        LeftUpVectorBar: '\u2958',
        LeftUpVector: '\u21BF',
        LeftVectorBar: '\u2952',
        LeftVector: '\u21BC',
        lEg: '\u2A8B',
        leg: '\u22DA',
        leq: '\u2264',
        leqq: '\u2266',
        leqslant: '\u2A7D',
        lescc: '\u2AA8',
        les: '\u2A7D',
        lesdot: '\u2A7F',
        lesdoto: '\u2A81',
        lesdotor: '\u2A83',
        lesg: '\u22DA\uFE00',
        lesges: '\u2A93',
        lessapprox: '\u2A85',
        lessdot: '\u22D6',
        lesseqgtr: '\u22DA',
        lesseqqgtr: '\u2A8B',
        LessEqualGreater: '\u22DA',
        LessFullEqual: '\u2266',
        LessGreater: '\u2276',
        lessgtr: '\u2276',
        LessLess: '\u2AA1',
        lesssim: '\u2272',
        LessSlantEqual: '\u2A7D',
        LessTilde: '\u2272',
        lfisht: '\u297C',
        lfloor: '\u230A',
        Lfr: '\u{1D50F}',
        lfr: '\u{1D529}',
        lg: '\u2276',
        lgE: '\u2A91',
        lHar: '\u2962',
        lhard: '\u21BD',
        lharu: '\u21BC',
        lharul: '\u296A',
        lhblk: '\u2584',
        LJcy: '\u0409',
        ljcy: '\u0459',
        llarr: '\u21C7',
        ll: '\u226A',
        Ll: '\u22D8',
        llcorner: '\u231E',
        Lleftarrow: '\u21DA',
        llhard: '\u296B',
        lltri: '\u25FA',
        Lmidot: '\u013F',
        lmidot: '\u0140',
        lmoustache: '\u23B0',
        lmoust: '\u23B0',
        lnap: '\u2A89',
        lnapprox: '\u2A89',
        lne: '\u2A87',
        lnE: '\u2268',
        lneq: '\u2A87',
        lneqq: '\u2268',
        lnsim: '\u22E6',
        loang: '\u27EC',
        loarr: '\u21FD',
        lobrk: '\u27E6',
        longleftarrow: '\u27F5',
        LongLeftArrow: '\u27F5',
        Longleftarrow: '\u27F8',
        longleftrightarrow: '\u27F7',
        LongLeftRightArrow: '\u27F7',
        Longleftrightarrow: '\u27FA',
        longmapsto: '\u27FC',
        longrightarrow: '\u27F6',
        LongRightArrow: '\u27F6',
        Longrightarrow: '\u27F9',
        looparrowleft: '\u21AB',
        looparrowright: '\u21AC',
        lopar: '\u2985',
        Lopf: '\u{1D543}',
        lopf: '\u{1D55D}',
        loplus: '\u2A2D',
        lotimes: '\u2A34',
        lowast: '\u2217',
        lowbar: '_',
        LowerLeftArrow: '\u2199',
        LowerRightArrow: '\u2198',
        loz: '\u25CA',
        lozenge: '\u25CA',
        lozf: '\u29EB',
        lpar: '(',
        lparlt: '\u2993',
        lrarr: '\u21C6',
        lrcorner: '\u231F',
        lrhar: '\u21CB',
        lrhard: '\u296D',
        lrm: '\u200E',
        lrtri: '\u22BF',
        lsaquo: '\u2039',
        lscr: '\u{1D4C1}',
        Lscr: '\u2112',
        lsh: '\u21B0',
        Lsh: '\u21B0',
        lsim: '\u2272',
        lsime: '\u2A8D',
        lsimg: '\u2A8F',
        lsqb: '[',
        lsquo: '\u2018',
        lsquor: '\u201A',
        Lstrok: '\u0141',
        lstrok: '\u0142',
        ltcc: '\u2AA6',
        ltcir: '\u2A79',
        lt: '<',
        LT: '<',
        Lt: '\u226A',
        ltdot: '\u22D6',
        lthree: '\u22CB',
        ltimes: '\u22C9',
        ltlarr: '\u2976',
        ltquest: '\u2A7B',
        ltri: '\u25C3',
        ltrie: '\u22B4',
        ltrif: '\u25C2',
        ltrPar: '\u2996',
        lurdshar: '\u294A',
        luruhar: '\u2966',
        lvertneqq: '\u2268\uFE00',
        lvnE: '\u2268\uFE00',
        macr: '\xAF',
        male: '\u2642',
        malt: '\u2720',
        maltese: '\u2720',
        Map: '\u2905',
        map: '\u21A6',
        mapsto: '\u21A6',
        mapstodown: '\u21A7',
        mapstoleft: '\u21A4',
        mapstoup: '\u21A5',
        marker: '\u25AE',
        mcomma: '\u2A29',
        Mcy: '\u041C',
        mcy: '\u043C',
        mdash: '\u2014',
        mDDot: '\u223A',
        measuredangle: '\u2221',
        MediumSpace: '\u205F',
        Mellintrf: '\u2133',
        Mfr: '\u{1D510}',
        mfr: '\u{1D52A}',
        mho: '\u2127',
        micro: '\xB5',
        midast: '*',
        midcir: '\u2AF0',
        mid: '\u2223',
        middot: '\xB7',
        minusb: '\u229F',
        minus: '\u2212',
        minusd: '\u2238',
        minusdu: '\u2A2A',
        MinusPlus: '\u2213',
        mlcp: '\u2ADB',
        mldr: '\u2026',
        mnplus: '\u2213',
        models: '\u22A7',
        Mopf: '\u{1D544}',
        mopf: '\u{1D55E}',
        mp: '\u2213',
        mscr: '\u{1D4C2}',
        Mscr: '\u2133',
        mstpos: '\u223E',
        Mu: '\u039C',
        mu: '\u03BC',
        multimap: '\u22B8',
        mumap: '\u22B8',
        nabla: '\u2207',
        Nacute: '\u0143',
        nacute: '\u0144',
        nang: '\u2220\u20D2',
        nap: '\u2249',
        napE: '\u2A70\u0338',
        napid: '\u224B\u0338',
        napos: '\u0149',
        napprox: '\u2249',
        natural: '\u266E',
        naturals: '\u2115',
        natur: '\u266E',
        nbsp: '\xA0',
        nbump: '\u224E\u0338',
        nbumpe: '\u224F\u0338',
        ncap: '\u2A43',
        Ncaron: '\u0147',
        ncaron: '\u0148',
        Ncedil: '\u0145',
        ncedil: '\u0146',
        ncong: '\u2247',
        ncongdot: '\u2A6D\u0338',
        ncup: '\u2A42',
        Ncy: '\u041D',
        ncy: '\u043D',
        ndash: '\u2013',
        nearhk: '\u2924',
        nearr: '\u2197',
        neArr: '\u21D7',
        nearrow: '\u2197',
        ne: '\u2260',
        nedot: '\u2250\u0338',
        NegativeMediumSpace: '\u200B',
        NegativeThickSpace: '\u200B',
        NegativeThinSpace: '\u200B',
        NegativeVeryThinSpace: '\u200B',
        nequiv: '\u2262',
        nesear: '\u2928',
        nesim: '\u2242\u0338',
        NestedGreaterGreater: '\u226B',
        NestedLessLess: '\u226A',
        NewLine: `
`,
        nexist: '\u2204',
        nexists: '\u2204',
        Nfr: '\u{1D511}',
        nfr: '\u{1D52B}',
        ngE: '\u2267\u0338',
        nge: '\u2271',
        ngeq: '\u2271',
        ngeqq: '\u2267\u0338',
        ngeqslant: '\u2A7E\u0338',
        nges: '\u2A7E\u0338',
        nGg: '\u22D9\u0338',
        ngsim: '\u2275',
        nGt: '\u226B\u20D2',
        ngt: '\u226F',
        ngtr: '\u226F',
        nGtv: '\u226B\u0338',
        nharr: '\u21AE',
        nhArr: '\u21CE',
        nhpar: '\u2AF2',
        ni: '\u220B',
        nis: '\u22FC',
        nisd: '\u22FA',
        niv: '\u220B',
        NJcy: '\u040A',
        njcy: '\u045A',
        nlarr: '\u219A',
        nlArr: '\u21CD',
        nldr: '\u2025',
        nlE: '\u2266\u0338',
        nle: '\u2270',
        nleftarrow: '\u219A',
        nLeftarrow: '\u21CD',
        nleftrightarrow: '\u21AE',
        nLeftrightarrow: '\u21CE',
        nleq: '\u2270',
        nleqq: '\u2266\u0338',
        nleqslant: '\u2A7D\u0338',
        nles: '\u2A7D\u0338',
        nless: '\u226E',
        nLl: '\u22D8\u0338',
        nlsim: '\u2274',
        nLt: '\u226A\u20D2',
        nlt: '\u226E',
        nltri: '\u22EA',
        nltrie: '\u22EC',
        nLtv: '\u226A\u0338',
        nmid: '\u2224',
        NoBreak: '\u2060',
        NonBreakingSpace: '\xA0',
        nopf: '\u{1D55F}',
        Nopf: '\u2115',
        Not: '\u2AEC',
        not: '\xAC',
        NotCongruent: '\u2262',
        NotCupCap: '\u226D',
        NotDoubleVerticalBar: '\u2226',
        NotElement: '\u2209',
        NotEqual: '\u2260',
        NotEqualTilde: '\u2242\u0338',
        NotExists: '\u2204',
        NotGreater: '\u226F',
        NotGreaterEqual: '\u2271',
        NotGreaterFullEqual: '\u2267\u0338',
        NotGreaterGreater: '\u226B\u0338',
        NotGreaterLess: '\u2279',
        NotGreaterSlantEqual: '\u2A7E\u0338',
        NotGreaterTilde: '\u2275',
        NotHumpDownHump: '\u224E\u0338',
        NotHumpEqual: '\u224F\u0338',
        notin: '\u2209',
        notindot: '\u22F5\u0338',
        notinE: '\u22F9\u0338',
        notinva: '\u2209',
        notinvb: '\u22F7',
        notinvc: '\u22F6',
        NotLeftTriangleBar: '\u29CF\u0338',
        NotLeftTriangle: '\u22EA',
        NotLeftTriangleEqual: '\u22EC',
        NotLess: '\u226E',
        NotLessEqual: '\u2270',
        NotLessGreater: '\u2278',
        NotLessLess: '\u226A\u0338',
        NotLessSlantEqual: '\u2A7D\u0338',
        NotLessTilde: '\u2274',
        NotNestedGreaterGreater: '\u2AA2\u0338',
        NotNestedLessLess: '\u2AA1\u0338',
        notni: '\u220C',
        notniva: '\u220C',
        notnivb: '\u22FE',
        notnivc: '\u22FD',
        NotPrecedes: '\u2280',
        NotPrecedesEqual: '\u2AAF\u0338',
        NotPrecedesSlantEqual: '\u22E0',
        NotReverseElement: '\u220C',
        NotRightTriangleBar: '\u29D0\u0338',
        NotRightTriangle: '\u22EB',
        NotRightTriangleEqual: '\u22ED',
        NotSquareSubset: '\u228F\u0338',
        NotSquareSubsetEqual: '\u22E2',
        NotSquareSuperset: '\u2290\u0338',
        NotSquareSupersetEqual: '\u22E3',
        NotSubset: '\u2282\u20D2',
        NotSubsetEqual: '\u2288',
        NotSucceeds: '\u2281',
        NotSucceedsEqual: '\u2AB0\u0338',
        NotSucceedsSlantEqual: '\u22E1',
        NotSucceedsTilde: '\u227F\u0338',
        NotSuperset: '\u2283\u20D2',
        NotSupersetEqual: '\u2289',
        NotTilde: '\u2241',
        NotTildeEqual: '\u2244',
        NotTildeFullEqual: '\u2247',
        NotTildeTilde: '\u2249',
        NotVerticalBar: '\u2224',
        nparallel: '\u2226',
        npar: '\u2226',
        nparsl: '\u2AFD\u20E5',
        npart: '\u2202\u0338',
        npolint: '\u2A14',
        npr: '\u2280',
        nprcue: '\u22E0',
        nprec: '\u2280',
        npreceq: '\u2AAF\u0338',
        npre: '\u2AAF\u0338',
        nrarrc: '\u2933\u0338',
        nrarr: '\u219B',
        nrArr: '\u21CF',
        nrarrw: '\u219D\u0338',
        nrightarrow: '\u219B',
        nRightarrow: '\u21CF',
        nrtri: '\u22EB',
        nrtrie: '\u22ED',
        nsc: '\u2281',
        nsccue: '\u22E1',
        nsce: '\u2AB0\u0338',
        Nscr: '\u{1D4A9}',
        nscr: '\u{1D4C3}',
        nshortmid: '\u2224',
        nshortparallel: '\u2226',
        nsim: '\u2241',
        nsime: '\u2244',
        nsimeq: '\u2244',
        nsmid: '\u2224',
        nspar: '\u2226',
        nsqsube: '\u22E2',
        nsqsupe: '\u22E3',
        nsub: '\u2284',
        nsubE: '\u2AC5\u0338',
        nsube: '\u2288',
        nsubset: '\u2282\u20D2',
        nsubseteq: '\u2288',
        nsubseteqq: '\u2AC5\u0338',
        nsucc: '\u2281',
        nsucceq: '\u2AB0\u0338',
        nsup: '\u2285',
        nsupE: '\u2AC6\u0338',
        nsupe: '\u2289',
        nsupset: '\u2283\u20D2',
        nsupseteq: '\u2289',
        nsupseteqq: '\u2AC6\u0338',
        ntgl: '\u2279',
        Ntilde: '\xD1',
        ntilde: '\xF1',
        ntlg: '\u2278',
        ntriangleleft: '\u22EA',
        ntrianglelefteq: '\u22EC',
        ntriangleright: '\u22EB',
        ntrianglerighteq: '\u22ED',
        Nu: '\u039D',
        nu: '\u03BD',
        num: '#',
        numero: '\u2116',
        numsp: '\u2007',
        nvap: '\u224D\u20D2',
        nvdash: '\u22AC',
        nvDash: '\u22AD',
        nVdash: '\u22AE',
        nVDash: '\u22AF',
        nvge: '\u2265\u20D2',
        nvgt: '>\u20D2',
        nvHarr: '\u2904',
        nvinfin: '\u29DE',
        nvlArr: '\u2902',
        nvle: '\u2264\u20D2',
        nvlt: '<\u20D2',
        nvltrie: '\u22B4\u20D2',
        nvrArr: '\u2903',
        nvrtrie: '\u22B5\u20D2',
        nvsim: '\u223C\u20D2',
        nwarhk: '\u2923',
        nwarr: '\u2196',
        nwArr: '\u21D6',
        nwarrow: '\u2196',
        nwnear: '\u2927',
        Oacute: '\xD3',
        oacute: '\xF3',
        oast: '\u229B',
        Ocirc: '\xD4',
        ocirc: '\xF4',
        ocir: '\u229A',
        Ocy: '\u041E',
        ocy: '\u043E',
        odash: '\u229D',
        Odblac: '\u0150',
        odblac: '\u0151',
        odiv: '\u2A38',
        odot: '\u2299',
        odsold: '\u29BC',
        OElig: '\u0152',
        oelig: '\u0153',
        ofcir: '\u29BF',
        Ofr: '\u{1D512}',
        ofr: '\u{1D52C}',
        ogon: '\u02DB',
        Ograve: '\xD2',
        ograve: '\xF2',
        ogt: '\u29C1',
        ohbar: '\u29B5',
        ohm: '\u03A9',
        oint: '\u222E',
        olarr: '\u21BA',
        olcir: '\u29BE',
        olcross: '\u29BB',
        oline: '\u203E',
        olt: '\u29C0',
        Omacr: '\u014C',
        omacr: '\u014D',
        Omega: '\u03A9',
        omega: '\u03C9',
        Omicron: '\u039F',
        omicron: '\u03BF',
        omid: '\u29B6',
        ominus: '\u2296',
        Oopf: '\u{1D546}',
        oopf: '\u{1D560}',
        opar: '\u29B7',
        OpenCurlyDoubleQuote: '\u201C',
        OpenCurlyQuote: '\u2018',
        operp: '\u29B9',
        oplus: '\u2295',
        orarr: '\u21BB',
        Or: '\u2A54',
        or: '\u2228',
        ord: '\u2A5D',
        order: '\u2134',
        orderof: '\u2134',
        ordf: '\xAA',
        ordm: '\xBA',
        origof: '\u22B6',
        oror: '\u2A56',
        orslope: '\u2A57',
        orv: '\u2A5B',
        oS: '\u24C8',
        Oscr: '\u{1D4AA}',
        oscr: '\u2134',
        Oslash: '\xD8',
        oslash: '\xF8',
        osol: '\u2298',
        Otilde: '\xD5',
        otilde: '\xF5',
        otimesas: '\u2A36',
        Otimes: '\u2A37',
        otimes: '\u2297',
        Ouml: '\xD6',
        ouml: '\xF6',
        ovbar: '\u233D',
        OverBar: '\u203E',
        OverBrace: '\u23DE',
        OverBracket: '\u23B4',
        OverParenthesis: '\u23DC',
        para: '\xB6',
        parallel: '\u2225',
        par: '\u2225',
        parsim: '\u2AF3',
        parsl: '\u2AFD',
        part: '\u2202',
        PartialD: '\u2202',
        Pcy: '\u041F',
        pcy: '\u043F',
        percnt: '%',
        period: '.',
        permil: '\u2030',
        perp: '\u22A5',
        pertenk: '\u2031',
        Pfr: '\u{1D513}',
        pfr: '\u{1D52D}',
        Phi: '\u03A6',
        phi: '\u03C6',
        phiv: '\u03D5',
        phmmat: '\u2133',
        phone: '\u260E',
        Pi: '\u03A0',
        pi: '\u03C0',
        pitchfork: '\u22D4',
        piv: '\u03D6',
        planck: '\u210F',
        planckh: '\u210E',
        plankv: '\u210F',
        plusacir: '\u2A23',
        plusb: '\u229E',
        pluscir: '\u2A22',
        plus: '+',
        plusdo: '\u2214',
        plusdu: '\u2A25',
        pluse: '\u2A72',
        PlusMinus: '\xB1',
        plusmn: '\xB1',
        plussim: '\u2A26',
        plustwo: '\u2A27',
        pm: '\xB1',
        Poincareplane: '\u210C',
        pointint: '\u2A15',
        popf: '\u{1D561}',
        Popf: '\u2119',
        pound: '\xA3',
        prap: '\u2AB7',
        Pr: '\u2ABB',
        pr: '\u227A',
        prcue: '\u227C',
        precapprox: '\u2AB7',
        prec: '\u227A',
        preccurlyeq: '\u227C',
        Precedes: '\u227A',
        PrecedesEqual: '\u2AAF',
        PrecedesSlantEqual: '\u227C',
        PrecedesTilde: '\u227E',
        preceq: '\u2AAF',
        precnapprox: '\u2AB9',
        precneqq: '\u2AB5',
        precnsim: '\u22E8',
        pre: '\u2AAF',
        prE: '\u2AB3',
        precsim: '\u227E',
        prime: '\u2032',
        Prime: '\u2033',
        primes: '\u2119',
        prnap: '\u2AB9',
        prnE: '\u2AB5',
        prnsim: '\u22E8',
        prod: '\u220F',
        Product: '\u220F',
        profalar: '\u232E',
        profline: '\u2312',
        profsurf: '\u2313',
        prop: '\u221D',
        Proportional: '\u221D',
        Proportion: '\u2237',
        propto: '\u221D',
        prsim: '\u227E',
        prurel: '\u22B0',
        Pscr: '\u{1D4AB}',
        pscr: '\u{1D4C5}',
        Psi: '\u03A8',
        psi: '\u03C8',
        puncsp: '\u2008',
        Qfr: '\u{1D514}',
        qfr: '\u{1D52E}',
        qint: '\u2A0C',
        qopf: '\u{1D562}',
        Qopf: '\u211A',
        qprime: '\u2057',
        Qscr: '\u{1D4AC}',
        qscr: '\u{1D4C6}',
        quaternions: '\u210D',
        quatint: '\u2A16',
        quest: '?',
        questeq: '\u225F',
        quot: '"',
        QUOT: '"',
        rAarr: '\u21DB',
        race: '\u223D\u0331',
        Racute: '\u0154',
        racute: '\u0155',
        radic: '\u221A',
        raemptyv: '\u29B3',
        rang: '\u27E9',
        Rang: '\u27EB',
        rangd: '\u2992',
        range: '\u29A5',
        rangle: '\u27E9',
        raquo: '\xBB',
        rarrap: '\u2975',
        rarrb: '\u21E5',
        rarrbfs: '\u2920',
        rarrc: '\u2933',
        rarr: '\u2192',
        Rarr: '\u21A0',
        rArr: '\u21D2',
        rarrfs: '\u291E',
        rarrhk: '\u21AA',
        rarrlp: '\u21AC',
        rarrpl: '\u2945',
        rarrsim: '\u2974',
        Rarrtl: '\u2916',
        rarrtl: '\u21A3',
        rarrw: '\u219D',
        ratail: '\u291A',
        rAtail: '\u291C',
        ratio: '\u2236',
        rationals: '\u211A',
        rbarr: '\u290D',
        rBarr: '\u290F',
        RBarr: '\u2910',
        rbbrk: '\u2773',
        rbrace: '}',
        rbrack: ']',
        rbrke: '\u298C',
        rbrksld: '\u298E',
        rbrkslu: '\u2990',
        Rcaron: '\u0158',
        rcaron: '\u0159',
        Rcedil: '\u0156',
        rcedil: '\u0157',
        rceil: '\u2309',
        rcub: '}',
        Rcy: '\u0420',
        rcy: '\u0440',
        rdca: '\u2937',
        rdldhar: '\u2969',
        rdquo: '\u201D',
        rdquor: '\u201D',
        rdsh: '\u21B3',
        real: '\u211C',
        realine: '\u211B',
        realpart: '\u211C',
        reals: '\u211D',
        Re: '\u211C',
        rect: '\u25AD',
        reg: '\xAE',
        REG: '\xAE',
        ReverseElement: '\u220B',
        ReverseEquilibrium: '\u21CB',
        ReverseUpEquilibrium: '\u296F',
        rfisht: '\u297D',
        rfloor: '\u230B',
        rfr: '\u{1D52F}',
        Rfr: '\u211C',
        rHar: '\u2964',
        rhard: '\u21C1',
        rharu: '\u21C0',
        rharul: '\u296C',
        Rho: '\u03A1',
        rho: '\u03C1',
        rhov: '\u03F1',
        RightAngleBracket: '\u27E9',
        RightArrowBar: '\u21E5',
        rightarrow: '\u2192',
        RightArrow: '\u2192',
        Rightarrow: '\u21D2',
        RightArrowLeftArrow: '\u21C4',
        rightarrowtail: '\u21A3',
        RightCeiling: '\u2309',
        RightDoubleBracket: '\u27E7',
        RightDownTeeVector: '\u295D',
        RightDownVectorBar: '\u2955',
        RightDownVector: '\u21C2',
        RightFloor: '\u230B',
        rightharpoondown: '\u21C1',
        rightharpoonup: '\u21C0',
        rightleftarrows: '\u21C4',
        rightleftharpoons: '\u21CC',
        rightrightarrows: '\u21C9',
        rightsquigarrow: '\u219D',
        RightTeeArrow: '\u21A6',
        RightTee: '\u22A2',
        RightTeeVector: '\u295B',
        rightthreetimes: '\u22CC',
        RightTriangleBar: '\u29D0',
        RightTriangle: '\u22B3',
        RightTriangleEqual: '\u22B5',
        RightUpDownVector: '\u294F',
        RightUpTeeVector: '\u295C',
        RightUpVectorBar: '\u2954',
        RightUpVector: '\u21BE',
        RightVectorBar: '\u2953',
        RightVector: '\u21C0',
        ring: '\u02DA',
        risingdotseq: '\u2253',
        rlarr: '\u21C4',
        rlhar: '\u21CC',
        rlm: '\u200F',
        rmoustache: '\u23B1',
        rmoust: '\u23B1',
        rnmid: '\u2AEE',
        roang: '\u27ED',
        roarr: '\u21FE',
        robrk: '\u27E7',
        ropar: '\u2986',
        ropf: '\u{1D563}',
        Ropf: '\u211D',
        roplus: '\u2A2E',
        rotimes: '\u2A35',
        RoundImplies: '\u2970',
        rpar: ')',
        rpargt: '\u2994',
        rppolint: '\u2A12',
        rrarr: '\u21C9',
        Rrightarrow: '\u21DB',
        rsaquo: '\u203A',
        rscr: '\u{1D4C7}',
        Rscr: '\u211B',
        rsh: '\u21B1',
        Rsh: '\u21B1',
        rsqb: ']',
        rsquo: '\u2019',
        rsquor: '\u2019',
        rthree: '\u22CC',
        rtimes: '\u22CA',
        rtri: '\u25B9',
        rtrie: '\u22B5',
        rtrif: '\u25B8',
        rtriltri: '\u29CE',
        RuleDelayed: '\u29F4',
        ruluhar: '\u2968',
        rx: '\u211E',
        Sacute: '\u015A',
        sacute: '\u015B',
        sbquo: '\u201A',
        scap: '\u2AB8',
        Scaron: '\u0160',
        scaron: '\u0161',
        Sc: '\u2ABC',
        sc: '\u227B',
        sccue: '\u227D',
        sce: '\u2AB0',
        scE: '\u2AB4',
        Scedil: '\u015E',
        scedil: '\u015F',
        Scirc: '\u015C',
        scirc: '\u015D',
        scnap: '\u2ABA',
        scnE: '\u2AB6',
        scnsim: '\u22E9',
        scpolint: '\u2A13',
        scsim: '\u227F',
        Scy: '\u0421',
        scy: '\u0441',
        sdotb: '\u22A1',
        sdot: '\u22C5',
        sdote: '\u2A66',
        searhk: '\u2925',
        searr: '\u2198',
        seArr: '\u21D8',
        searrow: '\u2198',
        sect: '\xA7',
        semi: ';',
        seswar: '\u2929',
        setminus: '\u2216',
        setmn: '\u2216',
        sext: '\u2736',
        Sfr: '\u{1D516}',
        sfr: '\u{1D530}',
        sfrown: '\u2322',
        sharp: '\u266F',
        SHCHcy: '\u0429',
        shchcy: '\u0449',
        SHcy: '\u0428',
        shcy: '\u0448',
        ShortDownArrow: '\u2193',
        ShortLeftArrow: '\u2190',
        shortmid: '\u2223',
        shortparallel: '\u2225',
        ShortRightArrow: '\u2192',
        ShortUpArrow: '\u2191',
        shy: '\xAD',
        Sigma: '\u03A3',
        sigma: '\u03C3',
        sigmaf: '\u03C2',
        sigmav: '\u03C2',
        sim: '\u223C',
        simdot: '\u2A6A',
        sime: '\u2243',
        simeq: '\u2243',
        simg: '\u2A9E',
        simgE: '\u2AA0',
        siml: '\u2A9D',
        simlE: '\u2A9F',
        simne: '\u2246',
        simplus: '\u2A24',
        simrarr: '\u2972',
        slarr: '\u2190',
        SmallCircle: '\u2218',
        smallsetminus: '\u2216',
        smashp: '\u2A33',
        smeparsl: '\u29E4',
        smid: '\u2223',
        smile: '\u2323',
        smt: '\u2AAA',
        smte: '\u2AAC',
        smtes: '\u2AAC\uFE00',
        SOFTcy: '\u042C',
        softcy: '\u044C',
        solbar: '\u233F',
        solb: '\u29C4',
        sol: '/',
        Sopf: '\u{1D54A}',
        sopf: '\u{1D564}',
        spades: '\u2660',
        spadesuit: '\u2660',
        spar: '\u2225',
        sqcap: '\u2293',
        sqcaps: '\u2293\uFE00',
        sqcup: '\u2294',
        sqcups: '\u2294\uFE00',
        Sqrt: '\u221A',
        sqsub: '\u228F',
        sqsube: '\u2291',
        sqsubset: '\u228F',
        sqsubseteq: '\u2291',
        sqsup: '\u2290',
        sqsupe: '\u2292',
        sqsupset: '\u2290',
        sqsupseteq: '\u2292',
        square: '\u25A1',
        Square: '\u25A1',
        SquareIntersection: '\u2293',
        SquareSubset: '\u228F',
        SquareSubsetEqual: '\u2291',
        SquareSuperset: '\u2290',
        SquareSupersetEqual: '\u2292',
        SquareUnion: '\u2294',
        squarf: '\u25AA',
        squ: '\u25A1',
        squf: '\u25AA',
        srarr: '\u2192',
        Sscr: '\u{1D4AE}',
        sscr: '\u{1D4C8}',
        ssetmn: '\u2216',
        ssmile: '\u2323',
        sstarf: '\u22C6',
        Star: '\u22C6',
        star: '\u2606',
        starf: '\u2605',
        straightepsilon: '\u03F5',
        straightphi: '\u03D5',
        strns: '\xAF',
        sub: '\u2282',
        Sub: '\u22D0',
        subdot: '\u2ABD',
        subE: '\u2AC5',
        sube: '\u2286',
        subedot: '\u2AC3',
        submult: '\u2AC1',
        subnE: '\u2ACB',
        subne: '\u228A',
        subplus: '\u2ABF',
        subrarr: '\u2979',
        subset: '\u2282',
        Subset: '\u22D0',
        subseteq: '\u2286',
        subseteqq: '\u2AC5',
        SubsetEqual: '\u2286',
        subsetneq: '\u228A',
        subsetneqq: '\u2ACB',
        subsim: '\u2AC7',
        subsub: '\u2AD5',
        subsup: '\u2AD3',
        succapprox: '\u2AB8',
        succ: '\u227B',
        succcurlyeq: '\u227D',
        Succeeds: '\u227B',
        SucceedsEqual: '\u2AB0',
        SucceedsSlantEqual: '\u227D',
        SucceedsTilde: '\u227F',
        succeq: '\u2AB0',
        succnapprox: '\u2ABA',
        succneqq: '\u2AB6',
        succnsim: '\u22E9',
        succsim: '\u227F',
        SuchThat: '\u220B',
        sum: '\u2211',
        Sum: '\u2211',
        sung: '\u266A',
        sup1: '\xB9',
        sup2: '\xB2',
        sup3: '\xB3',
        sup: '\u2283',
        Sup: '\u22D1',
        supdot: '\u2ABE',
        supdsub: '\u2AD8',
        supE: '\u2AC6',
        supe: '\u2287',
        supedot: '\u2AC4',
        Superset: '\u2283',
        SupersetEqual: '\u2287',
        suphsol: '\u27C9',
        suphsub: '\u2AD7',
        suplarr: '\u297B',
        supmult: '\u2AC2',
        supnE: '\u2ACC',
        supne: '\u228B',
        supplus: '\u2AC0',
        supset: '\u2283',
        Supset: '\u22D1',
        supseteq: '\u2287',
        supseteqq: '\u2AC6',
        supsetneq: '\u228B',
        supsetneqq: '\u2ACC',
        supsim: '\u2AC8',
        supsub: '\u2AD4',
        supsup: '\u2AD6',
        swarhk: '\u2926',
        swarr: '\u2199',
        swArr: '\u21D9',
        swarrow: '\u2199',
        swnwar: '\u292A',
        szlig: '\xDF',
        Tab: '	',
        target: '\u2316',
        Tau: '\u03A4',
        tau: '\u03C4',
        tbrk: '\u23B4',
        Tcaron: '\u0164',
        tcaron: '\u0165',
        Tcedil: '\u0162',
        tcedil: '\u0163',
        Tcy: '\u0422',
        tcy: '\u0442',
        tdot: '\u20DB',
        telrec: '\u2315',
        Tfr: '\u{1D517}',
        tfr: '\u{1D531}',
        there4: '\u2234',
        therefore: '\u2234',
        Therefore: '\u2234',
        Theta: '\u0398',
        theta: '\u03B8',
        thetasym: '\u03D1',
        thetav: '\u03D1',
        thickapprox: '\u2248',
        thicksim: '\u223C',
        ThickSpace: '\u205F\u200A',
        ThinSpace: '\u2009',
        thinsp: '\u2009',
        thkap: '\u2248',
        thksim: '\u223C',
        THORN: '\xDE',
        thorn: '\xFE',
        tilde: '\u02DC',
        Tilde: '\u223C',
        TildeEqual: '\u2243',
        TildeFullEqual: '\u2245',
        TildeTilde: '\u2248',
        timesbar: '\u2A31',
        timesb: '\u22A0',
        times: '\xD7',
        timesd: '\u2A30',
        tint: '\u222D',
        toea: '\u2928',
        topbot: '\u2336',
        topcir: '\u2AF1',
        top: '\u22A4',
        Topf: '\u{1D54B}',
        topf: '\u{1D565}',
        topfork: '\u2ADA',
        tosa: '\u2929',
        tprime: '\u2034',
        trade: '\u2122',
        TRADE: '\u2122',
        triangle: '\u25B5',
        triangledown: '\u25BF',
        triangleleft: '\u25C3',
        trianglelefteq: '\u22B4',
        triangleq: '\u225C',
        triangleright: '\u25B9',
        trianglerighteq: '\u22B5',
        tridot: '\u25EC',
        trie: '\u225C',
        triminus: '\u2A3A',
        TripleDot: '\u20DB',
        triplus: '\u2A39',
        trisb: '\u29CD',
        tritime: '\u2A3B',
        trpezium: '\u23E2',
        Tscr: '\u{1D4AF}',
        tscr: '\u{1D4C9}',
        TScy: '\u0426',
        tscy: '\u0446',
        TSHcy: '\u040B',
        tshcy: '\u045B',
        Tstrok: '\u0166',
        tstrok: '\u0167',
        twixt: '\u226C',
        twoheadleftarrow: '\u219E',
        twoheadrightarrow: '\u21A0',
        Uacute: '\xDA',
        uacute: '\xFA',
        uarr: '\u2191',
        Uarr: '\u219F',
        uArr: '\u21D1',
        Uarrocir: '\u2949',
        Ubrcy: '\u040E',
        ubrcy: '\u045E',
        Ubreve: '\u016C',
        ubreve: '\u016D',
        Ucirc: '\xDB',
        ucirc: '\xFB',
        Ucy: '\u0423',
        ucy: '\u0443',
        udarr: '\u21C5',
        Udblac: '\u0170',
        udblac: '\u0171',
        udhar: '\u296E',
        ufisht: '\u297E',
        Ufr: '\u{1D518}',
        ufr: '\u{1D532}',
        Ugrave: '\xD9',
        ugrave: '\xF9',
        uHar: '\u2963',
        uharl: '\u21BF',
        uharr: '\u21BE',
        uhblk: '\u2580',
        ulcorn: '\u231C',
        ulcorner: '\u231C',
        ulcrop: '\u230F',
        ultri: '\u25F8',
        Umacr: '\u016A',
        umacr: '\u016B',
        uml: '\xA8',
        UnderBar: '_',
        UnderBrace: '\u23DF',
        UnderBracket: '\u23B5',
        UnderParenthesis: '\u23DD',
        Union: '\u22C3',
        UnionPlus: '\u228E',
        Uogon: '\u0172',
        uogon: '\u0173',
        Uopf: '\u{1D54C}',
        uopf: '\u{1D566}',
        UpArrowBar: '\u2912',
        uparrow: '\u2191',
        UpArrow: '\u2191',
        Uparrow: '\u21D1',
        UpArrowDownArrow: '\u21C5',
        updownarrow: '\u2195',
        UpDownArrow: '\u2195',
        Updownarrow: '\u21D5',
        UpEquilibrium: '\u296E',
        upharpoonleft: '\u21BF',
        upharpoonright: '\u21BE',
        uplus: '\u228E',
        UpperLeftArrow: '\u2196',
        UpperRightArrow: '\u2197',
        upsi: '\u03C5',
        Upsi: '\u03D2',
        upsih: '\u03D2',
        Upsilon: '\u03A5',
        upsilon: '\u03C5',
        UpTeeArrow: '\u21A5',
        UpTee: '\u22A5',
        upuparrows: '\u21C8',
        urcorn: '\u231D',
        urcorner: '\u231D',
        urcrop: '\u230E',
        Uring: '\u016E',
        uring: '\u016F',
        urtri: '\u25F9',
        Uscr: '\u{1D4B0}',
        uscr: '\u{1D4CA}',
        utdot: '\u22F0',
        Utilde: '\u0168',
        utilde: '\u0169',
        utri: '\u25B5',
        utrif: '\u25B4',
        uuarr: '\u21C8',
        Uuml: '\xDC',
        uuml: '\xFC',
        uwangle: '\u29A7',
        vangrt: '\u299C',
        varepsilon: '\u03F5',
        varkappa: '\u03F0',
        varnothing: '\u2205',
        varphi: '\u03D5',
        varpi: '\u03D6',
        varpropto: '\u221D',
        varr: '\u2195',
        vArr: '\u21D5',
        varrho: '\u03F1',
        varsigma: '\u03C2',
        varsubsetneq: '\u228A\uFE00',
        varsubsetneqq: '\u2ACB\uFE00',
        varsupsetneq: '\u228B\uFE00',
        varsupsetneqq: '\u2ACC\uFE00',
        vartheta: '\u03D1',
        vartriangleleft: '\u22B2',
        vartriangleright: '\u22B3',
        vBar: '\u2AE8',
        Vbar: '\u2AEB',
        vBarv: '\u2AE9',
        Vcy: '\u0412',
        vcy: '\u0432',
        vdash: '\u22A2',
        vDash: '\u22A8',
        Vdash: '\u22A9',
        VDash: '\u22AB',
        Vdashl: '\u2AE6',
        veebar: '\u22BB',
        vee: '\u2228',
        Vee: '\u22C1',
        veeeq: '\u225A',
        vellip: '\u22EE',
        verbar: '|',
        Verbar: '\u2016',
        vert: '|',
        Vert: '\u2016',
        VerticalBar: '\u2223',
        VerticalLine: '|',
        VerticalSeparator: '\u2758',
        VerticalTilde: '\u2240',
        VeryThinSpace: '\u200A',
        Vfr: '\u{1D519}',
        vfr: '\u{1D533}',
        vltri: '\u22B2',
        vnsub: '\u2282\u20D2',
        vnsup: '\u2283\u20D2',
        Vopf: '\u{1D54D}',
        vopf: '\u{1D567}',
        vprop: '\u221D',
        vrtri: '\u22B3',
        Vscr: '\u{1D4B1}',
        vscr: '\u{1D4CB}',
        vsubnE: '\u2ACB\uFE00',
        vsubne: '\u228A\uFE00',
        vsupnE: '\u2ACC\uFE00',
        vsupne: '\u228B\uFE00',
        Vvdash: '\u22AA',
        vzigzag: '\u299A',
        Wcirc: '\u0174',
        wcirc: '\u0175',
        wedbar: '\u2A5F',
        wedge: '\u2227',
        Wedge: '\u22C0',
        wedgeq: '\u2259',
        weierp: '\u2118',
        Wfr: '\u{1D51A}',
        wfr: '\u{1D534}',
        Wopf: '\u{1D54E}',
        wopf: '\u{1D568}',
        wp: '\u2118',
        wr: '\u2240',
        wreath: '\u2240',
        Wscr: '\u{1D4B2}',
        wscr: '\u{1D4CC}',
        xcap: '\u22C2',
        xcirc: '\u25EF',
        xcup: '\u22C3',
        xdtri: '\u25BD',
        Xfr: '\u{1D51B}',
        xfr: '\u{1D535}',
        xharr: '\u27F7',
        xhArr: '\u27FA',
        Xi: '\u039E',
        xi: '\u03BE',
        xlarr: '\u27F5',
        xlArr: '\u27F8',
        xmap: '\u27FC',
        xnis: '\u22FB',
        xodot: '\u2A00',
        Xopf: '\u{1D54F}',
        xopf: '\u{1D569}',
        xoplus: '\u2A01',
        xotime: '\u2A02',
        xrarr: '\u27F6',
        xrArr: '\u27F9',
        Xscr: '\u{1D4B3}',
        xscr: '\u{1D4CD}',
        xsqcup: '\u2A06',
        xuplus: '\u2A04',
        xutri: '\u25B3',
        xvee: '\u22C1',
        xwedge: '\u22C0',
        Yacute: '\xDD',
        yacute: '\xFD',
        YAcy: '\u042F',
        yacy: '\u044F',
        Ycirc: '\u0176',
        ycirc: '\u0177',
        Ycy: '\u042B',
        ycy: '\u044B',
        yen: '\xA5',
        Yfr: '\u{1D51C}',
        yfr: '\u{1D536}',
        YIcy: '\u0407',
        yicy: '\u0457',
        Yopf: '\u{1D550}',
        yopf: '\u{1D56A}',
        Yscr: '\u{1D4B4}',
        yscr: '\u{1D4CE}',
        YUcy: '\u042E',
        yucy: '\u044E',
        yuml: '\xFF',
        Yuml: '\u0178',
        Zacute: '\u0179',
        zacute: '\u017A',
        Zcaron: '\u017D',
        zcaron: '\u017E',
        Zcy: '\u0417',
        zcy: '\u0437',
        Zdot: '\u017B',
        zdot: '\u017C',
        zeetrf: '\u2128',
        ZeroWidthSpace: '\u200B',
        Zeta: '\u0396',
        zeta: '\u03B6',
        zfr: '\u{1D537}',
        Zfr: '\u2128',
        ZHcy: '\u0416',
        zhcy: '\u0436',
        zigrarr: '\u21DD',
        zopf: '\u{1D56B}',
        Zopf: '\u2124',
        Zscr: '\u{1D4B5}',
        zscr: '\u{1D4CF}',
        zwj: '\u200D',
        zwnj: '\u200C',
      }
    })
    const HE = Ne((e, t) => {
      t.exports = {
        Aacute: '\xC1',
        aacute: '\xE1',
        Acirc: '\xC2',
        acirc: '\xE2',
        acute: '\xB4',
        AElig: '\xC6',
        aelig: '\xE6',
        Agrave: '\xC0',
        agrave: '\xE0',
        amp: '&',
        AMP: '&',
        Aring: '\xC5',
        aring: '\xE5',
        Atilde: '\xC3',
        atilde: '\xE3',
        Auml: '\xC4',
        auml: '\xE4',
        brvbar: '\xA6',
        Ccedil: '\xC7',
        ccedil: '\xE7',
        cedil: '\xB8',
        cent: '\xA2',
        copy: '\xA9',
        COPY: '\xA9',
        curren: '\xA4',
        deg: '\xB0',
        divide: '\xF7',
        Eacute: '\xC9',
        eacute: '\xE9',
        Ecirc: '\xCA',
        ecirc: '\xEA',
        Egrave: '\xC8',
        egrave: '\xE8',
        ETH: '\xD0',
        eth: '\xF0',
        Euml: '\xCB',
        euml: '\xEB',
        frac12: '\xBD',
        frac14: '\xBC',
        frac34: '\xBE',
        gt: '>',
        GT: '>',
        Iacute: '\xCD',
        iacute: '\xED',
        Icirc: '\xCE',
        icirc: '\xEE',
        iexcl: '\xA1',
        Igrave: '\xCC',
        igrave: '\xEC',
        iquest: '\xBF',
        Iuml: '\xCF',
        iuml: '\xEF',
        laquo: '\xAB',
        lt: '<',
        LT: '<',
        macr: '\xAF',
        micro: '\xB5',
        middot: '\xB7',
        nbsp: '\xA0',
        not: '\xAC',
        Ntilde: '\xD1',
        ntilde: '\xF1',
        Oacute: '\xD3',
        oacute: '\xF3',
        Ocirc: '\xD4',
        ocirc: '\xF4',
        Ograve: '\xD2',
        ograve: '\xF2',
        ordf: '\xAA',
        ordm: '\xBA',
        Oslash: '\xD8',
        oslash: '\xF8',
        Otilde: '\xD5',
        otilde: '\xF5',
        Ouml: '\xD6',
        ouml: '\xF6',
        para: '\xB6',
        plusmn: '\xB1',
        pound: '\xA3',
        quot: '"',
        QUOT: '"',
        raquo: '\xBB',
        reg: '\xAE',
        REG: '\xAE',
        sect: '\xA7',
        shy: '\xAD',
        sup1: '\xB9',
        sup2: '\xB2',
        sup3: '\xB3',
        szlig: '\xDF',
        THORN: '\xDE',
        thorn: '\xFE',
        times: '\xD7',
        Uacute: '\xDA',
        uacute: '\xFA',
        Ucirc: '\xDB',
        ucirc: '\xFB',
        Ugrave: '\xD9',
        ugrave: '\xF9',
        uml: '\xA8',
        Uuml: '\xDC',
        uuml: '\xFC',
        Yacute: '\xDD',
        yacute: '\xFD',
        yen: '\xA5',
        yuml: '\xFF',
      }
    })
    const cp = Ne((e, t) => {
      t.exports = { amp: '&', apos: "'", gt: '>', lt: '<', quot: '"' }
    })
    const VE = Ne((e, t) => {
      t.exports = {
        0: 65533,
        128: 8364,
        130: 8218,
        131: 402,
        132: 8222,
        133: 8230,
        134: 8224,
        135: 8225,
        136: 710,
        137: 8240,
        138: 352,
        139: 8249,
        140: 338,
        142: 381,
        145: 8216,
        146: 8217,
        147: 8220,
        148: 8221,
        149: 8226,
        150: 8211,
        151: 8212,
        152: 732,
        153: 8482,
        154: 353,
        155: 8250,
        156: 339,
        158: 382,
        159: 376,
      }
    })
    const zE = Ne(e => {
      'use strict'
      const t =
        (e && e.__importDefault) ||
        function (a) {
          return a && a.__esModule ? a : { default: a }
        }
      Object.defineProperty(e, '__esModule', { value: !0 })
      const r = t(VE())
      const n =
        String.fromCodePoint ||
        function (a) {
          let i = ''
          return (
            a > 65535 &&
              ((a -= 65536),
              (i += String.fromCharCode(((a >>> 10) & 1023) | 55296)),
              (a = 56320 | (a & 1023))),
            (i += String.fromCharCode(a)),
            i
          )
        }
      function o(a) {
        return (a >= 55296 && a <= 57343) || a > 1114111
          ? '\uFFFD'
          : (a in r.default && (a = r.default[a]), n(a))
      }
      ;(w(o, 'decodeCodePoint'), (e.default = o))
    })
    const Gd = Ne(e => {
      'use strict'
      const t =
        (e && e.__importDefault) ||
        function (d) {
          return d && d.__esModule ? d : { default: d }
        }
      ;(Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.decodeHTML = e.decodeHTMLStrict = e.decodeXML = void 0))
      const r = t(up())
      const n = t(HE())
      const o = t(cp())
      const a = t(zE())
      const i = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g
      ;((e.decodeXML = s(o.default)), (e.decodeHTMLStrict = s(r.default)))
      function s(d) {
        const m = u(d)
        return function (p) {
          return String(p).replace(i, m)
        }
      }
      w(s, 'getStrictDecoder')
      const l = w(function (d, m) {
        return d < m ? 1 : -1
      }, 'sorter')
      e.decodeHTML = (function () {
        for (
          var d = Object.keys(n.default).sort(l),
            m = Object.keys(r.default).sort(l),
            p = 0,
            f = 0;
          p < m.length;
          p++
        )
          d[f] === m[p] ? ((m[p] += ';?'), f++) : (m[p] += ';')
        const g = new RegExp(
          '&(?:' + m.join('|') + '|#[xX][\\da-fA-F]+;?|#\\d+;?)',
          'g'
        )
        const y = u(r.default)
        function E(b) {
          return (b.substr(-1) !== ';' && (b += ';'), y(b))
        }
        return (
          w(E, 'replacer'),
          function (b) {
            return String(b).replace(g, E)
          }
        )
      })()
      function u(d) {
        return w(function (m) {
          if (m.charAt(1) === '#') {
            const p = m.charAt(2)
            return p === 'X' || p === 'x'
              ? a.default(parseInt(m.substr(3), 16))
              : a.default(parseInt(m.substr(2), 10))
          }
          return d[m.slice(1, -1)] || m
        }, 'replace')
      }
      w(u, 'getReplacer')
    })
    const Wd = Ne(e => {
      'use strict'
      const t =
        (e && e.__importDefault) ||
        function (x) {
          return x && x.__esModule ? x : { default: x }
        }
      ;(Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.escapeUTF8 =
          e.escape =
          e.encodeNonAsciiHTML =
          e.encodeHTML =
          e.encodeXML =
            void 0))
      const r = t(cp())
      const n = l(r.default)
      const o = u(n)
      e.encodeXML = b(n)
      const a = t(up())
      const i = l(a.default)
      const s = u(i)
      ;((e.encodeHTML = f(i, s)), (e.encodeNonAsciiHTML = b(i)))
      function l(x) {
        return Object.keys(x)
          .sort()
          .reduce(function (S, T) {
            return ((S[x[T]] = '&' + T + ';'), S)
          }, {})
      }
      w(l, 'getInverseObj')
      function u(x) {
        for (var S = [], T = [], _ = 0, O = Object.keys(x); _ < O.length; _++) {
          const k = O[_]
          k.length === 1 ? S.push('\\' + k) : T.push(k)
        }
        S.sort()
        for (let B = 0; B < S.length - 1; B++) {
          for (
            var P = B;
            P < S.length - 1 &&
            S[P].charCodeAt(1) + 1 === S[P + 1].charCodeAt(1);

          )
            P += 1
          const L = 1 + P - B
          L < 3 || S.splice(B, L, S[B] + '-' + S[P])
        }
        return (T.unshift('[' + S.join('') + ']'), new RegExp(T.join('|'), 'g'))
      }
      w(u, 'getInverseReplacer')
      const d =
        /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g
      const m =
        String.prototype.codePointAt != null
          ? function (x) {
              return x.codePointAt(0)
            }
          : function (x) {
              return (
                (x.charCodeAt(0) - 55296) * 1024 +
                x.charCodeAt(1) -
                56320 +
                65536
              )
            }
      function p(x) {
        return (
          '&#x' +
          (x.length > 1 ? m(x) : x.charCodeAt(0)).toString(16).toUpperCase() +
          ';'
        )
      }
      w(p, 'singleCharReplacer')
      function f(x, S) {
        return function (T) {
          return T.replace(S, function (_) {
            return x[_]
          }).replace(d, p)
        }
      }
      w(f, 'getInverse')
      const g = new RegExp(o.source + '|' + d.source, 'g')
      function y(x) {
        return x.replace(g, p)
      }
      ;(w(y, 'escape'), (e.escape = y))
      function E(x) {
        return x.replace(o, p)
      }
      ;(w(E, 'escapeUTF8'), (e.escapeUTF8 = E))
      function b(x) {
        return function (S) {
          return S.replace(g, function (T) {
            return x[T] || p(T)
          })
        }
      }
      w(b, 'getASCIIEncoder')
    })
    const GE = Ne(e => {
      'use strict'
      ;(Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.decodeXMLStrict =
          e.decodeHTML5Strict =
          e.decodeHTML4Strict =
          e.decodeHTML5 =
          e.decodeHTML4 =
          e.decodeHTMLStrict =
          e.decodeHTML =
          e.decodeXML =
          e.encodeHTML5 =
          e.encodeHTML4 =
          e.escapeUTF8 =
          e.escape =
          e.encodeNonAsciiHTML =
          e.encodeHTML =
          e.encodeXML =
          e.encode =
          e.decodeStrict =
          e.decode =
            void 0))
      const t = Gd()
      const r = Wd()
      function n(l, u) {
        return (!u || u <= 0 ? t.decodeXML : t.decodeHTML)(l)
      }
      ;(w(n, 'decode'), (e.decode = n))
      function o(l, u) {
        return (!u || u <= 0 ? t.decodeXML : t.decodeHTMLStrict)(l)
      }
      ;(w(o, 'decodeStrict'), (e.decodeStrict = o))
      function a(l, u) {
        return (!u || u <= 0 ? r.encodeXML : r.encodeHTML)(l)
      }
      ;(w(a, 'encode'), (e.encode = a))
      const i = Wd()
      ;(Object.defineProperty(e, 'encodeXML', {
        enumerable: !0,
        get: w(function () {
          return i.encodeXML
        }, 'get'),
      }),
        Object.defineProperty(e, 'encodeHTML', {
          enumerable: !0,
          get: w(function () {
            return i.encodeHTML
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeNonAsciiHTML', {
          enumerable: !0,
          get: w(function () {
            return i.encodeNonAsciiHTML
          }, 'get'),
        }),
        Object.defineProperty(e, 'escape', {
          enumerable: !0,
          get: w(function () {
            return i.escape
          }, 'get'),
        }),
        Object.defineProperty(e, 'escapeUTF8', {
          enumerable: !0,
          get: w(function () {
            return i.escapeUTF8
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeHTML4', {
          enumerable: !0,
          get: w(function () {
            return i.encodeHTML
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeHTML5', {
          enumerable: !0,
          get: w(function () {
            return i.encodeHTML
          }, 'get'),
        }))
      const s = Gd()
      ;(Object.defineProperty(e, 'decodeXML', {
        enumerable: !0,
        get: w(function () {
          return s.decodeXML
        }, 'get'),
      }),
        Object.defineProperty(e, 'decodeHTML', {
          enumerable: !0,
          get: w(function () {
            return s.decodeHTML
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTMLStrict', {
          enumerable: !0,
          get: w(function () {
            return s.decodeHTMLStrict
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML4', {
          enumerable: !0,
          get: w(function () {
            return s.decodeHTML
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML5', {
          enumerable: !0,
          get: w(function () {
            return s.decodeHTML
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML4Strict', {
          enumerable: !0,
          get: w(function () {
            return s.decodeHTMLStrict
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML5Strict', {
          enumerable: !0,
          get: w(function () {
            return s.decodeHTMLStrict
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeXMLStrict', {
          enumerable: !0,
          get: w(function () {
            return s.decodeXML
          }, 'get'),
        }))
    })
    const WE = Ne((e, t) => {
      'use strict'
      function r(v, A) {
        if (!(v instanceof A))
          throw new TypeError('Cannot call a class as a function')
      }
      w(r, '_classCallCheck')
      function n(v, A) {
        for (let D = 0; D < A.length; D++) {
          const N = A[D]
          ;((N.enumerable = N.enumerable || !1),
            (N.configurable = !0),
            'value' in N && (N.writable = !0),
            Object.defineProperty(v, N.key, N))
        }
      }
      w(n, '_defineProperties')
      function o(v, A, D) {
        return (A && n(v.prototype, A), D && n(v, D), v)
      }
      w(o, '_createClass')
      function a(v, A) {
        let D = (typeof Symbol < 'u' && v[Symbol.iterator]) || v['@@iterator']
        if (!D) {
          if (
            Array.isArray(v) ||
            (D = i(v)) ||
            (A && v && typeof v.length === 'number')
          ) {
            D && (v = D)
            let N = 0
            const F = w(function () {}, 'F')
            return {
              s: F,
              n: w(function () {
                return N >= v.length
                  ? { done: !0 }
                  : { done: !1, value: v[N++] }
              }, 'n'),
              e: w(function (G) {
                throw G
              }, 'e'),
              f: F,
            }
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }
        let M = !0
        let q = !1
        let V
        return {
          s: w(function () {
            D = D.call(v)
          }, 's'),
          n: w(function () {
            const G = D.next()
            return ((M = G.done), G)
          }, 'n'),
          e: w(function (G) {
            ;((q = !0), (V = G))
          }, 'e'),
          f: w(function () {
            try {
              !M && D.return != null && D.return()
            } finally {
              if (q) throw V
            }
          }, 'f'),
        }
      }
      w(a, '_createForOfIteratorHelper')
      function i(v, A) {
        if (v) {
          if (typeof v === 'string') return s(v, A)
          let D = Object.prototype.toString.call(v).slice(8, -1)
          if (
            (D === 'Object' && v.constructor && (D = v.constructor.name),
            D === 'Map' || D === 'Set')
          )
            return Array.from(v)
          if (
            D === 'Arguments' ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(D)
          )
            return s(v, A)
        }
      }
      w(i, '_unsupportedIterableToArray')
      function s(v, A) {
        ;(A == null || A > v.length) && (A = v.length)
        for (var D = 0, N = new Array(A); D < A; D++) N[D] = v[D]
        return N
      }
      w(s, '_arrayLikeToArray')
      const l = GE()
      const u = {
        fg: '#FFF',
        bg: '#000',
        newline: !1,
        escapeXML: !1,
        stream: !1,
        colors: d(),
      }
      function d() {
        const v = {
          0: '#000',
          1: '#A00',
          2: '#0A0',
          3: '#A50',
          4: '#00A',
          5: '#A0A',
          6: '#0AA',
          7: '#AAA',
          8: '#555',
          9: '#F55',
          10: '#5F5',
          11: '#FF5',
          12: '#55F',
          13: '#F5F',
          14: '#5FF',
          15: '#FFF',
        }
        return (
          x(0, 5).forEach(function (A) {
            x(0, 5).forEach(function (D) {
              x(0, 5).forEach(function (N) {
                return m(A, D, N, v)
              })
            })
          }),
          x(0, 23).forEach(function (A) {
            const D = A + 232
            const N = p(A * 10 + 8)
            v[D] = '#' + N + N + N
          }),
          v
        )
      }
      w(d, 'getDefaultColors')
      function m(v, A, D, N) {
        const F = 16 + v * 36 + A * 6 + D
        const M = v > 0 ? v * 40 + 55 : 0
        const q = A > 0 ? A * 40 + 55 : 0
        const V = D > 0 ? D * 40 + 55 : 0
        N[F] = f([M, q, V])
      }
      w(m, 'setStyleColor')
      function p(v) {
        for (var A = v.toString(16); A.length < 2; ) A = '0' + A
        return A
      }
      w(p, 'toHexString')
      function f(v) {
        const A = []
        const D = a(v)
        let N
        try {
          for (D.s(); !(N = D.n()).done; ) {
            const F = N.value
            A.push(p(F))
          }
        } catch (M) {
          D.e(M)
        } finally {
          D.f()
        }
        return '#' + A.join('')
      }
      w(f, 'toColorHexString')
      function g(v, A, D, N) {
        let F
        return (
          A === 'text'
            ? (F = _(D, N))
            : A === 'display'
              ? (F = E(v, D, N))
              : A === 'xterm256Foreground'
                ? (F = B(v, N.colors[D]))
                : A === 'xterm256Background'
                  ? (F = P(v, N.colors[D]))
                  : A === 'rgb' && (F = y(v, D)),
          F
        )
      }
      w(g, 'generateOutput')
      function y(v, A) {
        A = A.substring(2).slice(0, -1)
        const D = +A.substr(0, 2)
        const N = A.substring(5).split(';')
        const F = N.map(function (M) {
          return ('0' + Number(M).toString(16)).substr(-2)
        }).join('')
        return k(v, (D === 38 ? 'color:#' : 'background-color:#') + F)
      }
      w(y, 'handleRgb')
      function E(v, A, D) {
        A = parseInt(A, 10)
        const N = {
          '-1': w(function () {
            return '<br/>'
          }, '_'),
          0: w(function () {
            return v.length && b(v)
          }, '_'),
          1: w(function () {
            return O(v, 'b')
          }, '_'),
          3: w(function () {
            return O(v, 'i')
          }, '_'),
          4: w(function () {
            return O(v, 'u')
          }, '_'),
          8: w(function () {
            return k(v, 'display:none')
          }, '_'),
          9: w(function () {
            return O(v, 'strike')
          }, '_'),
          22: w(function () {
            return k(
              v,
              'font-weight:normal;text-decoration:none;font-style:normal'
            )
          }, '_'),
          23: w(function () {
            return L(v, 'i')
          }, '_'),
          24: w(function () {
            return L(v, 'u')
          }, '_'),
          39: w(function () {
            return B(v, D.fg)
          }, '_'),
          49: w(function () {
            return P(v, D.bg)
          }, '_'),
          53: w(function () {
            return k(v, 'text-decoration:overline')
          }, '_'),
        }
        let F
        return (
          N[A]
            ? (F = N[A]())
            : A > 4 && A < 7
              ? (F = O(v, 'blink'))
              : A > 29 && A < 38
                ? (F = B(v, D.colors[A - 30]))
                : A > 39 && A < 48
                  ? (F = P(v, D.colors[A - 40]))
                  : A > 89 && A < 98
                    ? (F = B(v, D.colors[8 + (A - 90)]))
                    : A > 99 && A < 108 && (F = P(v, D.colors[8 + (A - 100)])),
          F
        )
      }
      w(E, 'handleDisplay')
      function b(v) {
        const A = v.slice(0)
        return (
          (v.length = 0),
          A.reverse()
            .map(function (D) {
              return '</' + D + '>'
            })
            .join('')
        )
      }
      w(b, 'resetStyles')
      function x(v, A) {
        for (var D = [], N = v; N <= A; N++) D.push(N)
        return D
      }
      w(x, 'range')
      function S(v) {
        return function (A) {
          return (v === null || A.category !== v) && v !== 'all'
        }
      }
      w(S, 'notCategory')
      function T(v) {
        v = parseInt(v, 10)
        let A = null
        return (
          v === 0
            ? (A = 'all')
            : v === 1
              ? (A = 'bold')
              : v > 2 && v < 5
                ? (A = 'underline')
                : v > 4 && v < 7
                  ? (A = 'blink')
                  : v === 8
                    ? (A = 'hide')
                    : v === 9
                      ? (A = 'strike')
                      : (v > 29 && v < 38) || v === 39 || (v > 89 && v < 98)
                        ? (A = 'foreground-color')
                        : ((v > 39 && v < 48) ||
                            v === 49 ||
                            (v > 99 && v < 108)) &&
                          (A = 'background-color'),
          A
        )
      }
      w(T, 'categoryForCode')
      function _(v, A) {
        return A.escapeXML ? l.encodeXML(v) : v
      }
      w(_, 'pushText')
      function O(v, A, D) {
        return (
          D || (D = ''),
          v.push(A),
          '<'.concat(A).concat(D ? ' style="'.concat(D, '"') : '', '>')
        )
      }
      w(O, 'pushTag')
      function k(v, A) {
        return O(v, 'span', A)
      }
      w(k, 'pushStyle')
      function B(v, A) {
        return O(v, 'span', 'color:' + A)
      }
      w(B, 'pushForegroundColor')
      function P(v, A) {
        return O(v, 'span', 'background-color:' + A)
      }
      w(P, 'pushBackgroundColor')
      function L(v, A) {
        let D
        if ((v.slice(-1)[0] === A && (D = v.pop()), D)) return '</' + A + '>'
      }
      w(L, 'closeTag')
      function j(v, A, D) {
        let N = !1
        const F = 3
        function M() {
          return ''
        }
        w(M, 'remove')
        function q(me, ue) {
          return (D('xterm256Foreground', ue), '')
        }
        w(q, 'removeXterm256Foreground')
        function V(me, ue) {
          return (D('xterm256Background', ue), '')
        }
        w(V, 'removeXterm256Background')
        function G(me) {
          return (A.newline ? D('display', -1) : D('text', me), '')
        }
        w(G, 'newline')
        function se(me, ue) {
          ;((N = !0),
            ue.trim().length === 0 && (ue = '0'),
            (ue = ue.trimRight(';').split(';')))
          const ht = a(ue)
          let Sn
          try {
            for (ht.s(); !(Sn = ht.n()).done; ) {
              const Ei = Sn.value
              D('display', Ei)
            }
          } catch (vi) {
            ht.e(vi)
          } finally {
            ht.f()
          }
          return ''
        }
        w(se, 'ansiMess')
        function pe(me) {
          return (D('text', me), '')
        }
        w(pe, 'realText')
        function ae(me) {
          return (D('rgb', me), '')
        }
        w(ae, 'rgb')
        const we = [
          { pattern: /^\x08+/, sub: M },
          { pattern: /^\x1B\[[012]?K/, sub: M },
          { pattern: /^\x1B\[\(B/, sub: M },
          { pattern: /^\x1B\[[34]8;2;\d+;\d+;\d+m/, sub: ae },
          { pattern: /^\x1B\[38;5;(\d+)m/, sub: q },
          { pattern: /^\x1B\[48;5;(\d+)m/, sub: V },
          { pattern: /^\n/, sub: G },
          { pattern: /^\r+\n/, sub: G },
          { pattern: /^\r/, sub: G },
          { pattern: /^\x1B\[((?:\d{1,3};?)+|)m/, sub: se },
          { pattern: /^\x1B\[\d?J/, sub: M },
          { pattern: /^\x1B\[\d{0,3};\d{0,3}f/, sub: M },
          { pattern: /^\x1B\[?[\d;]{0,3}/, sub: M },
          { pattern: /^(([^\x1B\x08\r\n])+)/, sub: pe },
        ]
        function ee(me, ue) {
          ;(ue > F && N) || ((N = !1), (v = v.replace(me.pattern, me.sub)))
        }
        w(ee, 'process')
        const Ce = []
        const Ve = v
        let Fe = Ve.length
        e: for (; Fe > 0; ) {
          for (let lt = 0, Zt = 0, Nr = we.length; Zt < Nr; lt = ++Zt) {
            const W = we[lt]
            if ((ee(W, lt), v.length !== Fe)) {
              Fe = v.length
              continue e
            }
          }
          if (v.length === Fe) break
          ;(Ce.push(0), (Fe = v.length))
        }
        return Ce
      }
      w(j, 'tokenize')
      function U(v, A, D) {
        return (
          A !== 'text' &&
            ((v = v.filter(S(T(D)))),
            v.push({ token: A, data: D, category: T(D) })),
          v
        )
      }
      w(U, 'updateStickyStack')
      const $ = (function () {
        function v(A) {
          ;(r(this, v),
            (A = A || {}),
            A.colors && (A.colors = Object.assign({}, u.colors, A.colors)),
            (this.options = Object.assign({}, u, A)),
            (this.stack = []),
            (this.stickyStack = []))
        }
        return (
          w(v, 'Filter'),
          o(v, [
            {
              key: 'toHtml',
              value: w(function (A) {
                const D = this
                A = typeof A === 'string' ? [A] : A
                const N = this.stack
                const F = this.options
                const M = []
                return (
                  this.stickyStack.forEach(function (q) {
                    const V = g(N, q.token, q.data, F)
                    V && M.push(V)
                  }),
                  j(A.join(''), F, function (q, V) {
                    const G = g(N, q, V, F)
                    ;(G && M.push(G),
                      F.stream && (D.stickyStack = U(D.stickyStack, q, V)))
                  }),
                  N.length && M.push(b(N)),
                  M.join('')
                )
              }, 'toHtml'),
            },
          ]),
          v
        )
      })()
      t.exports = $
    })
    function dp() {
      const e = {
        setHandler: w(() => {}, 'setHandler'),
        send: w(() => {}, 'send'),
      }
      return new No({ transport: e })
    }
    w(dp, 'mockChannel')
    const pp = class {
      constructor() {
        ;((this.getChannel = w(() => {
          if (!this.channel) {
            const t = dp()
            return (this.setChannel(t), t)
          }
          return this.channel
        }, 'getChannel')),
          (this.ready = w(() => this.promise, 'ready')),
          (this.hasChannel = w(() => !!this.channel, 'hasChannel')),
          (this.setChannel = w(t => {
            ;((this.channel = t), this.resolve())
          }, 'setChannel')),
          (this.promise = new Promise(t => {
            this.resolve = () => t(this.getChannel())
          })))
      }
    }
    w(pp, 'AddonStore')
    const YE = pp
    const ji = '__STORYBOOK_ADDONS_PREVIEW'
    function mp() {
      return (H[ji] || (H[ji] = new YE()), H[ji])
    }
    w(mp, 'getAddonsStore')
    const ut = mp()
    const hp = class {
      constructor() {
        ;((this.hookListsMap = void 0),
          (this.mountedDecorators = void 0),
          (this.prevMountedDecorators = void 0),
          (this.currentHooks = void 0),
          (this.nextHookIndex = void 0),
          (this.currentPhase = void 0),
          (this.currentEffects = void 0),
          (this.prevEffects = void 0),
          (this.currentDecoratorName = void 0),
          (this.hasUpdates = void 0),
          (this.currentContext = void 0),
          (this.renderListener = w(t => {
            t === this.currentContext?.id &&
              (this.triggerEffects(),
              (this.currentContext = null),
              this.removeRenderListeners())
          }, 'renderListener')),
          this.init())
      }
      init() {
        ;((this.hookListsMap = new WeakMap()),
          (this.mountedDecorators = new Set()),
          (this.prevMountedDecorators = new Set()),
          (this.currentHooks = []),
          (this.nextHookIndex = 0),
          (this.currentPhase = 'NONE'),
          (this.currentEffects = []),
          (this.prevEffects = []),
          (this.currentDecoratorName = null),
          (this.hasUpdates = !1),
          (this.currentContext = null))
      }
      clean() {
        ;(this.prevEffects.forEach(t => {
          t.destroy && t.destroy()
        }),
          this.init(),
          this.removeRenderListeners())
      }
      getNextHook() {
        const t = this.currentHooks[this.nextHookIndex]
        return ((this.nextHookIndex += 1), t)
      }
      triggerEffects() {
        ;(this.prevEffects.forEach(t => {
          !this.currentEffects.includes(t) && t.destroy && t.destroy()
        }),
          this.currentEffects.forEach(t => {
            this.prevEffects.includes(t) || (t.destroy = t.create())
          }),
          (this.prevEffects = this.currentEffects),
          (this.currentEffects = []))
      }
      addRenderListeners() {
        ;(this.removeRenderListeners(),
          ut.getChannel().on(rr, this.renderListener))
      }
      removeRenderListeners() {
        ut.getChannel().removeListener(rr, this.renderListener)
      }
    }
    w(hp, 'HooksContext')
    const fp = hp
    function zi(e) {
      const t = w((...r) => {
        const { hooks: n } = typeof r[0] === 'function' ? r[1] : r[0]
        const o = n.currentPhase
        const a = n.currentHooks
        const i = n.nextHookIndex
        const s = n.currentDecoratorName
        ;((n.currentDecoratorName = e.name),
          n.prevMountedDecorators.has(e)
            ? ((n.currentPhase = 'UPDATE'),
              (n.currentHooks = n.hookListsMap.get(e) || []))
            : ((n.currentPhase = 'MOUNT'),
              (n.currentHooks = []),
              n.hookListsMap.set(e, n.currentHooks),
              n.prevMountedDecorators.add(e)),
          (n.nextHookIndex = 0))
        const l = H.STORYBOOK_HOOKS_CONTEXT
        H.STORYBOOK_HOOKS_CONTEXT = n
        const u = e(...r)
        if (
          ((H.STORYBOOK_HOOKS_CONTEXT = l),
          n.currentPhase === 'UPDATE' && n.getNextHook() != null)
        )
          throw new Error(
            'Rendered fewer hooks than expected. This may be caused by an accidental early return statement.'
          )
        return (
          (n.currentPhase = o),
          (n.currentHooks = a),
          (n.nextHookIndex = i),
          (n.currentDecoratorName = s),
          u
        )
      }, 'hookified')
      return ((t.originalFn = e), t)
    }
    w(zi, 'hookify')
    let Mi = 0
    const KE = 25
    const XE = w(
      e => (t, r) => {
        const n = e(
          zi(t),
          r.map(o => zi(o))
        )
        return o => {
          const { hooks: a } = o
          ;((a.prevMountedDecorators ??= new Set()),
            (a.mountedDecorators = new Set([t, ...r])),
            (a.currentContext = o),
            (a.hasUpdates = !1))
          let i = n(o)
          for (Mi = 1; a.hasUpdates; )
            if (
              ((a.hasUpdates = !1),
              (a.currentEffects = []),
              (i = n(o)),
              (Mi += 1),
              Mi > KE)
            )
              throw new Error(
                'Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.'
              )
          return (a.addRenderListeners(), i)
        }
      },
      'applyHooks'
    )
    const JE = w(
      (e, t) => e.length === t.length && e.every((r, n) => r === t[n]),
      'areDepsEqual'
    )
    const ss = w(
      () =>
        new Error(
          'Storybook preview hooks can only be called inside decorators and story functions.'
        ),
      'invalidHooksError'
    )
    function ls() {
      return H.STORYBOOK_HOOKS_CONTEXT || null
    }
    w(ls, 'getHooksContextOrNull')
    function Wo() {
      const e = ls()
      if (e == null) throw ss()
      return e
    }
    w(Wo, 'getHooksContextOrThrow')
    function gp(e, t, r) {
      const n = Wo()
      if (n.currentPhase === 'MOUNT') {
        r != null &&
          !Array.isArray(r) &&
          Z.warn(
            `${e} received a final argument that is not an array (instead, received ${r}). When specified, the final argument must be an array.`
          )
        const o = { name: e, deps: r }
        return (n.currentHooks.push(o), t(o), o)
      }
      if (n.currentPhase === 'UPDATE') {
        const o = n.getNextHook()
        if (o == null)
          throw new Error(
            'Rendered more hooks than during the previous render.'
          )
        return (
          o.name !== e &&
            Z.warn(
              `Storybook has detected a change in the order of Hooks${n.currentDecoratorName ? ` called by ${n.currentDecoratorName}` : ''}. This will lead to bugs and errors if not fixed.`
            ),
          r != null &&
            o.deps == null &&
            Z.warn(
              `${e} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
            ),
          r != null &&
            o.deps != null &&
            r.length !== o.deps.length &&
            Z.warn(`The final argument passed to ${e} changed size between renders. The order and size of this array must remain constant.
Previous: ${o.deps}
Incoming: ${r}`),
          (r == null || o.deps == null || !JE(r, o.deps)) &&
            (t(o), (o.deps = r)),
          o
        )
      }
      throw ss()
    }
    w(gp, 'useHook')
    function Pn(e, t, r) {
      const { memoizedState: n } = gp(
        e,
        o => {
          o.memoizedState = t()
        },
        r
      )
      return n
    }
    w(Pn, 'useMemoLike')
    function us(e, t) {
      return Pn('useMemo', e, t)
    }
    w(us, 'useMemo')
    function Fn(e, t) {
      return Pn('useCallback', () => e, t)
    }
    w(Fn, 'useCallback')
    function cs(e, t) {
      return Pn(e, () => ({ current: t }), [])
    }
    w(cs, 'useRefLike')
    function ZE(e) {
      return cs('useRef', e)
    }
    w(ZE, 'useRef')
    function yp() {
      const e = ls()
      if (e != null && e.currentPhase !== 'NONE') e.hasUpdates = !0
      else
        try {
          ut.getChannel().emit(To)
        } catch {
          Z.warn(
            'State updates of Storybook preview hooks work only in browser'
          )
        }
    }
    w(yp, 'triggerUpdate')
    function ds(e, t) {
      const r = cs(e, typeof t === 'function' ? t() : t)
      const n = w(o => {
        ;((r.current = typeof o === 'function' ? o(r.current) : o), yp())
      }, 'setState')
      return [r.current, n]
    }
    w(ds, 'useStateLike')
    function QE(e) {
      return ds('useState', e)
    }
    w(QE, 'useState')
    function ev(e, t, r) {
      const n = r != null ? () => r(t) : t
      const [o, a] = ds('useReducer', n)
      return [o, w(i => a(s => e(s, i)), 'dispatch')]
    }
    w(ev, 'useReducer')
    function Bt(e, t) {
      const r = Wo()
      const n = Pn('useEffect', () => ({ create: e }), t)
      r.currentEffects.includes(n) || r.currentEffects.push(n)
    }
    w(Bt, 'useEffect')
    function tv(e, t = []) {
      const r = ut.getChannel()
      return (
        Bt(
          () => (
            Object.entries(e).forEach(([n, o]) => r.on(n, o)),
            () => {
              Object.entries(e).forEach(([n, o]) => r.removeListener(n, o))
            }
          ),
          [...Object.keys(e), ...t]
        ),
        Fn(r.emit.bind(r), [r])
      )
    }
    w(tv, 'useChannel')
    function Yo() {
      const { currentContext: e } = Wo()
      if (e == null) throw ss()
      return e
    }
    w(Yo, 'useStoryContext')
    function rv(e, t) {
      const { parameters: r } = Yo()
      if (e) return r[e] ?? t
    }
    w(rv, 'useParameter')
    function nv() {
      const e = ut.getChannel()
      const { id: t, args: r } = Yo()
      const n = Fn(a => e.emit(Po, { storyId: t, updatedArgs: a }), [e, t])
      const o = Fn(a => e.emit(Oo, { storyId: t, argNames: a }), [e, t])
      return [r, n, o]
    }
    w(nv, 'useArgs')
    function ov() {
      const e = ut.getChannel()
      const { globals: t } = Yo()
      const r = Fn(n => e.emit(Fo, { globals: n }), [e])
      return [t, r]
    }
    w(ov, 'useGlobals')
    const s6 = w(
      ({
        name: e,
        parameterName: t,
        wrapper: r,
        skipIfNoParametersOrOptions: n = !1,
      }) => {
        const o = w(
          a => (i, s) => {
            const l = s.parameters && s.parameters[t]
            return (l && l.disable) || (n && !a && !l)
              ? i(s)
              : r(i, s, { options: a, parameters: l })
          },
          'decorator'
        )
        return (...a) =>
          typeof a[0] === 'function'
            ? o()(...a)
            : (...i) => {
                if (i.length > 1)
                  return a.length > 1 ? o(a)(...i) : o(...a)(...i)
                throw new Error(`Passing stories directly into ${e}() is not allowed,
        instead use addDecorator(${e}) and pass options with the '${t}' parameter`)
              }
      },
      'makeDecorator'
    )
    function bp() {}
    w(bp, 'noop')
    function Gi(e) {
      return Object.getOwnPropertySymbols(e).filter(t =>
        Object.prototype.propertyIsEnumerable.call(e, t)
      )
    }
    w(Gi, 'getSymbols')
    function Wi(e) {
      return e == null
        ? e === void 0
          ? '[object Undefined]'
          : '[object Null]'
        : Object.prototype.toString.call(e)
    }
    w(Wi, 'getTag')
    const av = '[object RegExp]'
    const iv = '[object String]'
    const sv = '[object Number]'
    const lv = '[object Boolean]'
    const Yd = '[object Arguments]'
    const uv = '[object Symbol]'
    const cv = '[object Date]'
    const dv = '[object Map]'
    const pv = '[object Set]'
    const mv = '[object Array]'
    const hv = '[object Function]'
    const fv = '[object ArrayBuffer]'
    const $i = '[object Object]'
    const gv = '[object Error]'
    const yv = '[object DataView]'
    const bv = '[object Uint8Array]'
    const Ev = '[object Uint8ClampedArray]'
    const vv = '[object Uint16Array]'
    const Av = '[object Uint32Array]'
    const xv = '[object BigUint64Array]'
    const wv = '[object Int8Array]'
    const Sv = '[object Int16Array]'
    const Cv = '[object Int32Array]'
    const Dv = '[object BigInt64Array]'
    const Tv = '[object Float32Array]'
    const kv = '[object Float64Array]'
    function xt(e) {
      if (!e || typeof e !== 'object') return !1
      const t = Object.getPrototypeOf(e)
      return t === null ||
        t === Object.prototype ||
        Object.getPrototypeOf(t) === null
        ? Object.prototype.toString.call(e) === '[object Object]'
        : !1
    }
    w(xt, 'isPlainObject')
    function Gr(e, t) {
      const r = {}
      const n = Object.keys(e)
      for (let o = 0; o < n.length; o++) {
        const a = n[o]
        const i = e[a]
        r[a] = t(i, a, e)
      }
      return r
    }
    w(Gr, 'mapValues')
    function Ep(e, t) {
      const r = {}
      const n = Object.keys(e)
      for (let o = 0; o < n.length; o++) {
        const a = n[o]
        const i = e[a]
        t(i, a) && (r[a] = i)
      }
      return r
    }
    w(Ep, 'pickBy')
    function vp(e, t) {
      return e === t || (Number.isNaN(e) && Number.isNaN(t))
    }
    w(vp, 'eq')
    function Ap(e, t, r) {
      return Vr(e, t, void 0, void 0, void 0, void 0, r)
    }
    w(Ap, 'isEqualWith')
    function Vr(e, t, r, n, o, a, i) {
      const s = i(e, t, r, n, o, a)
      if (s !== void 0) return s
      if (typeof e === typeof t)
        switch (typeof e) {
          case 'bigint':
          case 'string':
          case 'boolean':
          case 'symbol':
          case 'undefined':
            return e === t
          case 'number':
            return e === t || Object.is(e, t)
          case 'function':
            return e === t
          case 'object':
            return zr(e, t, a, i)
        }
      return zr(e, t, a, i)
    }
    w(Vr, 'isEqualWithImpl')
    function zr(e, t, r, n) {
      if (Object.is(e, t)) return !0
      let o = Wi(e)
      let a = Wi(t)
      if ((o === Yd && (o = $i), a === Yd && (a = $i), o !== a)) return !1
      switch (o) {
        case iv:
          return e.toString() === t.toString()
        case sv: {
          const l = e.valueOf()
          const u = t.valueOf()
          return vp(l, u)
        }
        case lv:
        case cv:
        case uv:
          return Object.is(e.valueOf(), t.valueOf())
        case av:
          return e.source === t.source && e.flags === t.flags
        case hv:
          return e === t
      }
      r = r ?? new Map()
      const i = r.get(e)
      const s = r.get(t)
      if (i != null && s != null) return i === t
      ;(r.set(e, t), r.set(t, e))
      try {
        switch (o) {
          case dv: {
            if (e.size !== t.size) return !1
            for (const [l, u] of e.entries())
              if (!t.has(l) || !Vr(u, t.get(l), l, e, t, r, n)) return !1
            return !0
          }
          case pv: {
            if (e.size !== t.size) return !1
            const l = Array.from(e.values())
            const u = Array.from(t.values())
            for (let d = 0; d < l.length; d++) {
              const m = l[d]
              const p = u.findIndex(f => Vr(m, f, void 0, e, t, r, n))
              if (p === -1) return !1
              u.splice(p, 1)
            }
            return !0
          }
          case mv:
          case bv:
          case Ev:
          case vv:
          case Av:
          case xv:
          case wv:
          case Sv:
          case Cv:
          case Dv:
          case Tv:
          case kv: {
            if (
              (typeof Buffer < 'u' &&
                Buffer.isBuffer(e) !== Buffer.isBuffer(t)) ||
              e.length !== t.length
            )
              return !1
            for (let l = 0; l < e.length; l++)
              if (!Vr(e[l], t[l], l, e, t, r, n)) return !1
            return !0
          }
          case fv:
            return e.byteLength !== t.byteLength
              ? !1
              : zr(new Uint8Array(e), new Uint8Array(t), r, n)
          case yv:
            return e.byteLength !== t.byteLength ||
              e.byteOffset !== t.byteOffset
              ? !1
              : zr(new Uint8Array(e), new Uint8Array(t), r, n)
          case gv:
            return e.name === t.name && e.message === t.message
          case $i: {
            if (!(zr(e.constructor, t.constructor, r, n) || (xt(e) && xt(t))))
              return !1
            const l = [...Object.keys(e), ...Gi(e)]
            const u = [...Object.keys(t), ...Gi(t)]
            if (l.length !== u.length) return !1
            for (let d = 0; d < l.length; d++) {
              const m = l[d]
              const p = e[m]
              if (!Object.hasOwn(t, m)) return !1
              const f = t[m]
              if (!Vr(p, f, m, e, t, r, n)) return !1
            }
            return !0
          }
          default:
            return !1
        }
      } finally {
        ;(r.delete(e), r.delete(t))
      }
    }
    w(zr, 'areObjectsEqual')
    function xp(e, t) {
      return Ap(e, t, bp)
    }
    w(xp, 'isEqual')
    const qi = Jr(ip(), 1)
    function wt(e) {
      for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r]
      let n = Array.from(typeof e === 'string' ? [e] : e)
      n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, '')
      const o = n.reduce(function (s, l) {
        const u = l.match(/\n([\t ]+|(?!\s).)/g)
        return u
          ? s.concat(
              u.map(function (d) {
                let m, p
                return (p =
                  (m = d.match(/[\t ]/g)) === null || m === void 0
                    ? void 0
                    : m.length) !== null && p !== void 0
                  ? p
                  : 0
              })
            )
          : s
      }, [])
      if (o.length) {
        const a = new RegExp(
          `
[	 ]{` +
            Math.min.apply(Math, o) +
            '}',
          'g'
        )
        n = n.map(function (s) {
          return s.replace(
            a,
            `
`
          )
        })
      }
      n[0] = n[0].replace(/^\r?\n/, '')
      let i = n[0]
      return (
        t.forEach(function (s, l) {
          const u = i.match(/(?:^|\n)( *)$/)
          const d = u ? u[1] : ''
          let m = s
          ;(typeof s === 'string' &&
            s.includes(`
`) &&
            (m = String(s)
              .split(
                `
`
              )
              .map(function (p, f) {
                return f === 0 ? p : '' + d + p
              }).join(`
`)),
            (i += m + n[l + 1]))
        }),
        i
      )
    }
    w(wt, 'dedent')
    const Ur = Symbol('incompatible')
    var Yi = w((e, t) => {
      const r = t.type
      if (e == null || !r || t.mapping) return e
      switch (r.name) {
        case 'string':
          return String(e)
        case 'enum':
          return e
        case 'number':
          return Number(e)
        case 'boolean':
          return String(e) === 'true'
        case 'array':
          return !r.value || !Array.isArray(e)
            ? Ur
            : e.reduce((n, o, a) => {
                const i = Yi(o, { type: r.value })
                return (i !== Ur && (n[a] = i), n)
              }, new Array(e.length))
        case 'object':
          return typeof e === 'string' || typeof e === 'number'
            ? e
            : !r.value || typeof e !== 'object'
              ? Ur
              : Object.entries(e).reduce((n, [o, a]) => {
                  const i = Yi(a, { type: r.value[o] })
                  return i === Ur ? n : Object.assign(n, { [o]: i })
                }, {})
        default:
          return Ur
      }
    }, 'map')
    const Ov = w(
      (e, t) =>
        Object.entries(e).reduce((r, [n, o]) => {
          if (!t[n]) return r
          const a = Yi(o, t[n])
          return a === Ur ? r : Object.assign(r, { [n]: a })
        }, {}),
      'mapArgsToTypes'
    )
    var Ki = w(
      (e, t) =>
        Array.isArray(e) && Array.isArray(t)
          ? t
              .reduce((r, n, o) => ((r[o] = Ki(e[o], t[o])), r), [...e])
              .filter(r => r !== void 0)
          : !xt(e) || !xt(t)
            ? t
            : Object.keys({ ...e, ...t }).reduce((r, n) => {
                if (n in t) {
                  const o = Ki(e[n], t[n])
                  o !== void 0 && (r[n] = o)
                } else r[n] = e[n]
                return r
              }, {}),
      'combineArgs'
    )
    const Iv = w(
      (e, t) =>
        Object.entries(t).reduce((r, [n, { options: o }]) => {
          function a() {
            return (n in e && (r[n] = e[n]), r)
          }
          if ((w(a, 'allowArg'), !o)) return a()
          if (!Array.isArray(o))
            return (
              yt.error(wt`
        Invalid argType: '${n}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types
      `),
              a()
            )
          if (o.some(m => m && ['object', 'function'].includes(typeof m)))
            return (
              yt.error(wt`
        Invalid argType: '${n}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
      `),
              a()
            )
          const i = Array.isArray(e[n])
          const s = i && e[n].findIndex(m => !o.includes(m))
          const l = i && s === -1
          if (e[n] === void 0 || o.includes(e[n]) || l) return a()
          const u = i ? `${n}[${s}]` : n
          const d = o
            .map(m => (typeof m === 'string' ? `'${m}'` : String(m)))
            .join(', ')
          return (
            yt.warn(
              `Received illegal value for '${u}'. Supported options: ${d}`
            ),
            r
          )
        }, {}),
      'validateOptions'
    )
    const Bn = Symbol('Deeply equal')
    var Uo = w((e, t) => {
      if (typeof e !== typeof t) return t
      if (xp(e, t)) return Bn
      if (Array.isArray(e) && Array.isArray(t)) {
        const r = t.reduce((n, o, a) => {
          const i = Uo(e[a], o)
          return (i !== Bn && (n[a] = i), n)
        }, new Array(t.length))
        return t.length >= e.length
          ? r
          : r.concat(new Array(e.length - t.length).fill(void 0))
      }
      return xt(e) && xt(t)
        ? Object.keys({ ...e, ...t }).reduce((r, n) => {
            const o = Uo(e?.[n], t?.[n])
            return o === Bn ? r : Object.assign(r, { [n]: o })
          }, {})
        : t
    }, 'deepDiff')
    const wp = 'UNTARGETED'
    function Sp({ args: e, argTypes: t }) {
      const r = {}
      return (
        Object.entries(e).forEach(([n, o]) => {
          const { target: a = wp } = t[n] || {}
          ;((r[a] = r[a] || {}), (r[a][n] = o))
        }),
        r
      )
    }
    w(Sp, 'groupArgsByTarget')
    function Cp(e) {
      return (Object.keys(e).forEach(t => e[t] === void 0 && delete e[t]), e)
    }
    w(Cp, 'deleteUndefined')
    const Dp = class {
      constructor() {
        ;((this.initialArgsByStoryId = {}), (this.argsByStoryId = {}))
      }
      get(t) {
        if (!(t in this.argsByStoryId))
          throw new Error(`No args known for ${t} -- has it been rendered yet?`)
        return this.argsByStoryId[t]
      }
      setInitial(t) {
        if (!this.initialArgsByStoryId[t.id])
          ((this.initialArgsByStoryId[t.id] = t.initialArgs),
            (this.argsByStoryId[t.id] = t.initialArgs))
        else if (this.initialArgsByStoryId[t.id] !== t.initialArgs) {
          const r = Uo(
            this.initialArgsByStoryId[t.id],
            this.argsByStoryId[t.id]
          )
          ;((this.initialArgsByStoryId[t.id] = t.initialArgs),
            (this.argsByStoryId[t.id] = t.initialArgs),
            r !== Bn && this.updateFromDelta(t, r))
        }
      }
      updateFromDelta(t, r) {
        const n = Iv(r, t.argTypes)
        this.argsByStoryId[t.id] = Ki(this.argsByStoryId[t.id], n)
      }
      updateFromPersisted(t, r) {
        const n = Ov(r, t.argTypes)
        return this.updateFromDelta(t, n)
      }
      update(t, r) {
        if (!(t in this.argsByStoryId))
          throw new Error(`No args known for ${t} -- has it been rendered yet?`)
        this.argsByStoryId[t] = Cp({ ...this.argsByStoryId[t], ...r })
      }
    }
    w(Dp, 'ArgsStore')
    const Rv = Dp
    const Tp = w(
      (e = {}) =>
        Object.entries(e).reduce(
          (t, [r, { defaultValue: n }]) => (typeof n < 'u' && (t[r] = n), t),
          {}
        ),
      'getValuesFromArgTypes'
    )
    const kp = class {
      constructor({ globals: t = {}, globalTypes: r = {} }) {
        this.set({ globals: t, globalTypes: r })
      }
      set({ globals: t = {}, globalTypes: r = {} }) {
        const n = this.initialGlobals && Uo(this.initialGlobals, this.globals)
        this.allowedGlobalNames = new Set([
          ...Object.keys(t),
          ...Object.keys(r),
        ])
        const o = Tp(r)
        ;((this.initialGlobals = { ...o, ...t }),
          (this.globals = this.initialGlobals),
          n && n !== Bn && this.updateFromPersisted(n))
      }
      filterAllowedGlobals(t) {
        return Object.entries(t).reduce(
          (r, [n, o]) => (
            this.allowedGlobalNames.has(n)
              ? (r[n] = o)
              : Z.warn(
                  `Attempted to set a global (${n}) that is not defined in initial globals or globalTypes`
                ),
            r
          ),
          {}
        )
      }
      updateFromPersisted(t) {
        const r = this.filterAllowedGlobals(t)
        this.globals = { ...this.globals, ...r }
      }
      get() {
        return this.globals
      }
      update(t) {
        this.globals = { ...this.globals, ...this.filterAllowedGlobals(t) }
        for (const r in t)
          t[r] === void 0 && (this.globals[r] = this.initialGlobals[r])
      }
    }
    w(kp, 'GlobalsStore')
    const Bv = kp
    const _v = Jr(ip(), 1)
    const Fv = (0, _v.default)(1)(e =>
      Object.values(e).reduce(
        (t, r) => ((t[r.importPath] = t[r.importPath] || r), t),
        {}
      )
    )
    const Op = class {
      constructor({ entries: t } = { v: 5, entries: {} }) {
        this.entries = t
      }
      entryFromSpecifier(t) {
        const r = Object.values(this.entries)
        if (t === '*') return r[0]
        if (typeof t === 'string')
          return this.entries[t]
            ? this.entries[t]
            : r.find(a => a.id.startsWith(t))
        const { name: n, title: o } = t
        return r.find(a => a.name === n && a.title === o)
      }
      storyIdToEntry(t) {
        const r = this.entries[t]
        if (!r) throw new xd({ storyId: t })
        return r
      }
      importPathToEntry(t) {
        return Fv(this.entries)[t]
      }
    }
    w(Op, 'StoryIndexStore')
    const Pv = Op
    const Nv = w(
      e => (typeof e === 'string' ? { name: e } : e),
      'normalizeType'
    )
    const Lv = w(
      e => (typeof e === 'string' ? { type: e } : e),
      'normalizeControl'
    )
    const jv = w((e, t) => {
      const { type: r, control: n, ...o } = e
      const a = { name: t, ...o }
      return (
        r && (a.type = Nv(r)),
        n ? (a.control = Lv(n)) : n === !1 && (a.control = { disable: !0 }),
        a
      )
    }, 'normalizeInputType')
    const Ho = w(e => Gr(e, jv), 'normalizeInputTypes')
    const be = w(e => (Array.isArray(e) ? e : e ? [e] : []), 'normalizeArrays')
    const Mv = wt`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`
    function Vo(e, t, r) {
      const n = t
      const o = typeof t === 'function' ? t : null
      const { story: a } = n
      a && (Z.debug('deprecated story', a), $r(Mv))
      const i = Jo(e)
      const s =
        (typeof n !== 'function' && n.name) || n.storyName || a?.name || i
      const l = [...be(n.decorators), ...be(a?.decorators)]
      const u = { ...a?.parameters, ...n.parameters }
      const d = { ...a?.args, ...n.args }
      const m = { ...a?.argTypes, ...n.argTypes }
      const p = [...be(n.loaders), ...be(a?.loaders)]
      const f = [...be(n.beforeEach), ...be(a?.beforeEach)]
      const g = [...be(n.afterEach), ...be(a?.afterEach)]
      const { render: y, play: E, tags: b = [], globals: x = {} } = n
      const S = u.__id || Xo(r.id, i)
      return {
        moduleExport: t,
        id: S,
        name: s,
        tags: b,
        decorators: l,
        parameters: u,
        args: d,
        argTypes: Ho(m),
        loaders: p,
        beforeEach: f,
        afterEach: g,
        globals: x,
        ...(y && { render: y }),
        ...(o && { userStoryFn: o }),
        ...(E && { play: E }),
      }
    }
    w(Vo, 'normalizeStory')
    function zo(e, t = e.title, r) {
      const { id: n, argTypes: o } = e
      return {
        id: Nn(n || t),
        ...e,
        title: t,
        ...(o && { argTypes: Ho(o) }),
        parameters: { fileName: r, ...e.parameters },
      }
    }
    w(zo, 'normalizeComponentAnnotations')
    const $v = w(e => {
      const { globals: t, globalTypes: r } = e
      ;(t || r) &&
        Z.error(
          'Global args/argTypes can only be set globally',
          JSON.stringify({ globals: t, globalTypes: r })
        )
    }, 'checkGlobals')
    const qv = w(e => {
      const { options: t } = e
      t?.storySort &&
        Z.error('The storySort option parameter can only be set globally')
    }, 'checkStorySort')
    const Mo = w(e => {
      e && ($v(e), qv(e))
    }, 'checkDisallowedParameters')
    function Ip(e, t, r) {
      const { default: n, __namedExportsOrder: o, ...a } = e
      const i = Object.values(a)[0]
      if (Ar(i)) {
        const u = zo(i.meta.input, r, t)
        Mo(u.parameters)
        const d = { meta: u, stories: {}, moduleExports: e }
        return (
          Object.keys(a).forEach(m => {
            if (Xr(m, u)) {
              const p = Vo(m, a[m].input, u)
              ;(Mo(p.parameters), (d.stories[p.id] = p))
            }
          }),
          (d.projectAnnotations = i.meta.preview.composed),
          d
        )
      }
      const s = zo(n, r, t)
      Mo(s.parameters)
      const l = { meta: s, stories: {}, moduleExports: e }
      return (
        Object.keys(a).forEach(u => {
          if (Xr(u, s)) {
            const d = Vo(u, a[u], s)
            ;(Mo(d.parameters), (l.stories[d.id] = d))
          }
        }),
        l
      )
    }
    w(Ip, 'processCSFFile')
    function Rp(e) {
      return e != null && Bp(e).includes('mount')
    }
    w(Rp, 'mountDestructured')
    function Bp(e) {
      const t = e.toString().match(/[^(]*\(([^)]*)/)
      if (!t) return []
      const r = Xi(t[1])
      if (!r.length) return []
      const n = r[0]
      return n.startsWith('{') && n.endsWith('}')
        ? Xi(n.slice(1, -1).replace(/\s/g, '')).map(o =>
            o.replace(/:.*|=.*/g, '')
          )
        : []
    }
    w(Bp, 'getUsedProps')
    function Xi(e) {
      const t = []
      const r = []
      let n = 0
      for (let a = 0; a < e.length; a++)
        if (e[a] === '{' || e[a] === '[') r.push(e[a] === '{' ? '}' : ']')
        else if (e[a] === r[r.length - 1]) r.pop()
        else if (!r.length && e[a] === ',') {
          const i = e.substring(n, a).trim()
          ;(i && t.push(i), (n = a + 1))
        }
      const o = e.substring(n).trim()
      return (o && t.push(o), t)
    }
    w(Xi, 'splitByComma')
    function _p(e, t, r) {
      const n = r(e)
      return o => t(n, o)
    }
    w(_p, 'decorateStory')
    function Fp({
      componentId: e,
      title: t,
      kind: r,
      id: n,
      name: o,
      story: a,
      parameters: i,
      initialArgs: s,
      argTypes: l,
      ...u
    } = {}) {
      return u
    }
    w(Fp, 'sanitizeStoryContextUpdate')
    function Pp(e, t) {
      const r = {}
      const n = w(
        a => i => {
          if (!r.value)
            throw new Error('Decorated function called without init')
          return ((r.value = { ...r.value, ...Fp(i) }), a(r.value))
        },
        'bindWithContext'
      )
      const o = t.reduce((a, i) => _p(a, i, n), e)
      return a => ((r.value = a), o(a))
    }
    w(Pp, 'defaultDecorateStory')
    var Wr = w((...e) => {
      const t = {}
      const r = e.filter(Boolean)
      const n = r.reduce(
        (o, a) => (
          Object.entries(a).forEach(([i, s]) => {
            const l = o[i]
            Array.isArray(s) || typeof l > 'u'
              ? (o[i] = s)
              : xt(s) && xt(l)
                ? (t[i] = !0)
                : typeof s < 'u' && (o[i] = s)
          }),
          o
        ),
        {}
      )
      return (
        Object.keys(t).forEach(o => {
          const a = r
            .filter(Boolean)
            .map(i => i[o])
            .filter(i => typeof i < 'u')
          a.every(i => xt(i)) ? (n[o] = Wr(...a)) : (n[o] = a[a.length - 1])
        }),
        n
      )
    }, 'combineParameters')
    function ps(e, t, r) {
      const { moduleExport: n, id: o, name: a } = e || {}
      const i = ms(e, t, r)
      const s = w(async O => {
        const k = {}
        for (const B of [be(r.loaders), be(t.loaders), be(e.loaders)]) {
          if (O.abortSignal.aborted) return k
          const P = await Promise.all(B.map(L => L(O)))
          Object.assign(k, ...P)
        }
        return k
      }, 'applyLoaders')
      const l = w(async O => {
        const k = []
        for (const B of [
          ...be(r.beforeEach),
          ...be(t.beforeEach),
          ...be(e.beforeEach),
        ]) {
          if (O.abortSignal.aborted) return k
          const P = await B(O)
          P && k.push(P)
        }
        return k
      }, 'applyBeforeEach')
      const u = w(async O => {
        const k = [
          ...be(r.afterEach),
          ...be(t.afterEach),
          ...be(e.afterEach),
        ].reverse()
        for (const B of k) {
          if (O.abortSignal.aborted) return
          await B(O)
        }
      }, 'applyAfterEach')
      const d = w(O => O.originalStoryFn(O.args, O), 'undecoratedStoryFn')
      const { applyDecorators: m = Pp, runStep: p } = r
      const f = [
        ...be(e?.decorators),
        ...be(t?.decorators),
        ...be(r?.decorators),
      ]
      const g = e?.userStoryFn || e?.render || t.render || r.render
      const y = XE(m)(d, f)
      const E = w(O => y(O), 'unboundStoryFn')
      const b = e?.play ?? t?.play
      const x = Rp(b)
      if (!g && !x) throw new Lo({ id: o })
      const S = w(
        O => async () => (await O.renderToCanvas(), O.canvas),
        'defaultMount'
      )
      const T = e.mount ?? t.mount ?? r.mount ?? S
      const _ = r.testingLibraryRender
      return {
        storyGlobals: {},
        ...i,
        moduleExport: n,
        id: o,
        name: a,
        story: a,
        originalStoryFn: g,
        undecoratedStoryFn: d,
        unboundStoryFn: E,
        applyLoaders: s,
        applyBeforeEach: l,
        applyAfterEach: u,
        playFunction: b,
        runStep: p,
        mount: T,
        testingLibraryRender: _,
        renderToCanvas: r.renderToCanvas,
        usesMount: x,
      }
    }
    w(ps, 'prepareStory')
    function Np(e, t, r) {
      return { ...ms(void 0, e, t), moduleExport: r }
    }
    w(Np, 'prepareMeta')
    function ms(e, t, r) {
      const n = ['dev', 'test']
      const o = H.DOCS_OPTIONS?.autodocs === !0 ? ['autodocs'] : []
      const a = en(
        ...n,
        ...o,
        ...(r.tags ?? []),
        ...(t.tags ?? []),
        ...(e?.tags ?? [])
      )
      const i = Wr(r.parameters, t.parameters, e?.parameters)
      const { argTypesEnhancers: s = [], argsEnhancers: l = [] } = r
      const u = Wr(r.argTypes, t.argTypes, e?.argTypes)
      if (e) {
        const b = e?.userStoryFn || e?.render || t.render || r.render
        i.__isArgsStory = b && b.length > 0
      }
      const d = { ...r.args, ...t.args, ...e?.args }
      const m = { ...t.globals, ...e?.globals }
      const p = {
        componentId: t.id,
        title: t.title,
        kind: t.title,
        id: e?.id || t.id,
        name: e?.name || '__meta',
        story: e?.name || '__meta',
        component: t.component,
        subcomponents: t.subcomponents,
        tags: a,
        parameters: i,
        initialArgs: d,
        argTypes: u,
        storyGlobals: m,
      }
      p.argTypes = s.reduce((b, x) => x({ ...p, argTypes: b }), p.argTypes)
      const f = { ...d }
      p.initialArgs = [...l].reduce(
        (b, x) => ({ ...b, ...x({ ...p, initialArgs: b }) }),
        f
      )
      const { name: g, story: y, ...E } = p
      return E
    }
    w(ms, 'preparePartialAnnotations')
    function hs(e) {
      const { args: t } = e
      let r = { ...e, allArgs: void 0, argsByTarget: void 0 }
      if (H.FEATURES?.argTypeTargetsV7) {
        const a = Sp(e)
        r = { ...e, allArgs: e.args, argsByTarget: a, args: a[wp] || {} }
      }
      const n = Object.entries(r.args).reduce((a, [i, s]) => {
        if (!r.argTypes[i]?.mapping) return ((a[i] = s), a)
        const l = w(u => {
          const d = r.argTypes[i].mapping
          return d && u in d ? d[u] : u
        }, 'mappingFn')
        return ((a[i] = Array.isArray(s) ? s.map(l) : l(s)), a)
      }, {})
      const o = Object.entries(n).reduce((a, [i, s]) => {
        const l = r.argTypes[i] || {}
        return (Zr(l, n, r.globals) && (a[i] = s), a)
      }, {})
      return { ...r, unmappedArgs: t, args: o }
    }
    w(hs, 'prepareContext')
    var Ji = w((e, t, r) => {
      const n = typeof e
      switch (n) {
        case 'boolean':
        case 'string':
        case 'number':
        case 'function':
        case 'symbol':
          return { name: n }
        default:
          break
      }
      return e
        ? r.has(e)
          ? (Z.warn(wt`
        We've detected a cycle in arg '${t}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `),
            { name: 'other', value: 'cyclic object' })
          : (r.add(e),
            Array.isArray(e)
              ? {
                  name: 'array',
                  value:
                    e.length > 0
                      ? Ji(e[0], t, new Set(r))
                      : { name: 'other', value: 'unknown' },
                }
              : { name: 'object', value: Gr(e, o => Ji(o, t, new Set(r))) })
        : { name: 'object', value: {} }
    }, 'inferType')
    const Lp = w(e => {
      const { id: t, argTypes: r = {}, initialArgs: n = {} } = e
      const o = Gr(n, (i, s) => ({
        name: s,
        type: Ji(i, `${t}.${s}`, new Set()),
      }))
      const a = Gr(r, (i, s) => ({ name: s }))
      return Wr(o, a, r)
    }, 'inferArgTypes')
    Lp.secondPass = !0
    const Kd = w(
      (e, t) => (Array.isArray(t) ? t.includes(e) : e.match(t)),
      'matches'
    )
    const Uv = w(
      (e, t, r) =>
        !t && !r
          ? e
          : e &&
            Ep(e, (n, o) => {
              const a = n.name || o.toString()
              return !!(!t || Kd(a, t)) && (!r || !Kd(a, r))
            }),
      'filterArgTypes'
    )
    const Hv = w((e, t, r) => {
      const { type: n, options: o } = e
      if (n) {
        if (r.color && r.color.test(t)) {
          const a = n.name
          if (a === 'string') return { control: { type: 'color' } }
          a !== 'enum' &&
            Z.warn(
              `Addon controls: Control of type color only supports string, received "${a}" instead`
            )
        }
        if (r.date && r.date.test(t)) return { control: { type: 'date' } }
        switch (n.name) {
          case 'array':
            return { control: { type: 'object' } }
          case 'boolean':
            return { control: { type: 'boolean' } }
          case 'string':
            return { control: { type: 'text' } }
          case 'number':
            return { control: { type: 'number' } }
          case 'enum': {
            const { value: a } = n
            return {
              control: { type: a?.length <= 5 ? 'radio' : 'select' },
              options: a,
            }
          }
          case 'function':
          case 'symbol':
            return null
          default:
            return { control: { type: o ? 'select' : 'object' } }
        }
      }
    }, 'inferControl')
    const jp = w(e => {
      const {
        argTypes: t,
        parameters: {
          __isArgsStory: r,
          controls: {
            include: n = null,
            exclude: o = null,
            matchers: a = {},
          } = {},
        },
      } = e
      if (!r) return t
      const i = Uv(t, n, o)
      const s = Gr(i, (l, u) => l?.type && Hv(l, u.toString(), a))
      return Wr(s, i)
    }, 'inferControls')
    jp.secondPass = !0
    function Go({
      argTypes: e,
      globalTypes: t,
      argTypesEnhancers: r,
      decorators: n,
      loaders: o,
      beforeEach: a,
      afterEach: i,
      initialGlobals: s,
      ...l
    }) {
      return {
        ...(e && { argTypes: Ho(e) }),
        ...(t && { globalTypes: Ho(t) }),
        decorators: be(n),
        loaders: be(o),
        beforeEach: be(a),
        afterEach: be(i),
        argTypesEnhancers: [...(r || []), Lp, jp],
        initialGlobals: s,
        ...l,
      }
    }
    w(Go, 'normalizeProjectAnnotations')
    const Vv = w(
      e => async () => {
        const t = []
        for (const r of e) {
          const n = await r()
          n && t.unshift(n)
        }
        return async () => {
          for (const r of t) await r()
        }
      },
      'composeBeforeAllHooks'
    )
    function Mp(e) {
      return async (t, r, n) => {
        await e.reduceRight(
          (o, a) => async () => a(t, o, n),
          async () => r(n)
        )()
      }
    }
    w(Mp, 'composeStepRunners')
    function Yr(e, t) {
      return e.map(r => r.default?.[t] ?? r[t]).filter(Boolean)
    }
    w(Yr, 'getField')
    function jt(e, t, r = {}) {
      return Yr(e, t).reduce((n, o) => {
        const a = be(o)
        return r.reverseFileOrder ? [...a, ...n] : [...n, ...a]
      }, [])
    }
    w(jt, 'getArrayField')
    function Rn(e, t) {
      return Object.assign({}, ...Yr(e, t))
    }
    w(Rn, 'getObjectField')
    function Hr(e, t) {
      return Yr(e, t).pop()
    }
    w(Hr, 'getSingletonField')
    function Kr(e) {
      const t = jt(e, 'argTypesEnhancers')
      const r = Yr(e, 'runStep')
      const n = jt(e, 'beforeAll')
      return {
        parameters: Wr(...Yr(e, 'parameters')),
        decorators: jt(e, 'decorators', {
          reverseFileOrder: !(H.FEATURES?.legacyDecoratorFileOrder ?? !1),
        }),
        args: Rn(e, 'args'),
        argsEnhancers: jt(e, 'argsEnhancers'),
        argTypes: Rn(e, 'argTypes'),
        argTypesEnhancers: [
          ...t.filter(o => !o.secondPass),
          ...t.filter(o => o.secondPass),
        ],
        initialGlobals: Rn(e, 'initialGlobals'),
        globalTypes: Rn(e, 'globalTypes'),
        loaders: jt(e, 'loaders'),
        beforeAll: Vv(n),
        beforeEach: jt(e, 'beforeEach'),
        afterEach: jt(e, 'afterEach'),
        render: Hr(e, 'render'),
        renderToCanvas: Hr(e, 'renderToCanvas'),
        applyDecorators: Hr(e, 'applyDecorators'),
        runStep: Mp(r),
        tags: jt(e, 'tags'),
        mount: Hr(e, 'mount'),
        testingLibraryRender: Hr(e, 'testingLibraryRender'),
      }
    }
    w(Kr, 'composeConfigs')
    function fs() {
      try {
        return (
          !!globalThis.__vitest_browser__ ||
          !!globalThis.window?.navigator?.userAgent?.match(
            /StorybookTestRunner/
          )
        )
      } catch {
        return !1
      }
    }
    w(fs, 'isTestEnvironment')
    function gs(e = !0) {
      if (!('document' in globalThis && 'createElement' in globalThis.document))
        return () => {}
      const t = document.createElement('style')
      ;((t.textContent = `*, *:before, *:after {
    animation: none !important;
  }`),
        document.head.appendChild(t))
      const r = document.createElement('style')
      return (
        (r.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${e ? 'reverse' : 'normal'} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`),
        document.head.appendChild(r),
        document.body.clientHeight,
        document.head.removeChild(t),
        () => {
          r.parentNode?.removeChild(r)
        }
      )
    }
    w(gs, 'pauseAnimations')
    async function ys(e) {
      if (
        !(
          'document' in globalThis &&
          'getAnimations' in globalThis.document &&
          'querySelectorAll' in globalThis.document
        )
      )
        return
      let t = !1
      await Promise.race([
        new Promise(r => {
          setTimeout(() => {
            const n = [globalThis.document, ...bs(globalThis.document)]
            const o = w(async () => {
              if (t || e?.aborted) return
              const a = n
                .flatMap(i => i?.getAnimations?.() || [])
                .filter(i => i.playState === 'running' && !$p(i))
              a.length > 0 &&
                (await Promise.all(a.map(i => i.finished)), await o())
            }, 'checkAnimationsFinished')
            o().then(r)
          }, 100)
        }),
        new Promise(r =>
          setTimeout(() => {
            ;((t = !0), r(void 0))
          }, 5e3)
        ),
      ])
    }
    w(ys, 'waitForAnimations')
    function bs(e) {
      return [e, ...e.querySelectorAll('*')].reduce(
        (t, r) => (
          'shadowRoot' in r &&
            r.shadowRoot &&
            t.push(r.shadowRoot, ...bs(r.shadowRoot)),
          t
        ),
        []
      )
    }
    w(bs, 'getShadowRoots')
    function $p(e) {
      if (
        e instanceof CSSAnimation &&
        e.effect instanceof KeyframeEffect &&
        e.effect.target
      ) {
        const t = getComputedStyle(e.effect.target, e.effect.pseudoElement)
        const r = t.animationName?.split(', ').indexOf(e.animationName)
        return t.animationIterationCount.split(', ')[r] === 'infinite'
      }
      return !1
    }
    w($p, 'isInfiniteAnimation')
    const qp = class {
      constructor() {
        this.reports = []
      }
      async addReport(t) {
        this.reports.push(t)
      }
    }
    w(qp, 'ReporterAPI')
    const Up = qp
    function Hp(e, t, r) {
      return Ar(e)
        ? {
            story: e.input,
            meta: e.meta.input,
            preview: e.meta.preview.composed,
          }
        : { story: e, meta: t, preview: r }
    }
    w(Hp, 'getCsfFactoryAnnotations')
    function zv(e) {
      globalThis.defaultProjectAnnotations = e
    }
    w(zv, 'setDefaultProjectAnnotations')
    const Gv = 'ComposedStory'
    const Wv = 'Unnamed Story'
    function Vp(e) {
      return e ? Kr([e]) : {}
    }
    w(Vp, 'extractAnnotation')
    function Yv(e) {
      const t = Array.isArray(e) ? e : [e]
      return (
        (globalThis.globalProjectAnnotations = Kr([
          ...Qr(),
          globalThis.defaultProjectAnnotations ?? {},
          Kr(t.map(Vp)),
        ])),
        globalThis.globalProjectAnnotations ?? {}
      )
    }
    w(Yv, 'setProjectAnnotations')
    const nr = []
    function zp(e, t, r, n, o) {
      if (e === void 0)
        throw new Error('Expected a story but received undefined.')
      t.title = t.title ?? Gv
      const a = zo(t)
      const i = o || e.storyName || e.story?.name || e.name || Wv
      const s = Vo(i, e, a)
      const l = Go(
        Kr([n ?? globalThis.globalProjectAnnotations ?? {}, r ?? {}])
      )
      const u = ps(s, a, l)
      const d = { ...Tp(l.globalTypes), ...l.initialGlobals, ...u.storyGlobals }
      const m = new Up()
      const p = w(() => {
        const b = hs({
          hooks: new fp(),
          globals: d,
          args: { ...u.initialArgs },
          viewMode: 'story',
          reporting: m,
          loaded: {},
          abortSignal: new AbortController().signal,
          step: w((x, S) => u.runStep(x, S, b), 'step'),
          canvasElement: null,
          canvas: {},
          userEvent: {},
          globalTypes: l.globalTypes,
          ...u,
          context: null,
          mount: null,
        })
        return (
          (b.parameters.__isPortableStory = !0),
          (b.context = b),
          u.renderToCanvas &&
            (b.renderToCanvas = async () => {
              const x = await u.renderToCanvas?.(
                {
                  componentId: u.componentId,
                  title: u.title,
                  id: u.id,
                  name: u.name,
                  tags: u.tags,
                  showMain: w(() => {}, 'showMain'),
                  showError: w(S => {
                    throw new Error(`${S.title}
${S.description}`)
                  }, 'showError'),
                  showException: w(S => {
                    throw S
                  }, 'showException'),
                  forceRemount: !0,
                  storyContext: b,
                  storyFn: w(() => u.unboundStoryFn(b), 'storyFn'),
                  unboundStoryFn: u.unboundStoryFn,
                },
                b.canvasElement
              )
              x && nr.push(x)
            }),
          (b.mount = u.mount(b)),
          b
        )
      }, 'initializeContext')
      let f
      const g = w(async b => {
        const x = p()
        return (
          (x.canvasElement ??= globalThis?.document?.body),
          f && (x.loaded = f.loaded),
          Object.assign(x, b),
          u.playFunction(x)
        )
      }, 'play')
      const y = w(b => {
        const x = p()
        return (Object.assign(x, b), Gp(u, x))
      }, 'run')
      const E = u.playFunction ? g : void 0
      return Object.assign(
        w(function (b) {
          const x = p()
          return (
            f && (x.loaded = f.loaded),
            (x.args = { ...x.initialArgs, ...b }),
            u.unboundStoryFn(x)
          )
        }, 'storyFn'),
        {
          id: u.id,
          storyName: i,
          load: w(async () => {
            for (const x of [...nr].reverse()) await x()
            nr.length = 0
            const b = p()
            ;((b.loaded = await u.applyLoaders(b)),
              nr.push(...(await u.applyBeforeEach(b)).filter(Boolean)),
              (f = b))
          }, 'load'),
          globals: d,
          args: u.initialArgs,
          parameters: u.parameters,
          argTypes: u.argTypes,
          play: E,
          run: y,
          reporting: m,
          tags: u.tags,
        }
      )
    }
    w(zp, 'composeStory')
    const Kv = w((e, t, r, n) => zp(e, t, r, {}, n), 'defaultComposeStory')
    function Xv(e, t, r = Kv) {
      const { default: n, __esModule: o, __namedExportsOrder: a, ...i } = e
      let s = n
      return Object.entries(i).reduce((l, [u, d]) => {
        const { story: m, meta: p } = Hp(d)
        return (
          !s && p && (s = p),
          Xr(u, s) ? Object.assign(l, { [u]: r(m, s, t, u) }) : l
        )
      }, {})
    }
    w(Xv, 'composeStories')
    function Jv(e) {
      return e.extend({
        mount: w(async ({ mount: t, page: r }, n) => {
          await n(async (o, ...a) => {
            if (
              !('__pw_type' in o) ||
              ('__pw_type' in o && o.__pw_type !== 'jsx')
            )
              throw new Error(wt`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories-playwright
            `)
            const { props: i, ...s } = o
            await r.evaluate(async u => {
              const d = await globalThis.__pwUnwrapObject?.(u)
              return ('__pw_type' in d ? d.type : d)?.load?.()
            }, s)
            const l = await t(o, ...a)
            return (
              await r.evaluate(async u => {
                const d = await globalThis.__pwUnwrapObject?.(u)
                const m = '__pw_type' in d ? d.type : d
                const p = document.querySelector('#root')
                return m?.play?.({ canvasElement: p })
              }, s),
              l
            )
          })
        }, 'mount'),
      })
    }
    w(Jv, 'createPlaywrightTest')
    async function Gp(e, t) {
      for (const a of [...nr].reverse()) await a()
      if (((nr.length = 0), !t.canvasElement)) {
        const a = document.createElement('div')
        ;(globalThis?.document?.body?.appendChild(a),
          (t.canvasElement = a),
          nr.push(() => {
            globalThis?.document?.body?.contains(a) &&
              globalThis?.document?.body?.removeChild(a)
          }))
      }
      if (((t.loaded = await e.applyLoaders(t)), t.abortSignal.aborted)) return
      nr.push(...(await e.applyBeforeEach(t)).filter(Boolean))
      const r = e.playFunction
      const n = e.usesMount
      if ((n || (await t.mount()), t.abortSignal.aborted)) return
      r &&
        (n ||
          (t.mount = async () => {
            throw new qr({ playFunction: r.toString() })
          }),
        await r(t))
      let o
      ;(fs() ? (o = gs()) : await ys(t.abortSignal),
        await e.applyAfterEach(t),
        await o?.())
    }
    w(Gp, 'runStory')
    const Xd = 1e3
    const Zv = 1e4
    const Wp = class {
      constructor(t, r, n) {
        ;((this.importFn = r),
          (this.storyIndex = new Pv(t)),
          (this.projectAnnotations = Go(Kr([...Qr(), n]))))
        const { initialGlobals: o, globalTypes: a } = this.projectAnnotations
        ;((this.args = new Rv()),
          (this.userGlobals = new Bv({ globals: o, globalTypes: a })),
          (this.hooks = {}),
          (this.cleanupCallbacks = {}),
          (this.processCSFFileWithCache = (0, qi.default)(Xd)(Ip)),
          (this.prepareMetaWithCache = (0, qi.default)(Xd)(Np)),
          (this.prepareStoryWithCache = (0, qi.default)(Zv)(ps)))
      }
      setProjectAnnotations(t) {
        this.projectAnnotations = Go(t)
        const { initialGlobals: r, globalTypes: n } = t
        this.userGlobals.set({ globals: r, globalTypes: n })
      }
      async onStoriesChanged({ importFn: t, storyIndex: r }) {
        ;(t && (this.importFn = t),
          r && (this.storyIndex.entries = r.entries),
          this.cachedCSFFiles && (await this.cacheAllCSFFiles()))
      }
      async storyIdToEntry(t) {
        return this.storyIndex.storyIdToEntry(t)
      }
      async loadCSFFileByStoryId(t) {
        const { importPath: r, title: n } = this.storyIndex.storyIdToEntry(t)
        const o = await this.importFn(r)
        return this.processCSFFileWithCache(o, r, n)
      }
      async loadAllCSFFiles() {
        const t = {}
        return (
          Object.entries(this.storyIndex.entries).forEach(
            ([r, { importPath: n }]) => {
              t[n] = r
            }
          ),
          (
            await Promise.all(
              Object.entries(t).map(async ([r, n]) => ({
                importPath: r,
                csfFile: await this.loadCSFFileByStoryId(n),
              }))
            )
          ).reduce((r, { importPath: n, csfFile: o }) => ((r[n] = o), r), {})
        )
      }
      async cacheAllCSFFiles() {
        this.cachedCSFFiles = await this.loadAllCSFFiles()
      }
      preparedMetaFromCSFFile({ csfFile: t }) {
        const r = t.meta
        return this.prepareMetaWithCache(
          r,
          this.projectAnnotations,
          t.moduleExports.default
        )
      }
      async loadStory({ storyId: t }) {
        const r = await this.loadCSFFileByStoryId(t)
        return this.storyFromCSFFile({ storyId: t, csfFile: r })
      }
      storyFromCSFFile({ storyId: t, csfFile: r }) {
        const n = r.stories[t]
        if (!n) throw new Md({ storyId: t })
        const o = r.meta
        const a = this.prepareStoryWithCache(
          n,
          o,
          r.projectAnnotations ?? this.projectAnnotations
        )
        return (
          this.args.setInitial(a),
          (this.hooks[a.id] = this.hooks[a.id] || new fp()),
          a
        )
      }
      componentStoriesFromCSFFile({ csfFile: t }) {
        return Object.keys(this.storyIndex.entries)
          .filter(r => !!t.stories[r])
          .map(r => this.storyFromCSFFile({ storyId: r, csfFile: t }))
      }
      async loadEntry(t) {
        const r = await this.storyIdToEntry(t)
        const n = r.type === 'docs' ? r.storiesImports : []
        const [o, ...a] = await Promise.all([
          this.importFn(r.importPath),
          ...n.map(i => {
            const s = this.storyIndex.importPathToEntry(i)
            return this.loadCSFFileByStoryId(s.id)
          }),
        ])
        return { entryExports: o, csfFiles: a }
      }
      getStoryContext(t, { forceInitialArgs: r = !1 } = {}) {
        const n = this.userGlobals.get()
        const { initialGlobals: o } = this.userGlobals
        const a = new Up()
        return hs({
          ...t,
          args: r ? t.initialArgs : this.args.get(t.id),
          initialGlobals: o,
          globalTypes: this.projectAnnotations.globalTypes,
          userGlobals: n,
          reporting: a,
          globals: { ...n, ...t.storyGlobals },
          hooks: this.hooks[t.id],
        })
      }
      addCleanupCallbacks(t, ...r) {
        this.cleanupCallbacks[t.id] = (
          this.cleanupCallbacks[t.id] || []
        ).concat(r)
      }
      async cleanupStory(t) {
        this.hooks[t.id].clean()
        const r = this.cleanupCallbacks[t.id]
        if (r) for (const n of [...r].reverse()) await n()
        delete this.cleanupCallbacks[t.id]
      }
      extract(t = { includeDocsOnly: !1 }) {
        const { cachedCSFFiles: r } = this
        if (!r) throw new Dd()
        return Object.entries(this.storyIndex.entries).reduce(
          (n, [o, { type: a, importPath: i }]) => {
            if (a === 'docs') return n
            const s = r[i]
            const l = this.storyFromCSFFile({ storyId: o, csfFile: s })
            return (
              (!t.includeDocsOnly && l.parameters.docsOnly) ||
                (n[o] = Object.entries(l).reduce(
                  (u, [d, m]) =>
                    d === 'moduleExport' || typeof m === 'function'
                      ? u
                      : Array.isArray(m)
                        ? Object.assign(u, { [d]: m.slice().sort() })
                        : Object.assign(u, { [d]: m }),
                  {
                    args: l.initialArgs,
                    globals: {
                      ...this.userGlobals.initialGlobals,
                      ...this.userGlobals.globals,
                      ...l.storyGlobals,
                    },
                  }
                )),
              n
            )
          },
          {}
        )
      }
    }
    w(Wp, 'StoryStore')
    const Qv = Wp
    function Yp(e) {
      return e.startsWith('\\\\?\\') ? e : e.replace(/\\/g, '/')
    }
    w(Yp, 'slash')
    const eA = w(e => {
      if (e.length === 0) return e
      const t = e[e.length - 1]
      const r = t?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, '')
      if (e.length === 1) return [r]
      const n = e[e.length - 2]
      return r && n && r.toLowerCase() === n.toLowerCase()
        ? [...e.slice(0, -2), r]
        : r && (/^(story|stories)([.][^.]+)$/i.test(t) || /^index$/i.test(r))
          ? e.slice(0, -1)
          : [...e.slice(0, -1), r]
    }, 'sanitize')
    function Zi(e) {
      return e
        .flatMap(t => t.split('/'))
        .filter(Boolean)
        .join('/')
    }
    w(Zi, 'pathJoin')
    const tA = w((e, t, r) => {
      const {
        directory: n,
        importPathMatcher: o,
        titlePrefix: a = '',
      } = t || {}
      typeof e === 'number' &&
        yt.warn(wt`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `)
      const i = Yp(String(e))
      if (o.exec(i)) {
        if (!r) {
          const s = i.replace(n, '')
          let l = Zi([a, s]).split('/')
          return ((l = eA(l)), l.join('/'))
        }
        return a ? Zi([a, r]) : r
      }
    }, 'userOrAutoTitleFromSpecifier')
    const P6 = w((e, t, r) => {
      for (let n = 0; n < t.length; n += 1) {
        const o = tA(e, t[n], r)
        if (o) return o
      }
      return r || void 0
    }, 'userOrAutoTitle')
    const Jd = /\s*\/\s*/
    const rA = w(
      (e = {}) =>
        (t, r) => {
          if (t.title === r.title && !e.includeNames) return 0
          const n = e.method || 'configure'
          let o = e.order || []
          const a = t.title.trim().split(Jd)
          const i = r.title.trim().split(Jd)
          e.includeNames && (a.push(t.name), i.push(r.name))
          let s = 0
          for (; a[s] || i[s]; ) {
            if (!a[s]) return -1
            if (!i[s]) return 1
            const l = a[s]
            const u = i[s]
            if (l !== u) {
              let m = o.indexOf(l)
              let p = o.indexOf(u)
              const f = o.indexOf('*')
              return m !== -1 || p !== -1
                ? (m === -1 && (f !== -1 ? (m = f) : (m = o.length)),
                  p === -1 && (f !== -1 ? (p = f) : (p = o.length)),
                  m - p)
                : n === 'configure'
                  ? 0
                  : l.localeCompare(u, e.locales ? e.locales : void 0, {
                      numeric: !0,
                      sensitivity: 'accent',
                    })
            }
            let d = o.indexOf(l)
            ;(d === -1 && (d = o.indexOf('*')),
              (o = d !== -1 && Array.isArray(o[d + 1]) ? o[d + 1] : []),
              (s += 1))
          }
          return 0
        },
      'storySort'
    )
    const nA = w((e, t, r) => {
      if (t) {
        let n
        ;(typeof t === 'function' ? (n = t) : (n = rA(t)), e.sort(n))
      } else e.sort((n, o) => r.indexOf(n.importPath) - r.indexOf(o.importPath))
      return e
    }, 'sortStoriesCommon')
    const N6 = w((e, t, r) => {
      try {
        return nA(e, t, r)
      } catch (n) {
        throw new Error(wt`
    Error sorting stories with sort parameter ${t}:

    > ${n.message}
    
    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `)
      }
    }, 'sortStoriesV7')
    const Ko = new Error('prepareAborted')
    const { AbortController: Zd } = globalThis
    function Qi(e) {
      try {
        const { name: t = 'Error', message: r = String(e), stack: n } = e
        return { name: t, message: r, stack: n }
      } catch {
        return { name: 'Error', message: String(e) }
      }
    }
    w(Qi, 'serializeError')
    const Kp = class {
      constructor(
        t,
        r,
        n,
        o,
        a,
        i,
        s = { autoplay: !0, forceInitialArgs: !1 },
        l
      ) {
        ;((this.channel = t),
          (this.store = r),
          (this.renderToScreen = n),
          (this.callbacks = o),
          (this.id = a),
          (this.viewMode = i),
          (this.renderOptions = s),
          (this.type = 'story'),
          (this.notYetRendered = !0),
          (this.rerenderEnqueued = !1),
          (this.disableKeyListeners = !1),
          (this.teardownRender = w(() => {}, 'teardownRender')),
          (this.torndown = !1),
          (this.abortController = new Zd()),
          (this.renderId = Date.now()),
          l && ((this.story = l), (this.phase = 'preparing')))
      }
      async runPhase(t, r, n) {
        ;((this.phase = r),
          this.channel.emit(gt, {
            newPhase: this.phase,
            renderId: this.renderId,
            storyId: this.id,
          }),
          n && (await n(), this.checkIfAborted(t)))
      }
      checkIfAborted(t) {
        return t.aborted
          ? ((this.phase = 'aborted'),
            this.channel.emit(gt, {
              newPhase: this.phase,
              renderId: this.renderId,
              storyId: this.id,
            }),
            !0)
          : !1
      }
      async prepare() {
        if (
          (await this.runPhase(
            this.abortController.signal,
            'preparing',
            async () => {
              this.story = await this.store.loadStory({ storyId: this.id })
            }
          ),
          this.abortController.signal.aborted)
        )
          throw (await this.store.cleanupStory(this.story), Ko)
      }
      isEqual(t) {
        return !!(this.id === t.id && this.story && this.story === t.story)
      }
      isPreparing() {
        return ['preparing'].includes(this.phase)
      }
      isPending() {
        return [
          'loading',
          'beforeEach',
          'rendering',
          'playing',
          'afterEach',
        ].includes(this.phase)
      }
      async renderToElement(t) {
        return (
          (this.canvasElement = t),
          this.render({ initial: !0, forceRemount: !0 })
        )
      }
      storyContext() {
        if (!this.story)
          throw new Error('Cannot call storyContext before preparing')
        const { forceInitialArgs: t } = this.renderOptions
        return this.store.getStoryContext(this.story, { forceInitialArgs: t })
      }
      async render({ initial: t = !1, forceRemount: r = !1 } = {}) {
        const { canvasElement: n } = this
        if (!this.story) throw new Error('cannot render when not prepared')
        const o = this.story
        if (!n) throw new Error('cannot render when canvasElement is unset')
        const {
          id: a,
          componentId: i,
          title: s,
          name: l,
          tags: u,
          applyLoaders: d,
          applyBeforeEach: m,
          applyAfterEach: p,
          unboundStoryFn: f,
          playFunction: g,
          runStep: y,
        } = o
        r && !t && (this.cancelRender(), (this.abortController = new Zd()))
        const E = this.abortController.signal
        let b = !1
        const x = o.usesMount
        try {
          const S = {
            ...this.storyContext(),
            viewMode: this.viewMode,
            abortSignal: E,
            canvasElement: n,
            loaded: {},
            step: w(($, v) => y($, v, S), 'step'),
            context: null,
            canvas: {},
            userEvent: {},
            renderToCanvas: w(async () => {
              const $ = await this.renderToScreen(T, n)
              ;((this.teardownRender = $ || (() => {})), (b = !0))
            }, 'renderToCanvas'),
            mount: w(async (...$) => {
              this.callbacks.showStoryDuringRender?.()
              let v = null
              return (
                await this.runPhase(E, 'rendering', async () => {
                  v = await o.mount(S)(...$)
                }),
                x && (await this.runPhase(E, 'playing')),
                v
              )
            }, 'mount'),
          }
          S.context = S
          const T = {
            componentId: i,
            title: s,
            kind: s,
            id: a,
            name: l,
            story: l,
            tags: u,
            ...this.callbacks,
            showError: w(
              $ => ((this.phase = 'errored'), this.callbacks.showError($)),
              'showError'
            ),
            showException: w(
              $ => ((this.phase = 'errored'), this.callbacks.showException($)),
              'showException'
            ),
            forceRemount: r || this.notYetRendered,
            storyContext: S,
            storyFn: w(() => f(S), 'storyFn'),
            unboundStoryFn: f,
          }
          if (
            (await this.runPhase(E, 'loading', async () => {
              S.loaded = await d(S)
            }),
            E.aborted)
          )
            return
          const _ = await m(S)
          if (
            (this.store.addCleanupCallbacks(o, ..._),
            this.checkIfAborted(E) ||
              (!b && !x && (await S.mount()),
              (this.notYetRendered = !1),
              E.aborted))
          )
            return
          const O =
            this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === !0
          const k = new Set()
          const B = w($ => {
            $.error && k.add($.error)
          }, 'onError')
          const P = w($ => {
            $.reason && k.add($.reason)
          }, 'onUnhandledRejection')
          if (
            this.renderOptions.autoplay &&
            r &&
            g &&
            this.phase !== 'errored'
          ) {
            ;(window?.addEventListener?.('error', B),
              window?.addEventListener?.('unhandledrejection', P),
              (this.disableKeyListeners = !0))
            try {
              if (
                (x
                  ? await g(S)
                  : ((S.mount = async () => {
                      throw new qr({ playFunction: g.toString() })
                    }),
                    await this.runPhase(E, 'playing', async () => g(S))),
                !b)
              )
                throw new zd()
              ;(this.checkIfAborted(E),
                !O && k.size > 0
                  ? await this.runPhase(E, 'errored')
                  : await this.runPhase(E, 'played'))
            } catch ($) {
              if (
                (this.callbacks.showStoryDuringRender?.(),
                await this.runPhase(E, 'errored', async () => {
                  this.channel.emit(ko, Qi($))
                }),
                this.story.parameters.throwPlayFunctionExceptions !== !1)
              )
                throw $
              console.error($)
            }
            if (
              (!O && k.size > 0 && this.channel.emit(_o, Array.from(k).map(Qi)),
              (this.disableKeyListeners = !1),
              window?.removeEventListener?.('unhandledrejection', P),
              window?.removeEventListener?.('error', B),
              E.aborted)
            )
              return
          }
          ;(await this.runPhase(E, 'completing', async () => {
            fs() ? this.store.addCleanupCallbacks(o, gs()) : await ys(E)
          }),
            await this.runPhase(E, 'completed', async () => {
              this.channel.emit(rr, a)
            }),
            this.phase !== 'errored' &&
              (await this.runPhase(E, 'afterEach', async () => {
                await p(S)
              })))
          const L = !O && k.size > 0
          const j = S.reporting.reports.some($ => $.status === 'failed')
          const U = L || j
          await this.runPhase(E, 'finished', async () =>
            this.channel.emit(Pi, {
              storyId: a,
              status: U ? 'error' : 'success',
              reporters: S.reporting.reports,
            })
          )
        } catch (S) {
          ;((this.phase = 'errored'),
            this.callbacks.showException(S),
            await this.runPhase(E, 'finished', async () =>
              this.channel.emit(Pi, {
                storyId: a,
                status: 'error',
                reporters: [],
              })
            ))
        }
        this.rerenderEnqueued && ((this.rerenderEnqueued = !1), this.render())
      }
      async rerender() {
        if (this.isPending() && this.phase !== 'playing')
          this.rerenderEnqueued = !0
        else return this.render()
      }
      async remount() {
        return (await this.teardown(), this.render({ forceRemount: !0 }))
      }
      cancelRender() {
        this.abortController.abort()
      }
      cancelPlayFunction() {
        this.phase === 'playing' &&
          (this.abortController.abort(),
          this.runPhase(this.abortController.signal, 'aborted'))
      }
      async teardown() {
        ;((this.torndown = !0),
          this.cancelRender(),
          this.story && (await this.store.cleanupStory(this.story)))
        for (let t = 0; t < 3; t += 1) {
          if (!this.isPending()) {
            await this.teardownRender()
            return
          }
          await new Promise(r => setTimeout(r, 0))
        }
        ;(window?.location?.reload?.(), await new Promise(() => {}))
      }
    }
    w(Kp, 'StoryRender')
    const es = Kp
    const { fetch: oA } = H
    const aA = './index.json'
    const Xp = class {
      constructor(t, r, n = ut.getChannel(), o = !0) {
        ;((this.importFn = t),
          (this.getProjectAnnotations = r),
          (this.channel = n),
          (this.storyRenders = []),
          (this.storeInitializationPromise = new Promise((a, i) => {
            ;((this.resolveStoreInitializationPromise = a),
              (this.rejectStoreInitializationPromise = i))
          })),
          o && this.initialize())
      }
      get storyStore() {
        return new Proxy(
          {},
          {
            get: w((t, r) => {
              if (this.storyStoreValue)
                return (
                  $r(
                    'Accessing the Story Store is deprecated and will be removed in 9.0'
                  ),
                  this.storyStoreValue[r]
                )
              throw new qd()
            }, 'get'),
          }
        )
      }
      async initialize() {
        this.setupListeners()
        try {
          const t = await this.getProjectAnnotationsOrRenderError()
          ;(await this.runBeforeAllHook(t),
            await this.initializeWithProjectAnnotations(t))
        } catch (t) {
          this.rejectStoreInitializationPromise(t)
        }
      }
      ready() {
        return this.storeInitializationPromise
      }
      setupListeners() {
        ;(this.channel.on(hd, this.onStoryIndexChanged.bind(this)),
          this.channel.on(Fo, this.onUpdateGlobals.bind(this)),
          this.channel.on(Po, this.onUpdateArgs.bind(this)),
          this.channel.on(ad, this.onRequestArgTypesInfo.bind(this)),
          this.channel.on(Oo, this.onResetArgs.bind(this)),
          this.channel.on(To, this.onForceReRender.bind(this)),
          this.channel.on(br, this.onForceRemount.bind(this)),
          this.channel.on(md, this.onStoryHotUpdated.bind(this)))
      }
      async getProjectAnnotationsOrRenderError() {
        try {
          const t = await this.getProjectAnnotations()
          if (((this.renderToCanvas = t.renderToCanvas), !this.renderToCanvas))
            throw new kd()
          return t
        } catch (t) {
          throw (
            this.renderPreviewEntryError('Error reading preview.js:', t),
            t
          )
        }
      }
      async initializeWithProjectAnnotations(t) {
        this.projectAnnotationsBeforeInitialization = t
        try {
          const r = await this.getStoryIndexFromServer()
          return this.initializeWithStoryIndex(r)
        } catch (r) {
          throw (
            this.renderPreviewEntryError('Error loading story index:', r),
            r
          )
        }
      }
      async runBeforeAllHook(t) {
        try {
          ;(await this.beforeAllCleanup?.(),
            (this.beforeAllCleanup = await t.beforeAll?.()))
        } catch (r) {
          throw (this.renderPreviewEntryError('Error in beforeAll hook:', r), r)
        }
      }
      async getStoryIndexFromServer() {
        const t = await oA(aA)
        if (t.status === 200) return t.json()
        throw new Rd({ text: await t.text() })
      }
      initializeWithStoryIndex(t) {
        if (!this.projectAnnotationsBeforeInitialization)
          throw new Error(
            'Cannot call initializeWithStoryIndex until project annotations resolve'
          )
        ;((this.storyStoreValue = new Qv(
          t,
          this.importFn,
          this.projectAnnotationsBeforeInitialization
        )),
          delete this.projectAnnotationsBeforeInitialization,
          this.setInitialGlobals(),
          this.resolveStoreInitializationPromise())
      }
      async setInitialGlobals() {
        this.emitGlobals()
      }
      emitGlobals() {
        if (!this.storyStoreValue) throw new rt({ methodName: 'emitGlobals' })
        const t = {
          globals: this.storyStoreValue.userGlobals.get() || {},
          globalTypes:
            this.storyStoreValue.projectAnnotations.globalTypes || {},
        }
        this.channel.emit(cd, t)
      }
      async onGetProjectAnnotationsChanged({ getProjectAnnotations: t }) {
        ;(delete this.previewEntryError, (this.getProjectAnnotations = t))
        const r = await this.getProjectAnnotationsOrRenderError()
        if ((await this.runBeforeAllHook(r), !this.storyStoreValue)) {
          await this.initializeWithProjectAnnotations(r)
          return
        }
        ;(this.storyStoreValue.setProjectAnnotations(r), this.emitGlobals())
      }
      async onStoryIndexChanged() {
        if (
          (delete this.previewEntryError,
          !(
            !this.storyStoreValue &&
            !this.projectAnnotationsBeforeInitialization
          ))
        )
          try {
            const t = await this.getStoryIndexFromServer()
            if (this.projectAnnotationsBeforeInitialization) {
              this.initializeWithStoryIndex(t)
              return
            }
            await this.onStoriesChanged({ storyIndex: t })
          } catch (t) {
            throw (
              this.renderPreviewEntryError('Error loading story index:', t),
              t
            )
          }
      }
      async onStoriesChanged({ importFn: t, storyIndex: r }) {
        if (!this.storyStoreValue)
          throw new rt({ methodName: 'onStoriesChanged' })
        await this.storyStoreValue.onStoriesChanged({
          importFn: t,
          storyIndex: r,
        })
      }
      async onUpdateGlobals({ globals: t, currentStory: r }) {
        if (
          (this.storyStoreValue || (await this.storeInitializationPromise),
          !this.storyStoreValue)
        )
          throw new rt({ methodName: 'onUpdateGlobals' })
        if ((this.storyStoreValue.userGlobals.update(t), r)) {
          const {
            initialGlobals: n,
            storyGlobals: o,
            userGlobals: a,
            globals: i,
          } = this.storyStoreValue.getStoryContext(r)
          this.channel.emit(Mr, {
            initialGlobals: n,
            userGlobals: a,
            storyGlobals: o,
            globals: i,
          })
        } else {
          const { initialGlobals: n, globals: o } =
            this.storyStoreValue.userGlobals
          this.channel.emit(Mr, {
            initialGlobals: n,
            userGlobals: o,
            storyGlobals: {},
            globals: o,
          })
        }
        await Promise.all(this.storyRenders.map(n => n.rerender()))
      }
      async onUpdateArgs({ storyId: t, updatedArgs: r }) {
        if (!this.storyStoreValue) throw new rt({ methodName: 'onUpdateArgs' })
        ;(this.storyStoreValue.args.update(t, r),
          await Promise.all(
            this.storyRenders
              .filter(n => n.id === t && !n.renderOptions.forceInitialArgs)
              .map(n =>
                n.story && n.story.usesMount ? n.remount() : n.rerender()
              )
          ),
          this.channel.emit(dd, {
            storyId: t,
            args: this.storyStoreValue.args.get(t),
          }))
      }
      async onRequestArgTypesInfo({ id: t, payload: r }) {
        try {
          await this.storeInitializationPromise
          const n = await this.storyStoreValue?.loadStory(r)
          this.channel.emit(Bi, {
            id: t,
            success: !0,
            payload: { argTypes: n?.argTypes || {} },
            error: null,
          })
        } catch (n) {
          this.channel.emit(Bi, { id: t, success: !1, error: n?.message })
        }
      }
      async onResetArgs({ storyId: t, argNames: r }) {
        if (!this.storyStoreValue) throw new rt({ methodName: 'onResetArgs' })
        const n =
          this.storyRenders.find(a => a.id === t)?.story ||
          (await this.storyStoreValue.loadStory({ storyId: t }))
        const o = (
          r || [
            ...new Set([
              ...Object.keys(n.initialArgs),
              ...Object.keys(this.storyStoreValue.args.get(t)),
            ]),
          ]
        ).reduce((a, i) => ((a[i] = n.initialArgs[i]), a), {})
        await this.onUpdateArgs({ storyId: t, updatedArgs: o })
      }
      async onForceReRender() {
        await Promise.all(this.storyRenders.map(t => t.rerender()))
      }
      async onForceRemount({ storyId: t }) {
        await Promise.all(
          this.storyRenders.filter(r => r.id === t).map(r => r.remount())
        )
      }
      async onStoryHotUpdated() {
        await Promise.all(this.storyRenders.map(t => t.cancelPlayFunction()))
      }
      renderStoryToElement(t, r, n, o) {
        if (!this.renderToCanvas || !this.storyStoreValue)
          throw new rt({ methodName: 'renderStoryToElement' })
        const a = new es(
          this.channel,
          this.storyStoreValue,
          this.renderToCanvas,
          n,
          t.id,
          'docs',
          o,
          t
        )
        return (
          a.renderToElement(r),
          this.storyRenders.push(a),
          async () => {
            await this.teardownRender(a)
          }
        )
      }
      async teardownRender(t, { viewModeChanged: r } = {}) {
        ;((this.storyRenders = this.storyRenders.filter(n => n !== t)),
          await t?.teardown?.({ viewModeChanged: r }))
      }
      async loadStory({ storyId: t }) {
        if (!this.storyStoreValue) throw new rt({ methodName: 'loadStory' })
        return this.storyStoreValue.loadStory({ storyId: t })
      }
      getStoryContext(t, { forceInitialArgs: r = !1 } = {}) {
        if (!this.storyStoreValue)
          throw new rt({ methodName: 'getStoryContext' })
        return this.storyStoreValue.getStoryContext(t, { forceInitialArgs: r })
      }
      async extract(t) {
        if (!this.storyStoreValue) throw new rt({ methodName: 'extract' })
        if (this.previewEntryError) throw this.previewEntryError
        return (
          await this.storyStoreValue.cacheAllCSFFiles(),
          this.storyStoreValue.extract(t)
        )
      }
      renderPreviewEntryError(t, r) {
        ;((this.previewEntryError = r),
          Z.error(t),
          Z.error(r),
          this.channel.emit(id, r))
      }
    }
    w(Xp, 'Preview')
    const iA = Xp
    const sA = !1
    const Ui = 'Invariant failed'
    function $o(e, t) {
      if (!e) {
        if (sA) throw new Error(Ui)
        const r = typeof t === 'function' ? t() : t
        const n = r ? ''.concat(Ui, ': ').concat(r) : Ui
        throw new Error(n)
      }
    }
    w($o, 'invariant')
    const Jp = class {
      constructor(t, r, n, o) {
        ;((this.channel = t),
          (this.store = r),
          (this.renderStoryToElement = n),
          (this.storyIdByName = w(a => {
            const i = this.nameToStoryId.get(a)
            if (i) return i
            throw new Error(`No story found with that name: ${a}`)
          }, 'storyIdByName')),
          (this.componentStories = w(
            () => this.componentStoriesValue,
            'componentStories'
          )),
          (this.componentStoriesFromCSFFile = w(
            a => this.store.componentStoriesFromCSFFile({ csfFile: a }),
            'componentStoriesFromCSFFile'
          )),
          (this.storyById = w(a => {
            if (!a) {
              if (!this.primaryStory)
                throw new Error(
                  'No primary story defined for docs entry. Did you forget to use `<Meta>`?'
                )
              return this.primaryStory
            }
            const i = this.storyIdToCSFFile.get(a)
            if (!i)
              throw new Error(
                `Called \`storyById\` for story that was never loaded: ${a}`
              )
            return this.store.storyFromCSFFile({ storyId: a, csfFile: i })
          }, 'storyById')),
          (this.getStoryContext = w(
            a => ({
              ...this.store.getStoryContext(a),
              loaded: {},
              viewMode: 'docs',
            }),
            'getStoryContext'
          )),
          (this.loadStory = w(
            a => this.store.loadStory({ storyId: a }),
            'loadStory'
          )),
          (this.componentStoriesValue = []),
          (this.storyIdToCSFFile = new Map()),
          (this.exportToStory = new Map()),
          (this.exportsToCSFFile = new Map()),
          (this.nameToStoryId = new Map()),
          (this.attachedCSFFiles = new Set()),
          o.forEach((a, i) => {
            this.referenceCSFFile(a)
          }))
      }
      referenceCSFFile(t) {
        ;(this.exportsToCSFFile.set(t.moduleExports, t),
          this.exportsToCSFFile.set(t.moduleExports.default, t),
          this.store.componentStoriesFromCSFFile({ csfFile: t }).forEach(r => {
            const n = t.stories[r.id]
            ;(this.storyIdToCSFFile.set(n.id, t),
              this.exportToStory.set(n.moduleExport, r))
          }))
      }
      attachCSFFile(t) {
        if (!this.exportsToCSFFile.has(t.moduleExports))
          throw new Error(
            'Cannot attach a CSF file that has not been referenced'
          )
        this.attachedCSFFiles.has(t) ||
          (this.attachedCSFFiles.add(t),
          this.store.componentStoriesFromCSFFile({ csfFile: t }).forEach(r => {
            ;(this.nameToStoryId.set(r.name, r.id),
              this.componentStoriesValue.push(r),
              this.primaryStory || (this.primaryStory = r))
          }))
      }
      referenceMeta(t, r) {
        const n = this.resolveModuleExport(t)
        if (n.type !== 'meta')
          throw new Error(
            '<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?'
          )
        r && this.attachCSFFile(n.csfFile)
      }
      get projectAnnotations() {
        const { projectAnnotations: t } = this.store
        if (!t)
          throw new Error(
            "Can't get projectAnnotations from DocsContext before they are initialized"
          )
        return t
      }
      resolveAttachedModuleExportType(t) {
        if (t === 'story') {
          if (!this.primaryStory)
            throw new Error(
              'No primary story attached to this docs file, did you forget to use <Meta of={} />?'
            )
          return { type: 'story', story: this.primaryStory }
        }
        if (this.attachedCSFFiles.size === 0)
          throw new Error(
            'No CSF file attached to this docs file, did you forget to use <Meta of={} />?'
          )
        const r = Array.from(this.attachedCSFFiles)[0]
        if (t === 'meta') return { type: 'meta', csfFile: r }
        const { component: n } = r.meta
        if (!n)
          throw new Error(
            'Attached CSF file does not defined a component, did you forget to export one?'
          )
        return { type: 'component', component: n }
      }
      resolveModuleExport(t) {
        const r = this.exportsToCSFFile.get(t)
        if (r) return { type: 'meta', csfFile: r }
        const n = this.exportToStory.get(Ar(t) ? t.input : t)
        return n
          ? { type: 'story', story: n }
          : { type: 'component', component: t }
      }
      resolveOf(t, r = []) {
        let n
        if (['component', 'meta', 'story'].includes(t)) {
          const o = t
          n = this.resolveAttachedModuleExportType(o)
        } else n = this.resolveModuleExport(t)
        if (r.length && !r.includes(n.type)) {
          const o = n.type === 'component' ? 'component or unknown' : n.type
          throw new Error(wt`Invalid value passed to the 'of' prop. The value was resolved to a '${o}' type but the only types for this block are: ${r.join(', ')}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`)
        }
        switch (n.type) {
          case 'component':
            return { ...n, projectAnnotations: this.projectAnnotations }
          case 'meta':
            return {
              ...n,
              preparedMeta: this.store.preparedMetaFromCSFFile({
                csfFile: n.csfFile,
              }),
            }
          case 'story':
          default:
            return n
        }
      }
    }
    w(Jp, 'DocsContext')
    const Zp = Jp
    const Qp = class {
      constructor(t, r, n, o) {
        ;((this.channel = t),
          (this.store = r),
          (this.entry = n),
          (this.callbacks = o),
          (this.type = 'docs'),
          (this.subtype = 'csf'),
          (this.torndown = !1),
          (this.disableKeyListeners = !1),
          (this.preparing = !1),
          (this.id = n.id),
          (this.renderId = Date.now()))
      }
      isPreparing() {
        return this.preparing
      }
      async prepare() {
        this.preparing = !0
        const { entryExports: t, csfFiles: r = [] } =
          await this.store.loadEntry(this.id)
        if (this.torndown) throw Ko
        const { importPath: n, title: o } = this.entry
        const a = this.store.processCSFFileWithCache(t, n, o)
        const i = Object.keys(a.stories)[0]
        ;((this.story = this.store.storyFromCSFFile({
          storyId: i,
          csfFile: a,
        })),
          (this.csfFiles = [a, ...r]),
          (this.preparing = !1))
      }
      isEqual(t) {
        return !!(this.id === t.id && this.story && this.story === t.story)
      }
      docsContext(t) {
        if (!this.csfFiles)
          throw new Error('Cannot render docs before preparing')
        const r = new Zp(this.channel, this.store, t, this.csfFiles)
        return (this.csfFiles.forEach(n => r.attachCSFFile(n)), r)
      }
      async renderToElement(t, r) {
        if (!this.story || !this.csfFiles)
          throw new Error('Cannot render docs before preparing')
        const n = this.docsContext(r)
        const { docs: o } = this.story.parameters || {}
        if (!o)
          throw new Error(
            'Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed'
          )
        const a = await o.renderer()
        const { render: i } = a
        const s = w(async () => {
          try {
            ;(await i(n, o, t), this.channel.emit(Do, this.id))
          } catch (l) {
            this.callbacks.showException(l)
          }
        }, 'renderDocs')
        return (
          (this.rerender = async () => s()),
          (this.teardownRender = async ({ viewModeChanged: l }) => {
            !l || !t || a.unmount(t)
          }),
          s()
        )
      }
      async teardown({ viewModeChanged: t } = {}) {
        ;(this.teardownRender?.({ viewModeChanged: t }), (this.torndown = !0))
      }
    }
    w(Qp, 'CsfDocsRender')
    const Qd = Qp
    const em = class {
      constructor(t, r, n, o) {
        ;((this.channel = t),
          (this.store = r),
          (this.entry = n),
          (this.callbacks = o),
          (this.type = 'docs'),
          (this.subtype = 'mdx'),
          (this.torndown = !1),
          (this.disableKeyListeners = !1),
          (this.preparing = !1),
          (this.id = n.id),
          (this.renderId = Date.now()))
      }
      isPreparing() {
        return this.preparing
      }
      async prepare() {
        this.preparing = !0
        const { entryExports: t, csfFiles: r = [] } =
          await this.store.loadEntry(this.id)
        if (this.torndown) throw Ko
        ;((this.csfFiles = r), (this.exports = t), (this.preparing = !1))
      }
      isEqual(t) {
        return !!(
          this.id === t.id &&
          this.exports &&
          this.exports === t.exports
        )
      }
      docsContext(t) {
        if (!this.csfFiles)
          throw new Error('Cannot render docs before preparing')
        return new Zp(this.channel, this.store, t, this.csfFiles)
      }
      async renderToElement(t, r) {
        if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
          throw new Error('Cannot render docs before preparing')
        const n = this.docsContext(r)
        const { docs: o } = this.store.projectAnnotations.parameters ?? {}
        if (!o)
          throw new Error(
            'Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed'
          )
        const a = { ...o, page: this.exports.default }
        const i = await o.renderer()
        const { render: s } = i
        const l = w(async () => {
          try {
            ;(await s(n, a, t), this.channel.emit(Do, this.id))
          } catch (u) {
            this.callbacks.showException(u)
          }
        }, 'renderDocs')
        return (
          (this.rerender = async () => l()),
          (this.teardownRender = async ({ viewModeChanged: u } = {}) => {
            !u || !t || (i.unmount(t), (this.torndown = !0))
          }),
          l()
        )
      }
      async teardown({ viewModeChanged: t } = {}) {
        ;(this.teardownRender?.({ viewModeChanged: t }), (this.torndown = !0))
      }
    }
    w(em, 'MdxDocsRender')
    const ep = em
    const lA = globalThis
    function tm(e) {
      const t = (e.composedPath && e.composedPath()[0]) || e.target
      return (
        /input|textarea/i.test(t.tagName) ||
        t.getAttribute('contenteditable') !== null
      )
    }
    w(tm, 'focusInInput')
    const rm = 'attached-mdx'
    const uA = 'unattached-mdx'
    function nm({ tags: e }) {
      return e?.includes(uA) || e?.includes(rm)
    }
    w(nm, 'isMdxEntry')
    function qo(e) {
      return e.type === 'story'
    }
    w(qo, 'isStoryRender')
    function om(e) {
      return e.type === 'docs'
    }
    w(om, 'isDocsRender')
    function am(e) {
      return om(e) && e.subtype === 'csf'
    }
    w(am, 'isCsfDocsRender')
    const im = class extends iA {
      constructor(t, r, n, o) {
        ;(super(t, r, void 0, !1),
          (this.importFn = t),
          (this.getProjectAnnotations = r),
          (this.selectionStore = n),
          (this.view = o),
          this.initialize())
      }
      setupListeners() {
        ;(super.setupListeners(),
          (lA.onkeydown = this.onKeydown.bind(this)),
          this.channel.on(Ro, this.onSetCurrentStory.bind(this)),
          this.channel.on(bd, this.onUpdateQueryParams.bind(this)),
          this.channel.on(ld, this.onPreloadStories.bind(this)))
      }
      async setInitialGlobals() {
        if (!this.storyStoreValue)
          throw new rt({ methodName: 'setInitialGlobals' })
        const { globals: t } = this.selectionStore.selectionSpecifier || {}
        ;(t && this.storyStoreValue.userGlobals.updateFromPersisted(t),
          this.emitGlobals())
      }
      async initializeWithStoryIndex(t) {
        return (
          await super.initializeWithStoryIndex(t),
          this.selectSpecifiedStory()
        )
      }
      async selectSpecifiedStory() {
        if (!this.storyStoreValue)
          throw new rt({ methodName: 'selectSpecifiedStory' })
        if (this.selectionStore.selection) {
          await this.renderSelection()
          return
        }
        if (!this.selectionStore.selectionSpecifier) {
          this.renderMissingStory()
          return
        }
        const { storySpecifier: t, args: r } =
          this.selectionStore.selectionSpecifier
        const n = this.storyStoreValue.storyIndex.entryFromSpecifier(t)
        if (!n) {
          t === '*'
            ? this.renderStoryLoadingException(t, new Pd())
            : this.renderStoryLoadingException(
                t,
                new Ld({ storySpecifier: t.toString() })
              )
          return
        }
        const { id: o, type: a } = n
        ;(this.selectionStore.setSelection({ storyId: o, viewMode: a }),
          this.channel.emit(gd, this.selectionStore.selection),
          this.channel.emit(_i, this.selectionStore.selection),
          await this.renderSelection({ persistedArgs: r }))
      }
      async onGetProjectAnnotationsChanged({ getProjectAnnotations: t }) {
        ;(await super.onGetProjectAnnotationsChanged({
          getProjectAnnotations: t,
        }),
          this.selectionStore.selection && this.renderSelection())
      }
      async onStoriesChanged({ importFn: t, storyIndex: r }) {
        ;(await super.onStoriesChanged({ importFn: t, storyIndex: r }),
          this.selectionStore.selection
            ? await this.renderSelection()
            : await this.selectSpecifiedStory())
      }
      onKeydown(t) {
        if (!this.storyRenders.find(r => r.disableKeyListeners) && !tm(t)) {
          const {
            altKey: r,
            ctrlKey: n,
            metaKey: o,
            shiftKey: a,
            key: i,
            code: s,
            keyCode: l,
          } = t
          this.channel.emit(ud, {
            event: {
              altKey: r,
              ctrlKey: n,
              metaKey: o,
              shiftKey: a,
              key: i,
              code: s,
              keyCode: l,
            },
          })
        }
      }
      async onSetCurrentStory(t) {
        ;(this.selectionStore.setSelection({ viewMode: 'story', ...t }),
          await this.storeInitializationPromise,
          this.channel.emit(_i, this.selectionStore.selection),
          this.renderSelection())
      }
      onUpdateQueryParams(t) {
        this.selectionStore.setQueryParams(t)
      }
      async onUpdateGlobals({ globals: t }) {
        const r =
          (this.currentRender instanceof es && this.currentRender.story) ||
          void 0
        ;(super.onUpdateGlobals({ globals: t, currentStory: r }),
          (this.currentRender instanceof ep ||
            this.currentRender instanceof Qd) &&
            (await this.currentRender.rerender?.()))
      }
      async onUpdateArgs({ storyId: t, updatedArgs: r }) {
        super.onUpdateArgs({ storyId: t, updatedArgs: r })
      }
      async onPreloadStories({ ids: t }) {
        ;(await this.storeInitializationPromise,
          this.storyStoreValue &&
            (await Promise.allSettled(
              t.map(r => this.storyStoreValue?.loadEntry(r))
            )))
      }
      async renderSelection({ persistedArgs: t } = {}) {
        const { renderToCanvas: r } = this
        if (!this.storyStoreValue || !r)
          throw new rt({ methodName: 'renderSelection' })
        const { selection: n } = this.selectionStore
        if (!n)
          throw new Error(
            'Cannot call renderSelection as no selection was made'
          )
        const { storyId: o } = n
        let a
        try {
          a = await this.storyStoreValue.storyIdToEntry(o)
        } catch (p) {
          ;(this.currentRender &&
            (await this.teardownRender(this.currentRender)),
            this.renderStoryLoadingException(o, p))
          return
        }
        const i = this.currentSelection?.storyId !== o
        const s = this.currentRender?.type !== a.type
        ;(a.type === 'story'
          ? this.view.showPreparingStory({ immediate: s })
          : this.view.showPreparingDocs({ immediate: s }),
          this.currentRender?.isPreparing() &&
            (await this.teardownRender(this.currentRender)))
        let l
        a.type === 'story'
          ? (l = new es(
              this.channel,
              this.storyStoreValue,
              r,
              this.mainStoryCallbacks(o),
              o,
              'story'
            ))
          : nm(a)
            ? (l = new ep(
                this.channel,
                this.storyStoreValue,
                a,
                this.mainStoryCallbacks(o)
              ))
            : (l = new Qd(
                this.channel,
                this.storyStoreValue,
                a,
                this.mainStoryCallbacks(o)
              ))
        const u = this.currentSelection
        this.currentSelection = n
        const d = this.currentRender
        this.currentRender = l
        try {
          await l.prepare()
        } catch (p) {
          ;(d && (await this.teardownRender(d)),
            p !== Ko && this.renderStoryLoadingException(o, p))
          return
        }
        const m = !i && d && !l.isEqual(d)
        if (
          (t &&
            qo(l) &&
            ($o(!!l.story),
            this.storyStoreValue.args.updateFromPersisted(l.story, t)),
          d && !d.torndown && !i && !m && !s)
        ) {
          ;((this.currentRender = d),
            this.channel.emit(yd, o),
            this.view.showMain())
          return
        }
        if (
          (d && (await this.teardownRender(d, { viewModeChanged: s })),
          u && (i || s) && this.channel.emit(Er, o),
          qo(l))
        ) {
          $o(!!l.story)
          const {
            parameters: p,
            initialArgs: f,
            argTypes: g,
            unmappedArgs: y,
            initialGlobals: E,
            userGlobals: b,
            storyGlobals: x,
            globals: S,
          } = this.storyStoreValue.getStoryContext(l.story)
          ;(this.channel.emit(fd, {
            id: o,
            parameters: p,
            initialArgs: f,
            argTypes: g,
            args: y,
          }),
            this.channel.emit(Mr, {
              userGlobals: b,
              storyGlobals: x,
              globals: S,
              initialGlobals: E,
            }))
        } else {
          let { parameters: p } = this.storyStoreValue.projectAnnotations
          const { initialGlobals: f, globals: g } =
            this.storyStoreValue.userGlobals
          if (
            (this.channel.emit(Mr, {
              globals: g,
              initialGlobals: f,
              storyGlobals: {},
              userGlobals: g,
            }),
            am(l) || l.entry.tags?.includes(rm))
          ) {
            if (!l.csfFiles) throw new _d({ storyId: o })
            ;({ parameters: p } = this.storyStoreValue.preparedMetaFromCSFFile({
              csfFile: l.csfFiles[0],
            }))
          }
          this.channel.emit(sd, { id: o, parameters: p })
        }
        qo(l)
          ? ($o(!!l.story),
            this.storyRenders.push(l),
            this.currentRender.renderToElement(
              this.view.prepareForStory(l.story)
            ))
          : this.currentRender.renderToElement(
              this.view.prepareForDocs(),
              this.renderStoryToElement.bind(this)
            )
      }
      async teardownRender(t, { viewModeChanged: r = !1 } = {}) {
        ;((this.storyRenders = this.storyRenders.filter(n => n !== t)),
          await t?.teardown?.({ viewModeChanged: r }))
      }
      mainStoryCallbacks(t) {
        return {
          showStoryDuringRender: w(
            () => this.view.showStoryDuringRender(),
            'showStoryDuringRender'
          ),
          showMain: w(() => this.view.showMain(), 'showMain'),
          showError: w(r => this.renderError(t, r), 'showError'),
          showException: w(r => this.renderException(t, r), 'showException'),
        }
      }
      renderPreviewEntryError(t, r) {
        ;(super.renderPreviewEntryError(t, r), this.view.showErrorDisplay(r))
      }
      renderMissingStory() {
        ;(this.view.showNoPreview(), this.channel.emit(Ni))
      }
      renderStoryLoadingException(t, r) {
        ;(Z.error(r), this.view.showErrorDisplay(r), this.channel.emit(Ni, t))
      }
      renderException(t, r) {
        const { name: n = 'Error', message: o = String(r), stack: a } = r
        const i = this.currentRender?.renderId
        ;(this.channel.emit(Bo, { name: n, message: o, stack: a }),
          this.channel.emit(gt, {
            newPhase: 'errored',
            renderId: i,
            storyId: t,
          }),
          this.view.showErrorDisplay(r),
          Z.error(`Error rendering story '${t}':`),
          Z.error(r))
      }
      renderError(t, { title: r, description: n }) {
        const o = this.currentRender?.renderId
        ;(this.channel.emit(pd, { title: r, description: n }),
          this.channel.emit(gt, {
            newPhase: 'errored',
            renderId: o,
            storyId: t,
          }),
          this.view.showErrorDisplay({ message: r, stack: n }),
          Z.error(`Error rendering story ${r}: ${n}`))
      }
    }
    w(im, 'PreviewWithSelection')
    const cA = im
    const ts = Jr(is(), 1)
    const dA = Jr(is(), 1)
    const tp = /^[a-zA-Z0-9 _-]*$/
    const sm = /^-?[0-9]+(\.[0-9]+)?$/
    const pA = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i
    const lm =
      /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i
    var rs = w(
      (e = '', t) =>
        e === null || e === '' || !tp.test(e)
          ? !1
          : t == null ||
              t instanceof Date ||
              typeof t === 'number' ||
              typeof t === 'boolean'
            ? !0
            : typeof t === 'string'
              ? tp.test(t) || sm.test(t) || pA.test(t) || lm.test(t)
              : Array.isArray(t)
                ? t.every(r => rs(e, r))
                : xt(t)
                  ? Object.entries(t).every(([r, n]) => rs(r, n))
                  : !1,
      'validateArgs'
    )
    const mA = {
      delimiter: ';',
      nesting: !0,
      arrayRepeat: !0,
      arrayRepeatSyntax: 'bracket',
      nestingSyntax: 'js',
      valueDeserializer(e) {
        if (e.startsWith('!')) {
          if (e === '!undefined') return
          if (e === '!null') return null
          if (e === '!true') return !0
          if (e === '!false') return !1
          if (e.startsWith('!date(') && e.endsWith(')'))
            return new Date(e.replaceAll(' ', '+').slice(6, -1))
          if (e.startsWith('!hex(') && e.endsWith(')'))
            return `#${e.slice(5, -1)}`
          const t = e.slice(1).match(lm)
          if (t)
            return e.startsWith('!rgba') || e.startsWith('!RGBA')
              ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]}, ${t[5]})`
              : e.startsWith('!hsla') || e.startsWith('!HSLA')
                ? `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%, ${t[5]})`
                : e.startsWith('!rgb') || e.startsWith('!RGB')
                  ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]})`
                  : `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%)`
        }
        return sm.test(e) ? Number(e) : e
      },
    }
    const rp = w(e => {
      const t = e.split(';').map(r => r.replace('=', '~').replace(':', '='))
      return Object.entries((0, dA.parse)(t.join(';'), mA)).reduce(
        (r, [n, o]) =>
          rs(n, o)
            ? Object.assign(r, { [n]: o })
            : (yt.warn(wt`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url
    `),
              r),
        {}
      )
    }, 'parseArgsParam')
    const { history: um, document: or } = H
    function cm(e) {
      const t = (e || '').match(/^\/story\/(.+)/)
      if (!t) throw new Error(`Invalid path '${e}',  must start with '/story/'`)
      return t[1]
    }
    w(cm, 'pathToId')
    const dm = w(({ selection: e, extraParams: t }) => {
      const r = or?.location.search.slice(1)
      const {
        path: n,
        selectedKind: o,
        selectedStory: a,
        ...i
      } = (0, ts.parse)(r)
      return `?${(0, ts.stringify)({ ...i, ...t, ...(e && { id: e.storyId, viewMode: e.viewMode }) })}`
    }, 'getQueryString')
    const hA = w(e => {
      if (!e) return
      const t = dm({ selection: e })
      const { hash: r = '' } = or.location
      ;((or.title = e.storyId),
        um.replaceState({}, '', `${or.location.pathname}${t}${r}`))
    }, 'setPath')
    const fA = w(
      e => e != null && typeof e === 'object' && Array.isArray(e) === !1,
      'isObject'
    )
    var _n = w(e => {
      if (e !== void 0) {
        if (typeof e === 'string') return e
        if (Array.isArray(e)) return _n(e[0])
        if (fA(e)) return _n(Object.values(e).filter(Boolean))
      }
    }, 'getFirstString')
    const gA = w(() => {
      if (typeof or < 'u') {
        const e = or.location.search.slice(1)
        const t = (0, ts.parse)(e)
        const r = typeof t.args === 'string' ? rp(t.args) : void 0
        const n = typeof t.globals === 'string' ? rp(t.globals) : void 0
        let o = _n(t.viewMode)
        ;(typeof o !== 'string' || !o.match(/docs|story/)) && (o = 'story')
        const a = _n(t.path)
        const i = a ? cm(a) : _n(t.id)
        if (i) return { storySpecifier: i, args: r, globals: n, viewMode: o }
      }
      return null
    }, 'getSelectionSpecifierFromPath')
    const pm = class {
      constructor() {
        this.selectionSpecifier = gA()
      }
      setSelection(t) {
        ;((this.selection = t), hA(this.selection))
      }
      setQueryParams(t) {
        const r = dm({ extraParams: t })
        const { hash: n = '' } = or.location
        um.replaceState({}, '', `${or.location.pathname}${r}${n}`)
      }
    }
    w(pm, 'UrlStore')
    const yA = pm
    const bA = Jr(WE(), 1)
    const EA = Jr(is(), 1)
    const { document: qe } = H
    const np = 100
    var mm = (e => (
      (e.MAIN = 'MAIN'),
      (e.NOPREVIEW = 'NOPREVIEW'),
      (e.PREPARING_STORY = 'PREPARING_STORY'),
      (e.PREPARING_DOCS = 'PREPARING_DOCS'),
      (e.ERROR = 'ERROR'),
      e
    ))(mm || {})
    const Hi = {
      PREPARING_STORY: 'sb-show-preparing-story',
      PREPARING_DOCS: 'sb-show-preparing-docs',
      MAIN: 'sb-show-main',
      NOPREVIEW: 'sb-show-nopreview',
      ERROR: 'sb-show-errordisplay',
    }
    const Vi = {
      centered: 'sb-main-centered',
      fullscreen: 'sb-main-fullscreen',
      padded: 'sb-main-padded',
    }
    const op = new bA.default({ escapeXML: !0 })
    const hm = class {
      constructor() {
        if (((this.testing = !1), typeof qe < 'u')) {
          const { __SPECIAL_TEST_PARAMETER__: t } = (0, EA.parse)(
            qe.location.search.slice(1)
          )
          switch (t) {
            case 'preparing-story': {
              ;(this.showPreparingStory(), (this.testing = !0))
              break
            }
            case 'preparing-docs': {
              ;(this.showPreparingDocs(), (this.testing = !0))
              break
            }
            default:
          }
        }
      }
      prepareForStory(t) {
        return (
          this.showStory(),
          this.applyLayout(t.parameters.layout),
          (qe.documentElement.scrollTop = 0),
          (qe.documentElement.scrollLeft = 0),
          this.storyRoot()
        )
      }
      storyRoot() {
        return qe.getElementById('storybook-root')
      }
      prepareForDocs() {
        return (
          this.showMain(),
          this.showDocs(),
          this.applyLayout('fullscreen'),
          (qe.documentElement.scrollTop = 0),
          (qe.documentElement.scrollLeft = 0),
          this.docsRoot()
        )
      }
      docsRoot() {
        return qe.getElementById('storybook-docs')
      }
      applyLayout(t = 'padded') {
        if (t === 'none') {
          ;(qe.body.classList.remove(this.currentLayoutClass),
            (this.currentLayoutClass = null))
          return
        }
        this.checkIfLayoutExists(t)
        const r = Vi[t]
        ;(qe.body.classList.remove(this.currentLayoutClass),
          qe.body.classList.add(r),
          (this.currentLayoutClass = r))
      }
      checkIfLayoutExists(t) {
        Vi[t] ||
          Z.warn(wt`
          The desired layout: ${t} is not a valid option.
          The possible options are: ${Object.keys(Vi).join(', ')}, none.
        `)
      }

      showMode(t) {
        ;(clearTimeout(this.preparingTimeout),
          Object.keys(mm).forEach(r => {
            r === t
              ? qe.body.classList.add(Hi[r])
              : qe.body.classList.remove(Hi[r])
          }))
      }
      showErrorDisplay({ message: t = '', stack: r = '' }) {
        let n = t
        let o = r
        const a = t.split(`
`)
        ;(a.length > 1 &&
          (([n] = a),
          (o = a
            .slice(1)
            .join(
              `
`
            )
            .replace(/^\n/, ''))),
          (qe.getElementById('error-message').innerHTML = op.toHtml(n)),
          (qe.getElementById('error-stack').innerHTML = op.toHtml(o)),
          this.showMode('ERROR'))
      }

      showNoPreview() {
        this.testing ||
          (this.showMode('NOPREVIEW'),
          this.storyRoot()?.setAttribute('hidden', 'true'),
          this.docsRoot()?.setAttribute('hidden', 'true'))
      }
      showPreparingStory({ immediate: t = !1 } = {}) {
        ;(clearTimeout(this.preparingTimeout),
          t
            ? this.showMode('PREPARING_STORY')
            : (this.preparingTimeout = setTimeout(
                () => this.showMode('PREPARING_STORY'),
                np
              )))
      }
      showPreparingDocs({ immediate: t = !1 } = {}) {
        ;(clearTimeout(this.preparingTimeout),
          t
            ? this.showMode('PREPARING_DOCS')
            : (this.preparingTimeout = setTimeout(
                () => this.showMode('PREPARING_DOCS'),
                np
              )))
      }
      showMain() {
        this.showMode('MAIN')
      }
      showDocs() {
        ;(this.storyRoot().setAttribute('hidden', 'true'),
          this.docsRoot().removeAttribute('hidden'))
      }
      showStory() {
        ;(this.docsRoot().setAttribute('hidden', 'true'),
          this.storyRoot().removeAttribute('hidden'))
      }
      showStoryDuringRender() {
        qe.body.classList.add(Hi.MAIN)
      }
    }
    w(hm, 'WebView')
    const vA = hm
    const AA = class extends cA {
      constructor(t, r) {
        ;(super(t, r, new yA(), new vA()),
          (this.importFn = t),
          (this.getProjectAnnotations = r),
          (H.__STORYBOOK_PREVIEW__ = this))
      }
    }
    w(AA, 'PreviewWeb')
    const { document: vr } = H
    const xA = [
      'application/javascript',
      'application/ecmascript',
      'application/x-ecmascript',
      'application/x-javascript',
      'text/ecmascript',
      'text/javascript',
      'text/javascript1.0',
      'text/javascript1.1',
      'text/javascript1.2',
      'text/javascript1.3',
      'text/javascript1.4',
      'text/javascript1.5',
      'text/jscript',
      'text/livescript',
      'text/x-ecmascript',
      'text/x-javascript',
      'module',
    ]
    const wA = 'script'
    const ap = 'scripts-root'
    function ns() {
      const e = vr.createEvent('Event')
      ;(e.initEvent('DOMContentLoaded', !0, !0), vr.dispatchEvent(e))
    }
    w(ns, 'simulateDOMContentLoaded')
    function fm(e, t, r) {
      const n = vr.createElement('script')
      ;((n.type = e.type === 'module' ? 'module' : 'text/javascript'),
        e.src
          ? ((n.onload = t), (n.onerror = t), (n.src = e.src))
          : (n.textContent = e.innerText),
        r ? r.appendChild(n) : vr.head.appendChild(n),
        e.parentNode.removeChild(e),
        e.src || t())
    }
    w(fm, 'insertScript')
    function Es(e, t, r = 0) {
      e[r](() => {
        ;(r++, r === e.length ? t() : Es(e, t, r))
      })
    }
    w(Es, 'insertScriptsSequentially')
    function SA(e) {
      let t = vr.getElementById(ap)
      t
        ? (t.innerHTML = '')
        : ((t = vr.createElement('div')), (t.id = ap), vr.body.appendChild(t))
      const r = Array.from(e.querySelectorAll(wA))
      if (r.length) {
        const n = []
        ;(r.forEach(o => {
          const a = o.getAttribute('type')
          ;(!a || xA.includes(a)) && n.push(i => fm(o, i, t))
        }),
          n.length && Es(n, ns, void 0))
      } else ns()
    }
    w(SA, 'simulatePageLoad')
    const gm = 'storybook/docs'
    const cP = `${gm}/panel`
    const CA = `${gm}/snippet-rendered`
    async function DA(e, t) {
      const r = t.parameters?.docs?.source?.transform
      const { id: n, unmappedArgs: o } = t
      const a = r && e ? r?.(e, t) : e
      const i = a ? await a : void 0
      ut.getChannel().emit(CA, { id: n, source: i, args: o })
    }
    w(DA, 'emitTransformCode')
    te()
    re()
    ne()
    const gP = __STORYBOOK_TEST__
    const {
      buildQueries: yP,
      clearAllMocks: ym,
      configure: bP,
      createEvent: EP,
      expect: vP,
      findAllByAltText: AP,
      findAllByDisplayValue: xP,
      findAllByLabelText: wP,
      findAllByPlaceholderText: SP,
      findAllByRole: CP,
      findAllByTestId: DP,
      findAllByText: TP,
      findAllByTitle: kP,
      findByAltText: OP,
      findByDisplayValue: IP,
      findByLabelText: RP,
      findByPlaceholderText: BP,
      findByRole: _P,
      findByTestId: FP,
      findByText: PP,
      findByTitle: NP,
      fireEvent: LP,
      fn: bm,
      getAllByAltText: jP,
      getAllByDisplayValue: MP,
      getAllByLabelText: $P,
      getAllByPlaceholderText: qP,
      getAllByRole: UP,
      getAllByTestId: HP,
      getAllByText: VP,
      getAllByTitle: zP,
      getByAltText: GP,
      getByDisplayValue: WP,
      getByLabelText: YP,
      getByPlaceholderText: KP,
      getByRole: XP,
      getByTestId: JP,
      getByText: ZP,
      getByTitle: QP,
      getConfig: eN,
      getDefaultNormalizer: tN,
      getElementError: rN,
      getNodeText: nN,
      getQueriesForElement: oN,
      getRoles: aN,
      getSuggestedQuery: iN,
      isInaccessible: sN,
      isMockFunction: Em,
      logDOM: lN,
      logRoles: uN,
      mocked: cN,
      mocks: dN,
      onMockCall: vm,
      prettyDOM: pN,
      prettyFormat: mN,
      queries: hN,
      queryAllByAltText: fN,
      queryAllByAttribute: gN,
      queryAllByDisplayValue: yN,
      queryAllByLabelText: bN,
      queryAllByPlaceholderText: EN,
      queryAllByRole: vN,
      queryAllByTestId: AN,
      queryAllByText: xN,
      queryAllByTitle: wN,
      queryByAltText: SN,
      queryByAttribute: CN,
      queryByDisplayValue: DN,
      queryByLabelText: TN,
      queryByPlaceholderText: kN,
      queryByRole: ON,
      queryByTestId: IN,
      queryByText: RN,
      queryByTitle: BN,
      queryHelpers: _N,
      resetAllMocks: Am,
      restoreAllMocks: xm,
      sb: FN,
      screen: PN,
      spyOn: NN,
      uninstrumentedUserEvent: wm,
      userEvent: LN,
      waitFor: jN,
      waitForElementToBeRemoved: MN,
      within: Sm,
    } = __STORYBOOK_TEST__
    te()
    re()
    ne()
    const TA = Object.defineProperty
    const C = (e, t) => TA(e, 'name', { value: t, configurable: !0 })
    const kA = {
      reset: [0, 0],
      bold: [1, 22, '\x1B[22m\x1B[1m'],
      dim: [2, 22, '\x1B[22m\x1B[2m'],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      blackBright: [90, 39],
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39],
      bgBlackBright: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49],
    }
    const OA = Object.entries(kA)
    function la(e) {
      return String(e)
    }
    C(la, 'a')
    la.open = ''
    la.close = ''
    function Ym(e = !1) {
      const t = typeof process < 'u' ? process : void 0
      const r = t?.env || {}
      const n = t?.argv || []
      return (
        (!('NO_COLOR' in r || n.includes('--no-color')) &&
          ('FORCE_COLOR' in r ||
            n.includes('--color') ||
            t?.platform === 'win32' ||
            (e && r.TERM !== 'dumb') ||
            'CI' in r)) ||
        (typeof window < 'u' && !!window.chrome)
      )
    }
    C(Ym, 'C')
    function Km(e = !1) {
      const t = Ym(e)
      const r = C((i, s, l, u) => {
        let d = ''
        let m = 0
        do
          ((d += i.substring(m, u) + l),
            (m = u + s.length),
            (u = i.indexOf(s, m)))
        while (~u)
        return d + i.substring(m)
      }, 'i')
      const n = C((i, s, l = i) => {
        const u = C(d => {
          const m = String(d)
          const p = m.indexOf(s, i.length)
          return ~p ? i + r(m, s, l, p) + s : i + m + s
        }, 'o')
        return ((u.open = i), (u.close = s), u)
      }, 'g')
      const o = { isColorSupported: t }
      const a = C(i => `\x1B[${i}m`, 'd')
      for (const [i, s] of OA) o[i] = t ? n(a(s[0]), a(s[1]), s[2]) : la
      return o
    }
    C(Km, 'p')
    const Ut = Km()
    function Xs(e, t) {
      return (
        t.forEach(function (r) {
          r &&
            typeof r !== 'string' &&
            !Array.isArray(r) &&
            Object.keys(r).forEach(function (n) {
              if (n !== 'default' && !(n in e)) {
                const o = Object.getOwnPropertyDescriptor(r, n)
                Object.defineProperty(
                  e,
                  n,
                  o.get
                    ? o
                    : {
                        enumerable: !0,
                        get: C(function () {
                          return r[n]
                        }, 'get'),
                      }
                )
              }
            })
        }),
        Object.freeze(e)
      )
    }
    C(Xs, '_mergeNamespaces')
    function Xm(e, t) {
      const r = Object.keys(e)
      const n = t === null ? r : r.sort(t)
      if (Object.getOwnPropertySymbols)
        for (const o of Object.getOwnPropertySymbols(e))
          Object.getOwnPropertyDescriptor(e, o).enumerable && n.push(o)
      return n
    }
    C(Xm, 'getKeysOfEnumerableProperties')
    function sn(e, t, r, n, o, a, i = ': ') {
      let s = ''
      let l = 0
      let u = e.next()
      if (!u.done) {
        s += t.spacingOuter
        const d = r + t.indent
        for (; !u.done; ) {
          if (((s += d), l++ === t.maxWidth)) {
            s += '\u2026'
            break
          }
          const m = a(u.value[0], t, d, n, o)
          const p = a(u.value[1], t, d, n, o)
          ;((s += m + i + p),
            (u = e.next()),
            u.done ? t.min || (s += ',') : (s += `,${t.spacingInner}`))
        }
        s += t.spacingOuter + r
      }
      return s
    }
    C(sn, 'printIteratorEntries')
    function ua(e, t, r, n, o, a) {
      let i = ''
      let s = 0
      let l = e.next()
      if (!l.done) {
        i += t.spacingOuter
        const u = r + t.indent
        for (; !l.done; ) {
          if (((i += u), s++ === t.maxWidth)) {
            i += '\u2026'
            break
          }
          ;((i += a(l.value, t, u, n, o)),
            (l = e.next()),
            l.done ? t.min || (i += ',') : (i += `,${t.spacingInner}`))
        }
        i += t.spacingOuter + r
      }
      return i
    }
    C(ua, 'printIteratorValues')
    function qn(e, t, r, n, o, a) {
      let i = ''
      e = e instanceof ArrayBuffer ? new DataView(e) : e
      const s = C(u => u instanceof DataView, 'isDataView')
      const l = s(e) ? e.byteLength : e.length
      if (l > 0) {
        i += t.spacingOuter
        const u = r + t.indent
        for (let d = 0; d < l; d++) {
          if (((i += u), d === t.maxWidth)) {
            i += '\u2026'
            break
          }
          ;((s(e) || d in e) &&
            (i += a(s(e) ? e.getInt8(d) : e[d], t, u, n, o)),
            d < l - 1 ? (i += `,${t.spacingInner}`) : t.min || (i += ','))
        }
        i += t.spacingOuter + r
      }
      return i
    }
    C(qn, 'printListItems')
    function ca(e, t, r, n, o, a) {
      let i = ''
      const s = Xm(e, t.compareKeys)
      if (s.length > 0) {
        i += t.spacingOuter
        const l = r + t.indent
        for (let u = 0; u < s.length; u++) {
          const d = s[u]
          const m = a(d, t, l, n, o)
          const p = a(e[d], t, l, n, o)
          ;((i += `${l + m}: ${p}`),
            u < s.length - 1
              ? (i += `,${t.spacingInner}`)
              : t.min || (i += ','))
        }
        i += t.spacingOuter + r
      }
      return i
    }
    C(ca, 'printObjectProperties')
    const IA =
      typeof Symbol === 'function' && Symbol.for
        ? Symbol.for('jest.asymmetricMatcher')
        : 1267621
    const vs = ' '
    const RA = C((e, t, r, n, o, a) => {
      const i = e.toString()
      if (i === 'ArrayContaining' || i === 'ArrayNotContaining')
        return ++n > t.maxDepth
          ? `[${i}]`
          : `${i + vs}[${qn(e.sample, t, r, n, o, a)}]`
      if (i === 'ObjectContaining' || i === 'ObjectNotContaining')
        return ++n > t.maxDepth
          ? `[${i}]`
          : `${i + vs}{${ca(e.sample, t, r, n, o, a)}}`
      if (
        i === 'StringMatching' ||
        i === 'StringNotMatching' ||
        i === 'StringContaining' ||
        i === 'StringNotContaining'
      )
        return i + vs + a(e.sample, t, r, n, o)
      if (typeof e.toAsymmetricMatcher !== 'function')
        throw new TypeError(
          `Asymmetric matcher ${e.constructor.name} does not implement toAsymmetricMatcher()`
        )
      return e.toAsymmetricMatcher()
    }, 'serialize$5')
    const BA = C(e => e && e.$$typeof === IA, 'test$5')
    const _A = { serialize: RA, test: BA }
    const FA = ' '
    const Jm = new Set(['DOMStringMap', 'NamedNodeMap'])
    const PA = /^(?:HTML\w*Collection|NodeList)$/
    function Zm(e) {
      return Jm.has(e) || PA.test(e)
    }
    C(Zm, 'testName')
    const NA = C(
      e => e && e.constructor && !!e.constructor.name && Zm(e.constructor.name),
      'test$4'
    )
    function Qm(e) {
      return e.constructor.name === 'NamedNodeMap'
    }
    C(Qm, 'isNamedNodeMap')
    const LA = C((e, t, r, n, o, a) => {
      const i = e.constructor.name
      return ++n > t.maxDepth
        ? `[${i}]`
        : (t.min ? '' : i + FA) +
            (Jm.has(i)
              ? `{${ca(Qm(e) ? [...e].reduce((s, l) => ((s[l.name] = l.value), s), {}) : { ...e }, t, r, n, o, a)}}`
              : `[${qn([...e], t, r, n, o, a)}]`)
    }, 'serialize$4')
    const jA = { serialize: LA, test: NA }
    function Js(e) {
      return e.replaceAll('<', '&lt;').replaceAll('>', '&gt;')
    }
    C(Js, 'escapeHTML')
    function da(e, t, r, n, o, a, i) {
      const s = n + r.indent
      const l = r.colors
      return e
        .map(u => {
          const d = t[u]
          let m = i(d, r, s, o, a)
          return (
            typeof d !== 'string' &&
              (m.includes(`
`) && (m = r.spacingOuter + s + m + r.spacingOuter + n),
              (m = `{${m}}`)),
            `${r.spacingInner + n + l.prop.open + u + l.prop.close}=${l.value.open}${m}${l.value.close}`
          )
        })
        .join('')
    }
    C(da, 'printProps')
    function pa(e, t, r, n, o, a) {
      return e
        .map(
          i =>
            t.spacingOuter +
            r +
            (typeof i === 'string' ? Zs(i, t) : a(i, t, r, n, o))
        )
        .join('')
    }
    C(pa, 'printChildren')
    function Zs(e, t) {
      const r = t.colors.content
      return r.open + Js(e) + r.close
    }
    C(Zs, 'printText')
    function eh(e, t) {
      const r = t.colors.comment
      return `${r.open}<!--${Js(e)}-->${r.close}`
    }
    C(eh, 'printComment')
    function ma(e, t, r, n, o) {
      const a = n.colors.tag
      return `${a.open}<${e}${t && a.close + t + n.spacingOuter + o + a.open}${r ? `>${a.close}${r}${n.spacingOuter}${o}${a.open}</${e}` : `${t && !n.min ? '' : ' '}/`}>${a.close}`
    }
    C(ma, 'printElement')
    function ha(e, t) {
      const r = t.colors.tag
      return `${r.open}<${e}${r.close} \u2026${r.open} />${r.close}`
    }
    C(ha, 'printElementAsLeaf')
    const MA = 1
    const th = 3
    const rh = 8
    const nh = 11
    const $A = /^(?:(?:HTML|SVG)\w*)?Element$/
    function oh(e) {
      try {
        return typeof e.hasAttribute === 'function' && e.hasAttribute('is')
      } catch {
        return !1
      }
    }
    C(oh, 'testHasAttribute')
    function ah(e) {
      const t = e.constructor.name
      const { nodeType: r, tagName: n } = e
      const o = (typeof n === 'string' && n.includes('-')) || oh(e)
      return (
        (r === MA && ($A.test(t) || o)) ||
        (r === th && t === 'Text') ||
        (r === rh && t === 'Comment') ||
        (r === nh && t === 'DocumentFragment')
      )
    }
    C(ah, 'testNode')
    const qA = C(e => {
      let t
      return (
        (e == null || (t = e.constructor) === null || t === void 0
          ? void 0
          : t.name) && ah(e)
      )
    }, 'test$3')
    function ih(e) {
      return e.nodeType === th
    }
    C(ih, 'nodeIsText')
    function sh(e) {
      return e.nodeType === rh
    }
    C(sh, 'nodeIsComment')
    function Qo(e) {
      return e.nodeType === nh
    }
    C(Qo, 'nodeIsFragment')
    const UA = C((e, t, r, n, o, a) => {
      if (ih(e)) return Zs(e.data, t)
      if (sh(e)) return eh(e.data, t)
      const i = Qo(e) ? 'DocumentFragment' : e.tagName.toLowerCase()
      return ++n > t.maxDepth
        ? ha(i, t)
        : ma(
            i,
            da(
              Qo(e) ? [] : Array.from(e.attributes, s => s.name).sort(),
              Qo(e)
                ? {}
                : [...e.attributes].reduce(
                    (s, l) => ((s[l.name] = l.value), s),
                    {}
                  ),
              t,
              r + t.indent,
              n,
              o,
              a
            ),
            pa(
              Array.prototype.slice.call(e.childNodes || e.children),
              t,
              r + t.indent,
              n,
              o,
              a
            ),
            t,
            r
          )
    }, 'serialize$3')
    const HA = { serialize: UA, test: qA }
    const VA = '@@__IMMUTABLE_ITERABLE__@@'
    const zA = '@@__IMMUTABLE_LIST__@@'
    const GA = '@@__IMMUTABLE_KEYED__@@'
    const WA = '@@__IMMUTABLE_MAP__@@'
    const Cm = '@@__IMMUTABLE_ORDERED__@@'
    const YA = '@@__IMMUTABLE_RECORD__@@'
    const KA = '@@__IMMUTABLE_SEQ__@@'
    const XA = '@@__IMMUTABLE_SET__@@'
    const JA = '@@__IMMUTABLE_STACK__@@'
    const rn = C(e => `Immutable.${e}`, 'getImmutableName')
    const fa = C(e => `[${e}]`, 'printAsLeaf')
    const Un = ' '
    const Dm = '\u2026'
    function lh(e, t, r, n, o, a, i) {
      return ++n > t.maxDepth
        ? fa(rn(i))
        : `${rn(i) + Un}{${sn(e.entries(), t, r, n, o, a)}}`
    }
    C(lh, 'printImmutableEntries')
    function uh(e) {
      let t = 0
      return {
        next() {
          if (t < e._keys.length) {
            const r = e._keys[t++]
            return { done: !1, value: [r, e.get(r)] }
          }
          return { done: !0, value: void 0 }
        },
      }
    }
    C(uh, 'getRecordEntries')
    function ch(e, t, r, n, o, a) {
      const i = rn(e._name || 'Record')
      return ++n > t.maxDepth ? fa(i) : `${i + Un}{${sn(uh(e), t, r, n, o, a)}}`
    }
    C(ch, 'printImmutableRecord')
    function dh(e, t, r, n, o, a) {
      const i = rn('Seq')
      return ++n > t.maxDepth
        ? fa(i)
        : e[GA]
          ? `${i + Un}{${e._iter || e._object ? sn(e.entries(), t, r, n, o, a) : Dm}}`
          : `${i + Un}[${e._iter || e._array || e._collection || e._iterable ? ua(e.values(), t, r, n, o, a) : Dm}]`
    }
    C(dh, 'printImmutableSeq')
    function ea(e, t, r, n, o, a, i) {
      return ++n > t.maxDepth
        ? fa(rn(i))
        : `${rn(i) + Un}[${ua(e.values(), t, r, n, o, a)}]`
    }
    C(ea, 'printImmutableValues')
    const ZA = C(
      (e, t, r, n, o, a) =>
        e[WA]
          ? lh(e, t, r, n, o, a, e[Cm] ? 'OrderedMap' : 'Map')
          : e[zA]
            ? ea(e, t, r, n, o, a, 'List')
            : e[XA]
              ? ea(e, t, r, n, o, a, e[Cm] ? 'OrderedSet' : 'Set')
              : e[JA]
                ? ea(e, t, r, n, o, a, 'Stack')
                : e[KA]
                  ? dh(e, t, r, n, o, a)
                  : ch(e, t, r, n, o, a),
      'serialize$2'
    )
    const QA = C(e => e && (e[VA] === !0 || e[YA] === !0), 'test$2')
    const ex = { serialize: ZA, test: QA }
    function Qs(e) {
      return e &&
        e.__esModule &&
        Object.prototype.hasOwnProperty.call(e, 'default')
        ? e.default
        : e
    }
    C(Qs, 'getDefaultExportFromCjs')
    const Tm = { exports: {} }
    const he = {}
    let km
    function ph() {
      return (
        km ||
          ((km = 1),
          (function () {
            function e(y) {
              if (typeof y === 'object' && y !== null) {
                const E = y.$$typeof
                switch (E) {
                  case t:
                    switch (((y = y.type), y)) {
                      case n:
                      case a:
                      case o:
                      case u:
                      case d:
                      case f:
                        return y
                      default:
                        switch (((y = y && y.$$typeof), y)) {
                          case s:
                          case l:
                          case p:
                          case m:
                            return y
                          case i:
                            return y
                          default:
                            return E
                        }
                    }
                  case r:
                    return E
                }
              }
            }
            C(e, 'typeOf')
            var t = Symbol.for('react.transitional.element')
            var r = Symbol.for('react.portal')
            var n = Symbol.for('react.fragment')
            var o = Symbol.for('react.strict_mode')
            var a = Symbol.for('react.profiler')
            var i = Symbol.for('react.consumer')
            var s = Symbol.for('react.context')
            var l = Symbol.for('react.forward_ref')
            var u = Symbol.for('react.suspense')
            var d = Symbol.for('react.suspense_list')
            var m = Symbol.for('react.memo')
            var p = Symbol.for('react.lazy')
            var f = Symbol.for('react.view_transition')
            const g = Symbol.for('react.client.reference')
            ;((he.ContextConsumer = i),
              (he.ContextProvider = s),
              (he.Element = t),
              (he.ForwardRef = l),
              (he.Fragment = n),
              (he.Lazy = p),
              (he.Memo = m),
              (he.Portal = r),
              (he.Profiler = a),
              (he.StrictMode = o),
              (he.Suspense = u),
              (he.SuspenseList = d),
              (he.isContextConsumer = function (y) {
                return e(y) === i
              }),
              (he.isContextProvider = function (y) {
                return e(y) === s
              }),
              (he.isElement = function (y) {
                return typeof y === 'object' && y !== null && y.$$typeof === t
              }),
              (he.isForwardRef = function (y) {
                return e(y) === l
              }),
              (he.isFragment = function (y) {
                return e(y) === n
              }),
              (he.isLazy = function (y) {
                return e(y) === p
              }),
              (he.isMemo = function (y) {
                return e(y) === m
              }),
              (he.isPortal = function (y) {
                return e(y) === r
              }),
              (he.isProfiler = function (y) {
                return e(y) === a
              }),
              (he.isStrictMode = function (y) {
                return e(y) === o
              }),
              (he.isSuspense = function (y) {
                return e(y) === u
              }),
              (he.isSuspenseList = function (y) {
                return e(y) === d
              }),
              (he.isValidElementType = function (y) {
                return (
                  typeof y === 'string' ||
                  typeof y === 'function' ||
                  y === n ||
                  y === a ||
                  y === o ||
                  y === u ||
                  y === d ||
                  (typeof y === 'object' &&
                    y !== null &&
                    (y.$$typeof === p ||
                      y.$$typeof === m ||
                      y.$$typeof === s ||
                      y.$$typeof === i ||
                      y.$$typeof === l ||
                      y.$$typeof === g ||
                      y.getModuleId !== void 0))
                )
              }),
              (he.typeOf = e))
          })()),
        he
      )
    }
    C(ph, 'requireReactIs_development$1')
    let Om
    function mh() {
      return (Om || ((Om = 1), (Tm.exports = ph())), Tm.exports)
    }
    C(mh, 'requireReactIs$1')
    const hh = mh()
    const tx = Qs(hh)
    const rx = Xs({ __proto__: null, default: tx }, [hh])
    const Im = { exports: {} }
    const le = {}
    let Rm
    function fh() {
      return (
        Rm ||
          ((Rm = 1),
          (function () {
            const e = Symbol.for('react.element')
            const t = Symbol.for('react.portal')
            const r = Symbol.for('react.fragment')
            const n = Symbol.for('react.strict_mode')
            const o = Symbol.for('react.profiler')
            const a = Symbol.for('react.provider')
            const i = Symbol.for('react.context')
            const s = Symbol.for('react.server_context')
            const l = Symbol.for('react.forward_ref')
            const u = Symbol.for('react.suspense')
            const d = Symbol.for('react.suspense_list')
            const m = Symbol.for('react.memo')
            const p = Symbol.for('react.lazy')
            const f = Symbol.for('react.offscreen')
            const g = !1
            const y = !1
            const E = !1
            const b = !1
            const x = !1
            let S
            S = Symbol.for('react.module.reference')
            function T(W) {
              return !!(
                typeof W === 'string' ||
                typeof W === 'function' ||
                W === r ||
                W === o ||
                x ||
                W === n ||
                W === u ||
                W === d ||
                b ||
                W === f ||
                g ||
                y ||
                E ||
                (typeof W === 'object' &&
                  W !== null &&
                  (W.$$typeof === p ||
                    W.$$typeof === m ||
                    W.$$typeof === a ||
                    W.$$typeof === i ||
                    W.$$typeof === l ||
                    W.$$typeof === S ||
                    W.getModuleId !== void 0))
              )
            }
            C(T, 'isValidElementType')
            function _(W) {
              if (typeof W === 'object' && W !== null) {
                const me = W.$$typeof
                switch (me) {
                  case e:
                    var ue = W.type
                    switch (ue) {
                      case r:
                      case o:
                      case n:
                      case u:
                      case d:
                        return ue
                      default:
                        var ht = ue && ue.$$typeof
                        switch (ht) {
                          case s:
                          case i:
                          case l:
                          case p:
                          case m:
                          case a:
                            return ht
                          default:
                            return me
                        }
                    }
                  case t:
                    return me
                }
              }
            }
            C(_, 'typeOf')
            const O = i
            const k = a
            const B = e
            const P = l
            const L = r
            const j = p
            const U = m
            const $ = t
            const v = o
            const A = n
            const D = u
            const N = d
            let F = !1
            let M = !1
            function q(W) {
              return (
                F ||
                  ((F = !0),
                  console.warn(
                    'The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.'
                  )),
                !1
              )
            }
            C(q, 'isAsyncMode')
            function V(W) {
              return (
                M ||
                  ((M = !0),
                  console.warn(
                    'The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.'
                  )),
                !1
              )
            }
            C(V, 'isConcurrentMode')
            function G(W) {
              return _(W) === i
            }
            C(G, 'isContextConsumer')
            function se(W) {
              return _(W) === a
            }
            C(se, 'isContextProvider')
            function pe(W) {
              return typeof W === 'object' && W !== null && W.$$typeof === e
            }
            C(pe, 'isElement')
            function ae(W) {
              return _(W) === l
            }
            C(ae, 'isForwardRef')
            function we(W) {
              return _(W) === r
            }
            C(we, 'isFragment')
            function ee(W) {
              return _(W) === p
            }
            C(ee, 'isLazy')
            function Ce(W) {
              return _(W) === m
            }
            C(Ce, 'isMemo')
            function Ve(W) {
              return _(W) === t
            }
            C(Ve, 'isPortal')
            function Fe(W) {
              return _(W) === o
            }
            C(Fe, 'isProfiler')
            function lt(W) {
              return _(W) === n
            }
            C(lt, 'isStrictMode')
            function Zt(W) {
              return _(W) === u
            }
            C(Zt, 'isSuspense')
            function Nr(W) {
              return _(W) === d
            }
            ;(C(Nr, 'isSuspenseList'),
              (le.ContextConsumer = O),
              (le.ContextProvider = k),
              (le.Element = B),
              (le.ForwardRef = P),
              (le.Fragment = L),
              (le.Lazy = j),
              (le.Memo = U),
              (le.Portal = $),
              (le.Profiler = v),
              (le.StrictMode = A),
              (le.Suspense = D),
              (le.SuspenseList = N),
              (le.isAsyncMode = q),
              (le.isConcurrentMode = V),
              (le.isContextConsumer = G),
              (le.isContextProvider = se),
              (le.isElement = pe),
              (le.isForwardRef = ae),
              (le.isFragment = we),
              (le.isLazy = ee),
              (le.isMemo = Ce),
              (le.isPortal = Ve),
              (le.isProfiler = Fe),
              (le.isStrictMode = lt),
              (le.isSuspense = Zt),
              (le.isSuspenseList = Nr),
              (le.isValidElementType = T),
              (le.typeOf = _))
          })()),
        le
      )
    }
    C(fh, 'requireReactIs_development')
    let Bm
    function gh() {
      return (Bm || ((Bm = 1), (Im.exports = fh())), Im.exports)
    }
    C(gh, 'requireReactIs')
    const yh = gh()
    const nx = Qs(yh)
    const ox = Xs({ __proto__: null, default: nx }, [yh])
    const ax = [
      'isAsyncMode',
      'isConcurrentMode',
      'isContextConsumer',
      'isContextProvider',
      'isElement',
      'isForwardRef',
      'isFragment',
      'isLazy',
      'isMemo',
      'isPortal',
      'isProfiler',
      'isStrictMode',
      'isSuspense',
      'isSuspenseList',
      'isValidElementType',
    ]
    const xr = Object.fromEntries(ax.map(e => [e, t => ox[e](t) || rx[e](t)]))
    function el(e, t = []) {
      if (Array.isArray(e)) for (const r of e) el(r, t)
      else e != null && e !== !1 && e !== '' && t.push(e)
      return t
    }
    C(el, 'getChildren')
    function Ts(e) {
      const t = e.type
      if (typeof t === 'string') return t
      if (typeof t === 'function') return t.displayName || t.name || 'Unknown'
      if (xr.isFragment(e)) return 'React.Fragment'
      if (xr.isSuspense(e)) return 'React.Suspense'
      if (typeof t === 'object' && t !== null) {
        if (xr.isContextProvider(e)) return 'Context.Provider'
        if (xr.isContextConsumer(e)) return 'Context.Consumer'
        if (xr.isForwardRef(e)) {
          if (t.displayName) return t.displayName
          const r = t.render.displayName || t.render.name || ''
          return r === '' ? 'ForwardRef' : `ForwardRef(${r})`
        }
        if (xr.isMemo(e)) {
          const r = t.displayName || t.type.displayName || t.type.name || ''
          return r === '' ? 'Memo' : `Memo(${r})`
        }
      }
      return 'UNDEFINED'
    }
    C(Ts, 'getType')
    function bh(e) {
      const { props: t } = e
      return Object.keys(t)
        .filter(r => r !== 'children' && t[r] !== void 0)
        .sort()
    }
    C(bh, 'getPropKeys$1')
    const ix = C(
      (e, t, r, n, o, a) =>
        ++n > t.maxDepth
          ? ha(Ts(e), t)
          : ma(
              Ts(e),
              da(bh(e), e.props, t, r + t.indent, n, o, a),
              pa(el(e.props.children), t, r + t.indent, n, o, a),
              t,
              r
            ),
      'serialize$1'
    )
    const sx = C(e => e != null && xr.isElement(e), 'test$1')
    const lx = { serialize: ix, test: sx }
    const ux =
      typeof Symbol === 'function' && Symbol.for
        ? Symbol.for('react.test.json')
        : 245830487
    function Eh(e) {
      const { props: t } = e
      return t
        ? Object.keys(t)
            .filter(r => t[r] !== void 0)
            .sort()
        : []
    }
    C(Eh, 'getPropKeys')
    const cx = C(
      (e, t, r, n, o, a) =>
        ++n > t.maxDepth
          ? ha(e.type, t)
          : ma(
              e.type,
              e.props ? da(Eh(e), e.props, t, r + t.indent, n, o, a) : '',
              e.children ? pa(e.children, t, r + t.indent, n, o, a) : '',
              t,
              r
            ),
      'serialize'
    )
    const dx = C(e => e && e.$$typeof === ux, 'test')
    const px = { serialize: cx, test: dx }
    const vh = Object.prototype.toString
    const mx = Date.prototype.toISOString
    const hx = Error.prototype.toString
    const _m = RegExp.prototype.toString
    function Mn(e) {
      return (
        (typeof e.constructor === 'function' && e.constructor.name) || 'Object'
      )
    }
    C(Mn, 'getConstructorName')
    function Ah(e) {
      return typeof window < 'u' && e === window
    }
    C(Ah, 'isWindow')
    const fx = /^Symbol\((.*)\)(.*)$/
    const gx = /\n/g
    const xh = class extends Error {
      constructor(t, r) {
        ;(super(t), (this.stack = r), (this.name = this.constructor.name))
      }
    }
    C(xh, 'PrettyFormatPluginError')
    const wh = xh
    function Sh(e) {
      return (
        e === '[object Array]' ||
        e === '[object ArrayBuffer]' ||
        e === '[object DataView]' ||
        e === '[object Float32Array]' ||
        e === '[object Float64Array]' ||
        e === '[object Int8Array]' ||
        e === '[object Int16Array]' ||
        e === '[object Int32Array]' ||
        e === '[object Uint8Array]' ||
        e === '[object Uint8ClampedArray]' ||
        e === '[object Uint16Array]' ||
        e === '[object Uint32Array]'
      )
    }
    C(Sh, 'isToStringedArrayType')
    function Ch(e) {
      return Object.is(e, -0) ? '-0' : String(e)
    }
    C(Ch, 'printNumber')
    function Dh(e) {
      return `${e}n`
    }
    C(Dh, 'printBigInt')
    function ks(e, t) {
      return t ? `[Function ${e.name || 'anonymous'}]` : '[Function]'
    }
    C(ks, 'printFunction')
    function Os(e) {
      return String(e).replace(fx, 'Symbol($1)')
    }
    C(Os, 'printSymbol')
    function Is(e) {
      return `[${hx.call(e)}]`
    }
    C(Is, 'printError')
    function tl(e, t, r, n) {
      if (e === !0 || e === !1) return `${e}`
      if (e === void 0) return 'undefined'
      if (e === null) return 'null'
      const o = typeof e
      if (o === 'number') return Ch(e)
      if (o === 'bigint') return Dh(e)
      if (o === 'string')
        return n ? `"${e.replaceAll(/"|\\/g, '\\$&')}"` : `"${e}"`
      if (o === 'function') return ks(e, t)
      if (o === 'symbol') return Os(e)
      const a = vh.call(e)
      return a === '[object WeakMap]'
        ? 'WeakMap {}'
        : a === '[object WeakSet]'
          ? 'WeakSet {}'
          : a === '[object Function]' || a === '[object GeneratorFunction]'
            ? ks(e, t)
            : a === '[object Symbol]'
              ? Os(e)
              : a === '[object Date]'
                ? Number.isNaN(+e)
                  ? 'Date { NaN }'
                  : mx.call(e)
                : a === '[object Error]'
                  ? Is(e)
                  : a === '[object RegExp]'
                    ? r
                      ? _m.call(e).replaceAll(/[$()*+.?[\\\]^{|}]/g, '\\$&')
                      : _m.call(e)
                    : e instanceof Error
                      ? Is(e)
                      : null
    }
    C(tl, 'printBasicValue')
    function rl(e, t, r, n, o, a) {
      if (o.includes(e)) return '[Circular]'
      ;((o = [...o]), o.push(e))
      const i = ++n > t.maxDepth
      const s = t.min
      if (
        t.callToJSON &&
        !i &&
        e.toJSON &&
        typeof e.toJSON === 'function' &&
        !a
      )
        return $t(e.toJSON(), t, r, n, o, !0)
      const l = vh.call(e)
      return l === '[object Arguments]'
        ? i
          ? '[Arguments]'
          : `${s ? '' : 'Arguments '}[${qn(e, t, r, n, o, $t)}]`
        : Sh(l)
          ? i
            ? `[${e.constructor.name}]`
            : `${s || (!t.printBasicPrototype && e.constructor.name === 'Array') ? '' : `${e.constructor.name} `}[${qn(e, t, r, n, o, $t)}]`
          : l === '[object Map]'
            ? i
              ? '[Map]'
              : `Map {${sn(e.entries(), t, r, n, o, $t, ' => ')}}`
            : l === '[object Set]'
              ? i
                ? '[Set]'
                : `Set {${ua(e.values(), t, r, n, o, $t)}}`
              : i || Ah(e)
                ? `[${Mn(e)}]`
                : `${s || (!t.printBasicPrototype && Mn(e) === 'Object') ? '' : `${Mn(e)} `}{${ca(e, t, r, n, o, $t)}}`
    }
    C(rl, 'printComplexValue')
    const yx = {
      test: C(e => e && e instanceof Error, 'test'),
      serialize(e, t, r, n, o, a) {
        if (o.includes(e)) return '[Circular]'
        o = [...o, e]
        const i = ++n > t.maxDepth
        const { message: s, cause: l, ...u } = e
        const d = {
          message: s,
          ...(typeof l < 'u' ? { cause: l } : {}),
          ...(e instanceof AggregateError ? { errors: e.errors } : {}),
          ...u,
        }
        const m = e.name !== 'Error' ? e.name : Mn(e)
        return i
          ? `[${m}]`
          : `${m} {${sn(Object.entries(d).values(), t, r, n, o, a)}}`
      },
    }
    function Th(e) {
      return e.serialize != null
    }
    C(Th, 'isNewPlugin')
    function nl(e, t, r, n, o, a) {
      let i
      try {
        i = Th(e)
          ? e.serialize(t, r, n, o, a, $t)
          : e.print(
              t,
              s => $t(s, r, n, o, a),
              s => {
                const l = n + r.indent
                return (
                  l +
                  s.replaceAll(
                    gx,
                    `
${l}`
                  )
                )
              },
              {
                edgeSpacing: r.spacingOuter,
                min: r.min,
                spacing: r.spacingInner,
              },
              r.colors
            )
      } catch (s) {
        throw new wh(s.message, s.stack)
      }
      if (typeof i !== 'string')
        throw new TypeError(
          `pretty-format: Plugin must return type "string" but instead returned "${typeof i}".`
        )
      return i
    }
    C(nl, 'printPlugin')
    function ol(e, t) {
      for (const r of e)
        try {
          if (r.test(t)) return r
        } catch (n) {
          throw new wh(n.message, n.stack)
        }
      return null
    }
    C(ol, 'findPlugin')
    function $t(e, t, r, n, o, a) {
      const i = ol(t.plugins, e)
      if (i !== null) return nl(i, e, t, r, n, o)
      const s = tl(e, t.printFunctionName, t.escapeRegex, t.escapeString)
      return s !== null ? s : rl(e, t, r, n, o, a)
    }
    C($t, 'printer')
    const al = {
      comment: 'gray',
      content: 'reset',
      prop: 'yellow',
      tag: 'cyan',
      value: 'green',
    }
    const kh = Object.keys(al)
    const St = {
      callToJSON: !0,
      compareKeys: void 0,
      escapeRegex: !1,
      escapeString: !0,
      highlight: !1,
      indent: 2,
      maxDepth: Number.POSITIVE_INFINITY,
      maxWidth: Number.POSITIVE_INFINITY,
      min: !1,
      plugins: [],
      printBasicPrototype: !0,
      printFunctionName: !0,
      theme: al,
    }
    function Oh(e) {
      for (const t of Object.keys(e))
        if (!Object.prototype.hasOwnProperty.call(St, t))
          throw new Error(`pretty-format: Unknown option "${t}".`)
      if (e.min && e.indent !== void 0 && e.indent !== 0)
        throw new Error(
          'pretty-format: Options "min" and "indent" cannot be used together.'
        )
    }
    C(Oh, 'validateOptions')
    function Ih() {
      return kh.reduce((e, t) => {
        const r = al[t]
        const n = r && Ut[r]
        if (n && typeof n.close === 'string' && typeof n.open === 'string')
          e[t] = n
        else
          throw new Error(
            `pretty-format: Option "theme" has a key "${t}" whose value "${r}" is undefined in ansi-styles.`
          )
        return e
      }, Object.create(null))
    }
    C(Ih, 'getColorsHighlight')
    function Rh() {
      return kh.reduce(
        (e, t) => ((e[t] = { close: '', open: '' }), e),
        Object.create(null)
      )
    }
    C(Rh, 'getColorsEmpty')
    function il(e) {
      return e?.printFunctionName ?? St.printFunctionName
    }
    C(il, 'getPrintFunctionName')
    function sl(e) {
      return e?.escapeRegex ?? St.escapeRegex
    }
    C(sl, 'getEscapeRegex')
    function ll(e) {
      return e?.escapeString ?? St.escapeString
    }
    C(ll, 'getEscapeString')
    function Rs(e) {
      return {
        callToJSON: e?.callToJSON ?? St.callToJSON,
        colors: e?.highlight ? Ih() : Rh(),
        compareKeys:
          typeof e?.compareKeys === 'function' || e?.compareKeys === null
            ? e.compareKeys
            : St.compareKeys,
        escapeRegex: sl(e),
        escapeString: ll(e),
        indent: e?.min ? '' : Bh(e?.indent ?? St.indent),
        maxDepth: e?.maxDepth ?? St.maxDepth,
        maxWidth: e?.maxWidth ?? St.maxWidth,
        min: e?.min ?? St.min,
        plugins: e?.plugins ?? St.plugins,
        printBasicPrototype: e?.printBasicPrototype ?? !0,
        printFunctionName: il(e),
        spacingInner: e?.min
          ? ' '
          : `
`,
        spacingOuter: e?.min
          ? ''
          : `
`,
      }
    }
    C(Rs, 'getConfig')
    function Bh(e) {
      return Array.from({ length: e + 1 }).join(' ')
    }
    C(Bh, 'createIndent')
    function Ct(e, t) {
      if (t && (Oh(t), t.plugins)) {
        const n = ol(t.plugins, e)
        if (n !== null) return nl(n, e, Rs(t), '', 0, [])
      }
      const r = tl(e, il(t), sl(t), ll(t))
      return r !== null ? r : rl(e, Rs(t), '', 0, [])
    }
    C(Ct, 'format')
    const ul = {
      AsymmetricMatcher: _A,
      DOMCollection: jA,
      DOMElement: HA,
      Immutable: ex,
      ReactElement: lx,
      ReactTestComponent: px,
      Error: yx,
    }
    const Fm = {
      bold: ['1', '22'],
      dim: ['2', '22'],
      italic: ['3', '23'],
      underline: ['4', '24'],
      inverse: ['7', '27'],
      hidden: ['8', '28'],
      strike: ['9', '29'],
      black: ['30', '39'],
      red: ['31', '39'],
      green: ['32', '39'],
      yellow: ['33', '39'],
      blue: ['34', '39'],
      magenta: ['35', '39'],
      cyan: ['36', '39'],
      white: ['37', '39'],
      brightblack: ['30;1', '39'],
      brightred: ['31;1', '39'],
      brightgreen: ['32;1', '39'],
      brightyellow: ['33;1', '39'],
      brightblue: ['34;1', '39'],
      brightmagenta: ['35;1', '39'],
      brightcyan: ['36;1', '39'],
      brightwhite: ['37;1', '39'],
      grey: ['90', '39'],
    }
    const bx = {
      special: 'cyan',
      number: 'yellow',
      bigint: 'yellow',
      boolean: 'yellow',
      undefined: 'grey',
      null: 'bold',
      string: 'green',
      symbol: 'green',
      date: 'magenta',
      regexp: 'red',
    }
    const nn = '\u2026'
    function _h(e, t) {
      const r = Fm[bx[t]] || Fm[t] || ''
      return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e)
    }
    C(_h, 'colorise')
    function Fh(
      {
        showHidden: e = !1,
        depth: t = 2,
        colors: r = !1,
        customInspect: n = !0,
        showProxy: o = !1,
        maxArrayLength: a = 1 / 0,
        breakLength: i = 1 / 0,
        seen: s = [],
        truncate: l = 1 / 0,
        stylize: u = String,
      } = {},
      d
    ) {
      const m = {
        showHidden: !!e,
        depth: Number(t),
        colors: !!r,
        customInspect: !!n,
        showProxy: !!o,
        maxArrayLength: Number(a),
        breakLength: Number(i),
        truncate: Number(l),
        seen: s,
        inspect: d,
        stylize: u,
      }
      return (m.colors && (m.stylize = _h), m)
    }
    C(Fh, 'normaliseOptions')
    function Ph(e) {
      return e >= '\uD800' && e <= '\uDBFF'
    }
    C(Ph, 'isHighSurrogate')
    function Ht(e, t, r = nn) {
      e = String(e)
      const n = r.length
      const o = e.length
      if (n > t && o > n) return r
      if (o > t && o > n) {
        let a = t - n
        return (a > 0 && Ph(e[a - 1]) && (a = a - 1), `${e.slice(0, a)}${r}`)
      }
      return e
    }
    C(Ht, 'truncate')
    function bt(e, t, r, n = ', ') {
      r = r || t.inspect
      const o = e.length
      if (o === 0) return ''
      const a = t.truncate
      let i = ''
      let s = ''
      let l = ''
      for (let u = 0; u < o; u += 1) {
        const d = u + 1 === e.length
        const m = u + 2 === e.length
        l = `${nn}(${e.length - u})`
        const p = e[u]
        t.truncate = a - i.length - (d ? 0 : n.length)
        const f = s || r(p, t) + (d ? '' : n)
        const g = i.length + f.length
        const y = g + l.length
        if (
          (d && g > a && i.length + l.length <= a) ||
          (!d && !m && y > a) ||
          ((s = d ? '' : r(e[u + 1], t) + (m ? '' : n)),
          !d && m && y > a && g + s.length > a)
        )
          break
        if (((i += f), !d && !m && g + s.length >= a)) {
          l = `${nn}(${e.length - u - 1})`
          break
        }
        l = ''
      }
      return `${i}${l}`
    }
    C(bt, 'inspectList')
    function Nh(e) {
      return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)
        ? e
        : JSON.stringify(e)
            .replace(/'/g, "\\'")
            .replace(/\\"/g, '"')
            .replace(/(^"|"$)/g, "'")
    }
    C(Nh, 'quoteComplexKey')
    function on([e, t], r) {
      return (
        (r.truncate -= 2),
        typeof e === 'string'
          ? (e = Nh(e))
          : typeof e !== 'number' && (e = `[${r.inspect(e, r)}]`),
        (r.truncate -= e.length),
        (t = r.inspect(t, r)),
        `${e}: ${t}`
      )
    }
    C(on, 'inspectProperty')
    function Lh(e, t) {
      const r = Object.keys(e).slice(e.length)
      if (!e.length && !r.length) return '[]'
      t.truncate -= 4
      const n = bt(e, t)
      t.truncate -= n.length
      let o = ''
      return (
        r.length &&
          (o = bt(
            r.map(a => [a, e[a]]),
            t,
            on
          )),
        `[ ${n}${o ? `, ${o}` : ''} ]`
      )
    }
    C(Lh, 'inspectArray')
    const Ex = C(
      e =>
        typeof Buffer === 'function' && e instanceof Buffer
          ? 'Buffer'
          : e[Symbol.toStringTag]
            ? e[Symbol.toStringTag]
            : e.constructor.name,
      'getArrayName'
    )
    function _t(e, t) {
      const r = Ex(e)
      t.truncate -= r.length + 4
      const n = Object.keys(e).slice(e.length)
      if (!e.length && !n.length) return `${r}[]`
      let o = ''
      for (let i = 0; i < e.length; i++) {
        const s = `${t.stylize(Ht(e[i], t.truncate), 'number')}${i === e.length - 1 ? '' : ', '}`
        if (((t.truncate -= s.length), e[i] !== e.length && t.truncate <= 3)) {
          o += `${nn}(${e.length - e[i] + 1})`
          break
        }
        o += s
      }
      let a = ''
      return (
        n.length &&
          (a = bt(
            n.map(i => [i, e[i]]),
            t,
            on
          )),
        `${r}[ ${o}${a ? `, ${a}` : ''} ]`
      )
    }
    C(_t, 'inspectTypedArray')
    function jh(e, t) {
      const r = e.toJSON()
      if (r === null) return 'Invalid Date'
      const n = r.split('T')
      const o = n[0]
      return t.stylize(`${o}T${Ht(n[1], t.truncate - o.length - 1)}`, 'date')
    }
    C(jh, 'inspectDate')
    function Bs(e, t) {
      const r = e[Symbol.toStringTag] || 'Function'
      const n = e.name
      return n
        ? t.stylize(`[${r} ${Ht(n, t.truncate - 11)}]`, 'special')
        : t.stylize(`[${r}]`, 'special')
    }
    C(Bs, 'inspectFunction')
    function Mh([e, t], r) {
      return (
        (r.truncate -= 4),
        (e = r.inspect(e, r)),
        (r.truncate -= e.length),
        (t = r.inspect(t, r)),
        `${e} => ${t}`
      )
    }
    C(Mh, 'inspectMapEntry')
    function $h(e) {
      const t = []
      return (
        e.forEach((r, n) => {
          t.push([n, r])
        }),
        t
      )
    }
    C($h, 'mapToEntries')
    function qh(e, t) {
      return e.size === 0
        ? 'Map{}'
        : ((t.truncate -= 7), `Map{ ${bt($h(e), t, Mh)} }`)
    }
    C(qh, 'inspectMap')
    const vx = Number.isNaN || (e => e !== e)
    function _s(e, t) {
      return vx(e)
        ? t.stylize('NaN', 'number')
        : e === 1 / 0
          ? t.stylize('Infinity', 'number')
          : e === -1 / 0
            ? t.stylize('-Infinity', 'number')
            : e === 0
              ? t.stylize(1 / e === 1 / 0 ? '+0' : '-0', 'number')
              : t.stylize(Ht(String(e), t.truncate), 'number')
    }
    C(_s, 'inspectNumber')
    function Fs(e, t) {
      let r = Ht(e.toString(), t.truncate - 1)
      return (r !== nn && (r += 'n'), t.stylize(r, 'bigint'))
    }
    C(Fs, 'inspectBigInt')
    function Uh(e, t) {
      const r = e.toString().split('/')[2]
      const n = t.truncate - (2 + r.length)
      const o = e.source
      return t.stylize(`/${Ht(o, n)}/${r}`, 'regexp')
    }
    C(Uh, 'inspectRegExp')
    function Hh(e) {
      const t = []
      return (
        e.forEach(r => {
          t.push(r)
        }),
        t
      )
    }
    C(Hh, 'arrayFromSet')
    function Vh(e, t) {
      return e.size === 0
        ? 'Set{}'
        : ((t.truncate -= 7), `Set{ ${bt(Hh(e), t)} }`)
    }
    C(Vh, 'inspectSet')
    const Pm = new RegExp(
      "['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]",
      'g'
    )
    const Ax = {
      '\b': '\\b',
      '	': '\\t',
      '\n': '\\n',
      '\f': '\\f',
      '\r': '\\r',
      "'": "\\'",
      '\\': '\\\\',
    }
    const xx = 16
    const wx = 4
    function zh(e) {
      return Ax[e] || `\\u${`0000${e.charCodeAt(0).toString(xx)}`.slice(-wx)}`
    }
    C(zh, 'escape')
    function Ps(e, t) {
      return (
        Pm.test(e) && (e = e.replace(Pm, zh)),
        t.stylize(`'${Ht(e, t.truncate - 2)}'`, 'string')
      )
    }
    C(Ps, 'inspectString')
    function Ns(e) {
      return 'description' in Symbol.prototype
        ? e.description
          ? `Symbol(${e.description})`
          : 'Symbol()'
        : e.toString()
    }
    C(Ns, 'inspectSymbol')
    let Gh = C(() => 'Promise{\u2026}', 'getPromiseValue')
    try {
      const {
        getPromiseDetails: e,
        kPending: t,
        kRejected: r,
      } = process.binding('util')
      Array.isArray(e(Promise.resolve())) &&
        (Gh = C((n, o) => {
          const [a, i] = e(n)
          return a === t
            ? 'Promise{<pending>}'
            : `Promise${a === r ? '!' : ''}{${o.inspect(i, o)}}`
        }, 'getPromiseValue'))
    } catch {}
    const Sx = Gh
    function $n(e, t) {
      const r = Object.getOwnPropertyNames(e)
      const n = Object.getOwnPropertySymbols
        ? Object.getOwnPropertySymbols(e)
        : []
      if (r.length === 0 && n.length === 0) return '{}'
      if (((t.truncate -= 4), (t.seen = t.seen || []), t.seen.includes(e)))
        return '[Circular]'
      t.seen.push(e)
      const o = bt(
        r.map(s => [s, e[s]]),
        t,
        on
      )
      const a = bt(
        n.map(s => [s, e[s]]),
        t,
        on
      )
      t.seen.pop()
      let i = ''
      return (o && a && (i = ', '), `{ ${o}${i}${a} }`)
    }
    C($n, 'inspectObject')
    const As =
      typeof Symbol < 'u' && Symbol.toStringTag ? Symbol.toStringTag : !1
    function Wh(e, t) {
      let r = ''
      return (
        As && As in e && (r = e[As]),
        (r = r || e.constructor.name),
        (!r || r === '_class') && (r = '<Anonymous Class>'),
        (t.truncate -= r.length),
        `${r}${$n(e, t)}`
      )
    }
    C(Wh, 'inspectClass')
    function Yh(e, t) {
      return e.length === 0
        ? 'Arguments[]'
        : ((t.truncate -= 13), `Arguments[ ${bt(e, t)} ]`)
    }
    C(Yh, 'inspectArguments')
    const Cx = [
      'stack',
      'line',
      'column',
      'name',
      'message',
      'fileName',
      'lineNumber',
      'columnNumber',
      'number',
      'description',
      'cause',
    ]
    function Kh(e, t) {
      const r = Object.getOwnPropertyNames(e).filter(i => !Cx.includes(i))
      const n = e.name
      t.truncate -= n.length
      let o = ''
      if (
        (typeof e.message === 'string'
          ? (o = Ht(e.message, t.truncate))
          : r.unshift('message'),
        (o = o ? `: ${o}` : ''),
        (t.truncate -= o.length + 5),
        (t.seen = t.seen || []),
        t.seen.includes(e))
      )
        return '[Circular]'
      t.seen.push(e)
      const a = bt(
        r.map(i => [i, e[i]]),
        t,
        on
      )
      return `${n}${o}${a ? ` { ${a} }` : ''}`
    }
    C(Kh, 'inspectObject')
    function Xh([e, t], r) {
      return (
        (r.truncate -= 3),
        t
          ? `${r.stylize(String(e), 'yellow')}=${r.stylize(`"${t}"`, 'string')}`
          : `${r.stylize(String(e), 'yellow')}`
      )
    }
    C(Xh, 'inspectAttribute')
    function ra(e, t) {
      return bt(
        e,
        t,
        Jh,
        `
`
      )
    }
    C(ra, 'inspectNodeCollection')
    function Jh(e, t) {
      switch (e.nodeType) {
        case 1:
          return cl(e, t)
        case 3:
          return t.inspect(e.data, t)
        default:
          return t.inspect(e, t)
      }
    }
    C(Jh, 'inspectNode')
    function cl(e, t) {
      const r = e.getAttributeNames()
      const n = e.tagName.toLowerCase()
      const o = t.stylize(`<${n}`, 'special')
      const a = t.stylize('>', 'special')
      const i = t.stylize(`</${n}>`, 'special')
      t.truncate -= n.length * 2 + 5
      let s = ''
      ;(r.length > 0 &&
        ((s += ' '),
        (s += bt(
          r.map(d => [d, e.getAttribute(d)]),
          t,
          Xh,
          ' '
        ))),
        (t.truncate -= s.length))
      const l = t.truncate
      let u = ra(e.children, t)
      return (
        u && u.length > l && (u = `${nn}(${e.children.length})`),
        `${o}${s}${a}${u}${i}`
      )
    }
    C(cl, 'inspectHTML')
    const Dx = typeof Symbol === 'function' && typeof Symbol.for === 'function'
    const xs = Dx ? Symbol.for('chai/inspect') : '@@chai/inspect'
    const ws = Symbol.for('nodejs.util.inspect.custom')
    const Nm = new WeakMap()
    const Lm = {}
    const jm = {
      undefined: C((e, t) => t.stylize('undefined', 'undefined'), 'undefined'),
      null: C((e, t) => t.stylize('null', 'null'), 'null'),
      boolean: C((e, t) => t.stylize(String(e), 'boolean'), 'boolean'),
      Boolean: C((e, t) => t.stylize(String(e), 'boolean'), 'Boolean'),
      number: _s,
      Number: _s,
      bigint: Fs,
      BigInt: Fs,
      string: Ps,
      String: Ps,
      function: Bs,
      Function: Bs,
      symbol: Ns,
      Symbol: Ns,
      Array: Lh,
      Date: jh,
      Map: qh,
      Set: Vh,
      RegExp: Uh,
      Promise: Sx,
      WeakSet: C((e, t) => t.stylize('WeakSet{\u2026}', 'special'), 'WeakSet'),
      WeakMap: C((e, t) => t.stylize('WeakMap{\u2026}', 'special'), 'WeakMap'),
      Arguments: Yh,
      Int8Array: _t,
      Uint8Array: _t,
      Uint8ClampedArray: _t,
      Int16Array: _t,
      Uint16Array: _t,
      Int32Array: _t,
      Uint32Array: _t,
      Float32Array: _t,
      Float64Array: _t,
      Generator: C(() => '', 'Generator'),
      DataView: C(() => '', 'DataView'),
      ArrayBuffer: C(() => '', 'ArrayBuffer'),
      Error: Kh,
      HTMLCollection: ra,
      NodeList: ra,
    }
    const Tx = C(
      (e, t, r) =>
        xs in e && typeof e[xs] === 'function'
          ? e[xs](t)
          : ws in e && typeof e[ws] === 'function'
            ? e[ws](t.depth, t)
            : 'inspect' in e && typeof e.inspect === 'function'
              ? e.inspect(t.depth, t)
              : 'constructor' in e && Nm.has(e.constructor)
                ? Nm.get(e.constructor)(e, t)
                : Lm[r]
                  ? Lm[r](e, t)
                  : '',
      'inspectCustom'
    )
    const kx = Object.prototype.toString
    function na(e, t = {}) {
      const r = Fh(t, na)
      const { customInspect: n } = r
      let o = e === null ? 'null' : typeof e
      if ((o === 'object' && (o = kx.call(e).slice(8, -1)), o in jm))
        return jm[o](e, r)
      if (n && e) {
        const i = Tx(e, r, o)
        if (i) return typeof i === 'string' ? i : na(i, r)
      }
      const a = e ? Object.getPrototypeOf(e) : !1
      return a === Object.prototype || a === null
        ? $n(e, r)
        : e && typeof HTMLElement === 'function' && e instanceof HTMLElement
          ? cl(e, r)
          : 'constructor' in e
            ? e.constructor !== Object
              ? Wh(e, r)
              : $n(e, r)
            : e === Object(e)
              ? $n(e, r)
              : r.stylize(String(e), o)
    }
    C(na, 'inspect')
    const {
      AsymmetricMatcher: Ox,
      DOMCollection: Ix,
      DOMElement: Rx,
      Immutable: Bx,
      ReactElement: _x,
      ReactTestComponent: Fx,
    } = ul
    const Mm = [Fx, _x, Rx, Ix, Bx, Ox]
    function an(e, t = 10, { maxLength: r, ...n } = {}) {
      const o = r ?? 1e4
      let a
      try {
        a = Ct(e, { maxDepth: t, escapeString: !1, plugins: Mm, ...n })
      } catch {
        a = Ct(e, {
          callToJSON: !1,
          maxDepth: t,
          escapeString: !1,
          plugins: Mm,
          ...n,
        })
      }
      return a.length >= o && t > 1
        ? an(e, Math.floor(Math.min(t, Number.MAX_SAFE_INTEGER) / 2), {
            maxLength: r,
            ...n,
          })
        : a
    }
    C(an, 'stringify')
    const Px = /%[sdjifoOc%]/g
    function Zh(...e) {
      if (typeof e[0] !== 'string') {
        const a = []
        for (let i = 0; i < e.length; i++)
          a.push(tn(e[i], { depth: 0, colors: !1 }))
        return a.join(' ')
      }
      const t = e.length
      let r = 1
      const n = e[0]
      let o = String(n).replace(Px, a => {
        if (a === '%%') return '%'
        if (r >= t) return a
        switch (a) {
          case '%s': {
            const i = e[r++]
            return typeof i === 'bigint'
              ? `${i.toString()}n`
              : typeof i === 'number' && i === 0 && 1 / i < 0
                ? '-0'
                : typeof i === 'object' && i !== null
                  ? typeof i.toString === 'function' &&
                    i.toString !== Object.prototype.toString
                    ? i.toString()
                    : tn(i, { depth: 0, colors: !1 })
                  : String(i)
          }
          case '%d': {
            const i = e[r++]
            return typeof i === 'bigint'
              ? `${i.toString()}n`
              : Number(i).toString()
          }
          case '%i': {
            const i = e[r++]
            return typeof i === 'bigint'
              ? `${i.toString()}n`
              : Number.parseInt(String(i)).toString()
          }
          case '%f':
            return Number.parseFloat(String(e[r++])).toString()
          case '%o':
            return tn(e[r++], { showHidden: !0, showProxy: !0 })
          case '%O':
            return tn(e[r++])
          case '%c':
            return (r++, '')
          case '%j':
            try {
              return JSON.stringify(e[r++])
            } catch (i) {
              const s = i.message
              if (
                s.includes('circular structure') ||
                s.includes('cyclic structures') ||
                s.includes('cyclic object')
              )
                return '[Circular]'
              throw i
            }
          default:
            return a
        }
      })
      for (let a = e[r]; r < t; a = e[++r])
        a === null || typeof a !== 'object'
          ? (o += ` ${a}`)
          : (o += ` ${tn(a)}`)
      return o
    }
    C(Zh, 'format')
    function tn(e, t = {}) {
      return (
        t.truncate === 0 && (t.truncate = Number.POSITIVE_INFINITY),
        na(e, t)
      )
    }
    C(tn, 'inspect')
    function Qh(e) {
      return e &&
        e.__esModule &&
        Object.prototype.hasOwnProperty.call(e, 'default')
        ? e.default
        : e
    }
    C(Qh, 'getDefaultExportFromCjs')
    function ef(e) {
      return (
        e === Object.prototype ||
        e === Function.prototype ||
        e === RegExp.prototype
      )
    }
    C(ef, 'isFinalObj')
    function oa(e) {
      return Object.prototype.toString.apply(e).slice(8, -1)
    }
    C(oa, 'getType')
    function tf(e, t) {
      const r = typeof t === 'function' ? t : n => t.add(n)
      ;(Object.getOwnPropertyNames(e).forEach(r),
        Object.getOwnPropertySymbols(e).forEach(r))
    }
    C(tf, 'collectOwnProperties')
    function dl(e) {
      const t = new Set()
      return ef(e) ? [] : (tf(e, t), Array.from(t))
    }
    C(dl, 'getOwnProperties')
    const rf = { forceWritable: !1 }
    function Ls(e, t = rf) {
      return aa(e, new WeakMap(), t)
    }
    C(Ls, 'deepClone')
    function aa(e, t, r = rf) {
      let n, o
      if (t.has(e)) return t.get(e)
      if (Array.isArray(e)) {
        for (o = Array.from({ length: (n = e.length) }), t.set(e, o); n--; )
          o[n] = aa(e[n], t, r)
        return o
      }
      if (Object.prototype.toString.call(e) === '[object Object]') {
        ;((o = Object.create(Object.getPrototypeOf(e))), t.set(e, o))
        const a = dl(e)
        for (const i of a) {
          const s = Object.getOwnPropertyDescriptor(e, i)
          if (!s) continue
          const l = aa(e[i], t, r)
          r.forceWritable
            ? Object.defineProperty(o, i, {
                enumerable: s.enumerable,
                configurable: !0,
                writable: !0,
                value: l,
              })
            : 'get' in s
              ? Object.defineProperty(o, i, {
                  ...s,
                  get() {
                    return l
                  },
                })
              : Object.defineProperty(o, i, { ...s, value: l })
        }
        return o
      }
      return e
    }
    C(aa, 'clone')
    const Ue = -1
    const Le = 1
    const Se = 0
    const nf = class {
      0
      1
      constructor(t, r) {
        ;((this[0] = t), (this[1] = r))
      }
    }
    C(nf, 'Diff')
    const xe = nf
    function of(e, t) {
      if (!e || !t || e.charAt(0) !== t.charAt(0)) return 0
      let r = 0
      let n = Math.min(e.length, t.length)
      let o = n
      let a = 0
      for (; r < o; )
        (e.substring(a, o) === t.substring(a, o) ? ((r = o), (a = r)) : (n = o),
          (o = Math.floor((n - r) / 2 + r)))
      return o
    }
    C(of, 'diff_commonPrefix')
    function pl(e, t) {
      if (!e || !t || e.charAt(e.length - 1) !== t.charAt(t.length - 1))
        return 0
      let r = 0
      let n = Math.min(e.length, t.length)
      let o = n
      let a = 0
      for (; r < o; )
        (e.substring(e.length - o, e.length - a) ===
        t.substring(t.length - o, t.length - a)
          ? ((r = o), (a = r))
          : (n = o),
          (o = Math.floor((n - r) / 2 + r)))
      return o
    }
    C(pl, 'diff_commonSuffix')
    function js(e, t) {
      const r = e.length
      const n = t.length
      if (r === 0 || n === 0) return 0
      r > n ? (e = e.substring(r - n)) : r < n && (t = t.substring(0, r))
      const o = Math.min(r, n)
      if (e === t) return o
      let a = 0
      let i = 1
      for (;;) {
        const s = e.substring(o - i)
        const l = t.indexOf(s)
        if (l === -1) return a
        ;((i += l),
          (l === 0 || e.substring(o - i) === t.substring(0, i)) &&
            ((a = i), i++))
      }
    }
    C(js, 'diff_commonOverlap_')
    function af(e) {
      let t = !1
      const r = []
      let n = 0
      let o = null
      let a = 0
      let i = 0
      let s = 0
      let l = 0
      let u = 0
      for (; a < e.length; )
        (e[a][0] === Se
          ? ((r[n++] = a), (i = l), (s = u), (l = 0), (u = 0), (o = e[a][1]))
          : (e[a][0] === Le ? (l += e[a][1].length) : (u += e[a][1].length),
            o &&
              o.length <= Math.max(i, s) &&
              o.length <= Math.max(l, u) &&
              (e.splice(r[n - 1], 0, new xe(Ue, o)),
              (e[r[n - 1] + 1][0] = Le),
              n--,
              n--,
              (a = n > 0 ? r[n - 1] : -1),
              (i = 0),
              (s = 0),
              (l = 0),
              (u = 0),
              (o = null),
              (t = !0))),
          a++)
      for (t && ml(e), sf(e), a = 1; a < e.length; ) {
        if (e[a - 1][0] === Ue && e[a][0] === Le) {
          const d = e[a - 1][1]
          const m = e[a][1]
          const p = js(d, m)
          const f = js(m, d)
          ;(p >= f
            ? (p >= d.length / 2 || p >= m.length / 2) &&
              (e.splice(a, 0, new xe(Se, m.substring(0, p))),
              (e[a - 1][1] = d.substring(0, d.length - p)),
              (e[a + 1][1] = m.substring(p)),
              a++)
            : (f >= d.length / 2 || f >= m.length / 2) &&
              (e.splice(a, 0, new xe(Se, d.substring(0, f))),
              (e[a - 1][0] = Le),
              (e[a - 1][1] = m.substring(0, m.length - f)),
              (e[a + 1][0] = Ue),
              (e[a + 1][1] = d.substring(f)),
              a++),
            a++)
        }
        a++
      }
    }
    C(af, 'diff_cleanupSemantic')
    const $m = /[^a-z0-9]/i
    const qm = /\s/
    const Um = /[\r\n]/
    const Nx = /\n\r?\n$/
    const Lx = /^\r?\n\r?\n/
    function sf(e) {
      let t = 1
      for (; t < e.length - 1; ) {
        if (e[t - 1][0] === Se && e[t + 1][0] === Se) {
          let r = e[t - 1][1]
          let n = e[t][1]
          let o = e[t + 1][1]
          const a = pl(r, n)
          if (a) {
            const d = n.substring(n.length - a)
            ;((r = r.substring(0, r.length - a)),
              (n = d + n.substring(0, n.length - a)),
              (o = d + o))
          }
          let i = r
          let s = n
          let l = o
          let u = Ln(r, n) + Ln(n, o)
          for (; n.charAt(0) === o.charAt(0); ) {
            ;((r += n.charAt(0)),
              (n = n.substring(1) + o.charAt(0)),
              (o = o.substring(1)))
            const d = Ln(r, n) + Ln(n, o)
            d >= u && ((u = d), (i = r), (s = n), (l = o))
          }
          e[t - 1][1] !== i &&
            (i ? (e[t - 1][1] = i) : (e.splice(t - 1, 1), t--),
            (e[t][1] = s),
            l ? (e[t + 1][1] = l) : (e.splice(t + 1, 1), t--))
        }
        t++
      }
    }
    C(sf, 'diff_cleanupSemanticLossless')
    function ml(e) {
      e.push(new xe(Se, ''))
      let t = 0
      let r = 0
      let n = 0
      let o = ''
      let a = ''
      let i
      for (; t < e.length; )
        switch (e[t][0]) {
          case Le:
            ;(n++, (a += e[t][1]), t++)
            break
          case Ue:
            ;(r++, (o += e[t][1]), t++)
            break
          case Se:
            ;(r + n > 1
              ? (r !== 0 &&
                  n !== 0 &&
                  ((i = of(a, o)),
                  i !== 0 &&
                    (t - r - n > 0 && e[t - r - n - 1][0] === Se
                      ? (e[t - r - n - 1][1] += a.substring(0, i))
                      : (e.splice(0, 0, new xe(Se, a.substring(0, i))), t++),
                    (a = a.substring(i)),
                    (o = o.substring(i))),
                  (i = pl(a, o)),
                  i !== 0 &&
                    ((e[t][1] = a.substring(a.length - i) + e[t][1]),
                    (a = a.substring(0, a.length - i)),
                    (o = o.substring(0, o.length - i)))),
                (t -= r + n),
                e.splice(t, r + n),
                o.length && (e.splice(t, 0, new xe(Ue, o)), t++),
                a.length && (e.splice(t, 0, new xe(Le, a)), t++),
                t++)
              : t !== 0 && e[t - 1][0] === Se
                ? ((e[t - 1][1] += e[t][1]), e.splice(t, 1))
                : t++,
              (n = 0),
              (r = 0),
              (o = ''),
              (a = ''))
            break
        }
      e[e.length - 1][1] === '' && e.pop()
      let s = !1
      for (t = 1; t < e.length - 1; )
        (e[t - 1][0] === Se &&
          e[t + 1][0] === Se &&
          (e[t][1].substring(e[t][1].length - e[t - 1][1].length) ===
          e[t - 1][1]
            ? ((e[t][1] =
                e[t - 1][1] +
                e[t][1].substring(0, e[t][1].length - e[t - 1][1].length)),
              (e[t + 1][1] = e[t - 1][1] + e[t + 1][1]),
              e.splice(t - 1, 1),
              (s = !0))
            : e[t][1].substring(0, e[t + 1][1].length) === e[t + 1][1] &&
              ((e[t - 1][1] += e[t + 1][1]),
              (e[t][1] = e[t][1].substring(e[t + 1][1].length) + e[t + 1][1]),
              e.splice(t + 1, 1),
              (s = !0))),
          t++)
      s && ml(e)
    }
    C(ml, 'diff_cleanupMerge')
    function Ln(e, t) {
      if (!e || !t) return 6
      const r = e.charAt(e.length - 1)
      const n = t.charAt(0)
      const o = r.match($m)
      const a = n.match($m)
      const i = o && r.match(qm)
      const s = a && n.match(qm)
      const l = i && r.match(Um)
      const u = s && n.match(Um)
      const d = l && e.match(Nx)
      const m = u && t.match(Lx)
      return d || m
        ? 5
        : l || u
          ? 4
          : o && !i && s
            ? 3
            : i || s
              ? 2
              : o || a
                ? 1
                : 0
    }
    C(Ln, 'diff_cleanupSemanticScore_')
    const lf = 'Compared values have no visual difference.'
    const jx =
      'Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.'
    const Zo = {}
    let Hm
    function uf() {
      if (Hm) return Zo
      ;((Hm = 1),
        Object.defineProperty(Zo, '__esModule', { value: !0 }),
        (Zo.default = p))
      const e = 'diff-sequences'
      const t = 0
      const r = C((f, g, y, E, b) => {
        let x = 0
        for (; f < g && y < E && b(f, y); ) ((f += 1), (y += 1), (x += 1))
        return x
      }, 'countCommonItemsF')
      const n = C((f, g, y, E, b) => {
        let x = 0
        for (; f <= g && y <= E && b(g, E); ) ((g -= 1), (E -= 1), (x += 1))
        return x
      }, 'countCommonItemsR')
      const o = C((f, g, y, E, b, x, S) => {
        let T = 0
        let _ = -f
        let O = x[T]
        let k = O
        x[T] += r(O + 1, g, E + O - _ + 1, y, b)
        const B = f < S ? f : S
        for (T += 1, _ += 2; T <= B; T += 1, _ += 2) {
          if (T !== f && k < x[T]) O = x[T]
          else if (((O = k + 1), g <= O)) return T - 1
          ;((k = x[T]), (x[T] = O + r(O + 1, g, E + O - _ + 1, y, b)))
        }
        return S
      }, 'extendPathsF')
      const a = C((f, g, y, E, b, x, S) => {
        let T = 0
        let _ = f
        let O = x[T]
        let k = O
        x[T] -= n(g, O - 1, y, E + O - _ - 1, b)
        const B = f < S ? f : S
        for (T += 1, _ -= 2; T <= B; T += 1, _ -= 2) {
          if (T !== f && x[T] < k) O = x[T]
          else if (((O = k - 1), O < g)) return T - 1
          ;((k = x[T]), (x[T] = O - n(g, O - 1, y, E + O - _ - 1, b)))
        }
        return S
      }, 'extendPathsR')
      const i = C((f, g, y, E, b, x, S, T, _, O, k) => {
        const B = E - g
        const P = y - g
        const L = b - E - P
        const j = -L - (f - 1)
        const U = -L + (f - 1)
        let $ = t
        const v = f < T ? f : T
        for (let A = 0, D = -f; A <= v; A += 1, D += 2) {
          const N = A === 0 || (A !== f && $ < S[A])
          const F = N ? S[A] : $
          const M = N ? F : F + 1
          const q = B + M - D
          const V = r(M + 1, y, q + 1, b, x)
          const G = M + V
          if ((($ = S[A]), (S[A] = G), j <= D && D <= U)) {
            const se = (f - 1 - (D + L)) / 2
            if (se <= O && _[se] - 1 <= G) {
              const pe = B + F - (N ? D + 1 : D - 1)
              const ae = n(g, F, E, pe, x)
              const we = F - ae
              const ee = pe - ae
              const Ce = we + 1
              const Ve = ee + 1
              ;((k.nChangePreceding = f - 1),
                f - 1 === Ce + Ve - g - E
                  ? ((k.aEndPreceding = g), (k.bEndPreceding = E))
                  : ((k.aEndPreceding = Ce), (k.bEndPreceding = Ve)),
                (k.nCommonPreceding = ae),
                ae !== 0 &&
                  ((k.aCommonPreceding = Ce), (k.bCommonPreceding = Ve)),
                (k.nCommonFollowing = V),
                V !== 0 &&
                  ((k.aCommonFollowing = M + 1), (k.bCommonFollowing = q + 1)))
              const Fe = G + 1
              const lt = q + V + 1
              return (
                (k.nChangeFollowing = f - 1),
                f - 1 === y + b - Fe - lt
                  ? ((k.aStartFollowing = y), (k.bStartFollowing = b))
                  : ((k.aStartFollowing = Fe), (k.bStartFollowing = lt)),
                !0
              )
            }
          }
        }
        return !1
      }, 'extendOverlappablePathsF')
      const s = C((f, g, y, E, b, x, S, T, _, O, k) => {
        const B = b - y
        const P = y - g
        const L = b - E - P
        const j = L - f
        const U = L + f
        let $ = t
        const v = f < O ? f : O
        for (let A = 0, D = f; A <= v; A += 1, D -= 2) {
          const N = A === 0 || (A !== f && _[A] < $)
          const F = N ? _[A] : $
          const M = N ? F : F - 1
          const q = B + M - D
          const V = n(g, M - 1, E, q - 1, x)
          const G = M - V
          if ((($ = _[A]), (_[A] = G), j <= D && D <= U)) {
            const se = (f + (D - L)) / 2
            if (se <= T && G - 1 <= S[se]) {
              const pe = q - V
              if (
                ((k.nChangePreceding = f),
                f === G + pe - g - E
                  ? ((k.aEndPreceding = g), (k.bEndPreceding = E))
                  : ((k.aEndPreceding = G), (k.bEndPreceding = pe)),
                (k.nCommonPreceding = V),
                V !== 0 &&
                  ((k.aCommonPreceding = G), (k.bCommonPreceding = pe)),
                (k.nChangeFollowing = f - 1),
                f === 1)
              )
                ((k.nCommonFollowing = 0),
                  (k.aStartFollowing = y),
                  (k.bStartFollowing = b))
              else {
                const ae = B + F - (N ? D - 1 : D + 1)
                const we = r(F, y, ae, b, x)
                ;((k.nCommonFollowing = we),
                  we !== 0 &&
                    ((k.aCommonFollowing = F), (k.bCommonFollowing = ae)))
                const ee = F + we
                const Ce = ae + we
                f - 1 === y + b - ee - Ce
                  ? ((k.aStartFollowing = y), (k.bStartFollowing = b))
                  : ((k.aStartFollowing = ee), (k.bStartFollowing = Ce))
              }
              return !0
            }
          }
        }
        return !1
      }, 'extendOverlappablePathsR')
      const l = C((f, g, y, E, b, x, S, T, _) => {
        const O = E - g
        const k = b - y
        const B = y - g
        const P = b - E
        const L = P - B
        let j = B
        let U = B
        if (((S[0] = g - 1), (T[0] = y), L % 2 === 0)) {
          const $ = (f || L) / 2
          const v = (B + P) / 2
          for (let A = 1; A <= v; A += 1)
            if (((j = o(A, y, b, O, x, S, j)), A < $))
              U = a(A, g, E, k, x, T, U)
            else if (s(A, g, y, E, b, x, S, j, T, U, _)) return
        } else {
          const $ = ((f || L) + 1) / 2
          const v = (B + P + 1) / 2
          let A = 1
          for (j = o(A, y, b, O, x, S, j), A += 1; A <= v; A += 1)
            if (((U = a(A - 1, g, E, k, x, T, U)), A < $))
              j = o(A, y, b, O, x, S, j)
            else if (i(A, g, y, E, b, x, S, j, T, U, _)) return
        }
        throw new Error(
          `${e}: no overlap aStart=${g} aEnd=${y} bStart=${E} bEnd=${b}`
        )
      }, 'divide')
      const u = C((f, g, y, E, b, x, S, T, _, O) => {
        if (b - E < y - g) {
          if (((x = !x), x && S.length === 1)) {
            const { foundSubsequence: se, isCommon: pe } = S[0]
            S[1] = {
              foundSubsequence: C((ae, we, ee) => {
                se(ae, ee, we)
              }, 'foundSubsequence'),
              isCommon: C((ae, we) => pe(we, ae), 'isCommon'),
            }
          }
          const V = g
          const G = y
          ;((g = E), (y = b), (E = V), (b = G))
        }
        const { foundSubsequence: k, isCommon: B } = S[x ? 1 : 0]
        l(f, g, y, E, b, B, T, _, O)
        const {
          nChangePreceding: P,
          aEndPreceding: L,
          bEndPreceding: j,
          nCommonPreceding: U,
          aCommonPreceding: $,
          bCommonPreceding: v,
          nCommonFollowing: A,
          aCommonFollowing: D,
          bCommonFollowing: N,
          nChangeFollowing: F,
          aStartFollowing: M,
          bStartFollowing: q,
        } = O
        ;(g < L && E < j && u(P, g, L, E, j, x, S, T, _, O),
          U !== 0 && k(U, $, v),
          A !== 0 && k(A, D, N),
          M < y && q < b && u(F, M, y, q, b, x, S, T, _, O))
      }, 'findSubsequences')
      const d = C((f, g) => {
        if (typeof g !== 'number')
          throw new TypeError(`${e}: ${f} typeof ${typeof g} is not a number`)
        if (!Number.isSafeInteger(g))
          throw new RangeError(`${e}: ${f} value ${g} is not a safe integer`)
        if (g < 0)
          throw new RangeError(`${e}: ${f} value ${g} is a negative integer`)
      }, 'validateLength')
      const m = C((f, g) => {
        const y = typeof g
        if (y !== 'function')
          throw new TypeError(`${e}: ${f} typeof ${y} is not a function`)
      }, 'validateCallback')
      function p(f, g, y, E) {
        ;(d('aLength', f),
          d('bLength', g),
          m('isCommon', y),
          m('foundSubsequence', E))
        const b = r(0, f, 0, g, y)
        if ((b !== 0 && E(b, 0, 0), f !== b || g !== b)) {
          const x = b
          const S = b
          const T = n(x, f - 1, S, g - 1, y)
          const _ = f - T
          const O = g - T
          const k = b + T
          ;(f !== k &&
            g !== k &&
            u(
              0,
              x,
              _,
              S,
              O,
              !1,
              [{ foundSubsequence: E, isCommon: y }],
              [t],
              [t],
              {
                aCommonFollowing: t,
                aCommonPreceding: t,
                aEndPreceding: t,
                aStartFollowing: t,
                bCommonFollowing: t,
                bCommonPreceding: t,
                bEndPreceding: t,
                bStartFollowing: t,
                nChangeFollowing: t,
                nChangePreceding: t,
                nCommonFollowing: t,
                nCommonPreceding: t,
              }
            ),
            T !== 0 && E(T, _, O))
        }
      }
      return (C(p, 'diffSequence'), Zo)
    }
    C(uf, 'requireBuild')
    const Mx = uf()
    const cf = Qh(Mx)
    function df(e, t) {
      return e.replace(/\s+$/, r => t(r))
    }
    C(df, 'formatTrailingSpaces')
    function ga(e, t, r, n, o, a) {
      return e.length !== 0
        ? r(`${n} ${df(e, o)}`)
        : n !== ' '
          ? r(n)
          : t && a.length !== 0
            ? r(`${n} ${a}`)
            : ''
    }
    C(ga, 'printDiffLine')
    function hl(
      e,
      t,
      {
        aColor: r,
        aIndicator: n,
        changeLineTrailingSpaceColor: o,
        emptyFirstOrLastLinePlaceholder: a,
      }
    ) {
      return ga(e, t, r, n, o, a)
    }
    C(hl, 'printDeleteLine')
    function fl(
      e,
      t,
      {
        bColor: r,
        bIndicator: n,
        changeLineTrailingSpaceColor: o,
        emptyFirstOrLastLinePlaceholder: a,
      }
    ) {
      return ga(e, t, r, n, o, a)
    }
    C(fl, 'printInsertLine')
    function gl(
      e,
      t,
      {
        commonColor: r,
        commonIndicator: n,
        commonLineTrailingSpaceColor: o,
        emptyFirstOrLastLinePlaceholder: a,
      }
    ) {
      return ga(e, t, r, n, o, a)
    }
    C(gl, 'printCommonLine')
    function Ms(e, t, r, n, { patchColor: o }) {
      return o(`@@ -${e + 1},${t - e} +${r + 1},${n - r} @@`)
    }
    C(Ms, 'createPatchMark')
    function pf(e, t) {
      const r = e.length
      const n = t.contextLines
      const o = n + n
      let a = r
      let i = !1
      let s = 0
      let l = 0
      for (; l !== r; ) {
        const T = l
        for (; l !== r && e[l][0] === Se; ) l += 1
        if (T !== l)
          if (T === 0) l > n && ((a -= l - n), (i = !0))
          else if (l === r) {
            const _ = l - T
            _ > n && ((a -= _ - n), (i = !0))
          } else {
            const _ = l - T
            _ > o && ((a -= _ - o), (s += 1))
          }
        for (; l !== r && e[l][0] !== Se; ) l += 1
      }
      const u = s !== 0 || i
      s !== 0 ? (a += s + 1) : i && (a += 1)
      const d = a - 1
      const m = []
      let p = 0
      u && m.push('')
      let f = 0
      let g = 0
      let y = 0
      let E = 0
      const b = C(T => {
        const _ = m.length
        ;(m.push(gl(T, _ === 0 || _ === d, t)), (y += 1), (E += 1))
      }, 'pushCommonLine')
      const x = C(T => {
        const _ = m.length
        ;(m.push(hl(T, _ === 0 || _ === d, t)), (y += 1))
      }, 'pushDeleteLine')
      const S = C(T => {
        const _ = m.length
        ;(m.push(fl(T, _ === 0 || _ === d, t)), (E += 1))
      }, 'pushInsertLine')
      for (l = 0; l !== r; ) {
        let T = l
        for (; l !== r && e[l][0] === Se; ) l += 1
        if (T !== l)
          if (T === 0) {
            l > n && ((T = l - n), (f = T), (g = T), (y = f), (E = g))
            for (let _ = T; _ !== l; _ += 1) b(e[_][1])
          } else if (l === r) {
            const _ = l - T > n ? T + n : l
            for (let O = T; O !== _; O += 1) b(e[O][1])
          } else {
            const _ = l - T
            if (_ > o) {
              const O = T + n
              for (let B = T; B !== O; B += 1) b(e[B][1])
              ;((m[p] = Ms(f, y, g, E, t)), (p = m.length), m.push(''))
              const k = _ - o
              ;((f = y + k), (g = E + k), (y = f), (E = g))
              for (let B = l - n; B !== l; B += 1) b(e[B][1])
            } else for (let O = T; O !== l; O += 1) b(e[O][1])
          }
        for (; l !== r && e[l][0] === Ue; ) (x(e[l][1]), (l += 1))
        for (; l !== r && e[l][0] === Le; ) (S(e[l][1]), (l += 1))
      }
      return (
        u && (m[p] = Ms(f, y, g, E, t)),
        m.join(`
`)
      )
    }
    C(pf, 'joinAlignedDiffsNoExpand')
    function mf(e, t) {
      return e.map((r, n, o) => {
        const a = r[1]
        const i = n === 0 || n === o.length - 1
        switch (r[0]) {
          case Ue:
            return hl(a, i, t)
          case Le:
            return fl(a, i, t)
          default:
            return gl(a, i, t)
        }
      }).join(`
`)
    }
    C(mf, 'joinAlignedDiffsExpand')
    const Ss = C(e => e, 'noColor')
    const hf = 5
    const $x = 0
    function ff() {
      return {
        aAnnotation: 'Expected',
        aColor: Ut.green,
        aIndicator: '-',
        bAnnotation: 'Received',
        bColor: Ut.red,
        bIndicator: '+',
        changeColor: Ut.inverse,
        changeLineTrailingSpaceColor: Ss,
        commonColor: Ut.dim,
        commonIndicator: ' ',
        commonLineTrailingSpaceColor: Ss,
        compareKeys: void 0,
        contextLines: hf,
        emptyFirstOrLastLinePlaceholder: '',
        expand: !1,
        includeChangeCounts: !1,
        omitAnnotationLines: !1,
        patchColor: Ut.yellow,
        printBasicPrototype: !1,
        truncateThreshold: $x,
        truncateAnnotation: '... Diff result is truncated',
        truncateAnnotationColor: Ss,
      }
    }
    C(ff, 'getDefaultOptions')
    function gf(e) {
      return e && typeof e === 'function' ? e : void 0
    }
    C(gf, 'getCompareKeys')
    function yf(e) {
      return typeof e === 'number' && Number.isSafeInteger(e) && e >= 0 ? e : hf
    }
    C(yf, 'getContextLines')
    function ar(e = {}) {
      return {
        ...ff(),
        ...e,
        compareKeys: gf(e.compareKeys),
        contextLines: yf(e.contextLines),
      }
    }
    C(ar, 'normalizeDiffOptions')
    function wr(e) {
      return e.length === 1 && e[0].length === 0
    }
    C(wr, 'isEmptyString')
    function bf(e) {
      let t = 0
      let r = 0
      return (
        e.forEach(n => {
          switch (n[0]) {
            case Ue:
              t += 1
              break
            case Le:
              r += 1
              break
          }
        }),
        { a: t, b: r }
      )
    }
    C(bf, 'countChanges')
    function Ef(
      {
        aAnnotation: e,
        aColor: t,
        aIndicator: r,
        bAnnotation: n,
        bColor: o,
        bIndicator: a,
        includeChangeCounts: i,
        omitAnnotationLines: s,
      },
      l
    ) {
      if (s) return ''
      let u = ''
      let d = ''
      if (i) {
        const f = String(l.a)
        const g = String(l.b)
        const y = n.length - e.length
        const E = ' '.repeat(Math.max(0, y))
        const b = ' '.repeat(Math.max(0, -y))
        const x = g.length - f.length
        const S = ' '.repeat(Math.max(0, x))
        const T = ' '.repeat(Math.max(0, -x))
        ;((u = `${E}  ${r} ${S}${f}`), (d = `${b}  ${a} ${T}${g}`))
      }
      const m = `${r} ${e}${u}`
      const p = `${a} ${n}${d}`
      return `${t(m)}
${o(p)}

`
    }
    C(Ef, 'printAnnotation')
    function ya(e, t, r) {
      return (
        Ef(r, bf(e)) +
        (r.expand ? mf(e, r) : pf(e, r)) +
        (t
          ? r.truncateAnnotationColor(`
${r.truncateAnnotation}`)
          : '')
      )
    }
    C(ya, 'printDiffLines')
    function Hn(e, t, r) {
      const n = ar(r)
      const [o, a] = yl(wr(e) ? [] : e, wr(t) ? [] : t, n)
      return ya(o, a, n)
    }
    C(Hn, 'diffLinesUnified')
    function vf(e, t, r, n, o) {
      if (
        (wr(e) && wr(r) && ((e = []), (r = [])),
        wr(t) && wr(n) && ((t = []), (n = [])),
        e.length !== r.length || t.length !== n.length)
      )
        return Hn(e, t, o)
      const [a, i] = yl(r, n, o)
      let s = 0
      let l = 0
      return (
        a.forEach(u => {
          switch (u[0]) {
            case Ue:
              ;((u[1] = e[s]), (s += 1))
              break
            case Le:
              ;((u[1] = t[l]), (l += 1))
              break
            default:
              ;((u[1] = t[l]), (s += 1), (l += 1))
          }
        }),
        ya(a, i, ar(o))
      )
    }
    C(vf, 'diffLinesUnified2')
    function yl(e, t, r) {
      const n = r?.truncateThreshold ?? !1
      const o = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0)
      const a = n ? Math.min(e.length, o) : e.length
      const i = n ? Math.min(t.length, o) : t.length
      const s = a !== e.length || i !== t.length
      const l = C((p, f) => e[p] === t[f], 'isCommon')
      const u = []
      let d = 0
      let m = 0
      for (
        cf(
          a,
          i,
          l,
          C((p, f, g) => {
            for (; d !== f; d += 1) u.push(new xe(Ue, e[d]))
            for (; m !== g; m += 1) u.push(new xe(Le, t[m]))
            for (; p !== 0; p -= 1, d += 1, m += 1) u.push(new xe(Se, t[m]))
          }, 'foundSubsequence')
        );
        d !== a;
        d += 1
      )
        u.push(new xe(Ue, e[d]))
      for (; m !== i; m += 1) u.push(new xe(Le, t[m]))
      return [u, s]
    }
    C(yl, 'diffLinesRaw')
    function $s(e) {
      if (e === void 0) return 'undefined'
      if (e === null) return 'null'
      if (Array.isArray(e)) return 'array'
      if (typeof e === 'boolean') return 'boolean'
      if (typeof e === 'function') return 'function'
      if (typeof e === 'number') return 'number'
      if (typeof e === 'string') return 'string'
      if (typeof e === 'bigint') return 'bigint'
      if (typeof e === 'object') {
        if (e != null) {
          if (e.constructor === RegExp) return 'regexp'
          if (e.constructor === Map) return 'map'
          if (e.constructor === Set) return 'set'
          if (e.constructor === Date) return 'date'
        }
        return 'object'
      } else if (typeof e === 'symbol') return 'symbol'
      throw new Error(`value of unknown type: ${e}`)
    }
    C($s, 'getType')
    function qs(e) {
      return e.includes(`\r
`)
        ? `\r
`
        : `
`
    }
    C(qs, 'getNewLineSymbol')
    function Af(e, t, r) {
      const n = r?.truncateThreshold ?? !1
      const o = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0)
      let a = e.length
      let i = t.length
      if (n) {
        const p = e.includes(`
`)
        const f = t.includes(`
`)
        const g = qs(e)
        const y = qs(t)
        const E = p
          ? `${e.split(g, o).join(g)}
`
          : e
        const b = f
          ? `${t.split(y, o).join(y)}
`
          : t
        ;((a = E.length), (i = b.length))
      }
      const s = a !== e.length || i !== t.length
      const l = C((p, f) => e[p] === t[f], 'isCommon')
      let u = 0
      let d = 0
      const m = []
      return (
        cf(
          a,
          i,
          l,
          C((p, f, g) => {
            ;(u !== f && m.push(new xe(Ue, e.slice(u, f))),
              d !== g && m.push(new xe(Le, t.slice(d, g))),
              (u = f + p),
              (d = g + p),
              m.push(new xe(Se, t.slice(g, d))))
          }, 'foundSubsequence')
        ),
        u !== a && m.push(new xe(Ue, e.slice(u))),
        d !== i && m.push(new xe(Le, t.slice(d))),
        [m, s]
      )
    }
    C(Af, 'diffStrings')
    function xf(e, t, r) {
      return t.reduce(
        (n, o) =>
          n +
          (o[0] === Se ? o[1] : o[0] === e && o[1].length !== 0 ? r(o[1]) : ''),
        ''
      )
    }
    C(xf, 'concatenateRelevantDiffs')
    const wf = class {
      op
      line
      lines
      changeColor
      constructor(t, r) {
        ;((this.op = t),
          (this.line = []),
          (this.lines = []),
          (this.changeColor = r))
      }
      pushSubstring(t) {
        this.pushDiff(new xe(this.op, t))
      }
      pushLine() {
        ;(this.lines.push(
          this.line.length !== 1
            ? new xe(this.op, xf(this.op, this.line, this.changeColor))
            : this.line[0][0] === this.op
              ? this.line[0]
              : new xe(this.op, this.line[0][1])
        ),
          (this.line.length = 0))
      }
      isLineEmpty() {
        return this.line.length === 0
      }
      pushDiff(t) {
        this.line.push(t)
      }
      align(t) {
        const r = t[1]
        if (
          r.includes(`
`)
        ) {
          const n = r.split(`
`)
          const o = n.length - 1
          n.forEach((a, i) => {
            i < o
              ? (this.pushSubstring(a), this.pushLine())
              : a.length !== 0 && this.pushSubstring(a)
          })
        } else this.pushDiff(t)
      }

      moveLinesTo(t) {
        ;(this.isLineEmpty() || this.pushLine(),
          t.push(...this.lines),
          (this.lines.length = 0))
      }
    }
    C(wf, 'ChangeBuffer')
    const Vm = wf
    const Sf = class {
      deleteBuffer
      insertBuffer
      lines
      constructor(t, r) {
        ;((this.deleteBuffer = t), (this.insertBuffer = r), (this.lines = []))
      }
      pushDiffCommonLine(t) {
        this.lines.push(t)
      }
      pushDiffChangeLines(t) {
        const r = t[1].length === 0
        ;((!r || this.deleteBuffer.isLineEmpty()) &&
          this.deleteBuffer.pushDiff(t),
          (!r || this.insertBuffer.isLineEmpty()) &&
            this.insertBuffer.pushDiff(t))
      }
      flushChangeLines() {
        ;(this.deleteBuffer.moveLinesTo(this.lines),
          this.insertBuffer.moveLinesTo(this.lines))
      }
      align(t) {
        const r = t[0]
        const n = t[1]
        if (
          n.includes(`
`)
        ) {
          const o = n.split(`
`)
          const a = o.length - 1
          o.forEach((i, s) => {
            if (s === 0) {
              const l = new xe(r, i)
              this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()
                ? (this.flushChangeLines(), this.pushDiffCommonLine(l))
                : (this.pushDiffChangeLines(l), this.flushChangeLines())
            } else
              s < a
                ? this.pushDiffCommonLine(new xe(r, i))
                : i.length !== 0 && this.pushDiffChangeLines(new xe(r, i))
          })
        } else this.pushDiffChangeLines(t)
      }

      getLines() {
        return (this.flushChangeLines(), this.lines)
      }
    }
    C(Sf, 'CommonBuffer')
    const qx = Sf
    function Cf(e, t) {
      const r = new Vm(Ue, t)
      const n = new Vm(Le, t)
      const o = new qx(r, n)
      return (
        e.forEach(a => {
          switch (a[0]) {
            case Ue:
              r.align(a)
              break
            case Le:
              n.align(a)
              break
            default:
              o.align(a)
          }
        }),
        o.getLines()
      )
    }
    C(Cf, 'getAlignedDiffs')
    function Df(e, t) {
      if (t) {
        const r = e.length - 1
        return e.some(
          (n, o) =>
            n[0] === Se &&
            (o !== r ||
              n[1] !==
                `
`)
        )
      }
      return e.some(r => r[0] === Se)
    }
    C(Df, 'hasCommonDiff')
    function Tf(e, t, r) {
      if (e !== t && e.length !== 0 && t.length !== 0) {
        const n =
          e.includes(`
`) ||
          t.includes(`
`)
        const [o, a] = bl(
          n
            ? `${e}
`
            : e,
          n
            ? `${t}
`
            : t,
          !0,
          r
        )
        if (Df(o, n)) {
          const i = ar(r)
          const s = Cf(o, i.changeColor)
          return ya(s, a, i)
        }
      }
      return Hn(
        e.split(`
`),
        t.split(`
`),
        r
      )
    }
    C(Tf, 'diffStringsUnified')
    function bl(e, t, r, n) {
      const [o, a] = Af(e, t, n)
      return (r && af(o), [o, a])
    }
    C(bl, 'diffStringsRaw')
    function ia(e, t) {
      const { commonColor: r } = ar(t)
      return r(e)
    }
    C(ia, 'getCommonMessage')
    const {
      AsymmetricMatcher: Ux,
      DOMCollection: Hx,
      DOMElement: Vx,
      Immutable: zx,
      ReactElement: Gx,
      ReactTestComponent: Wx,
    } = ul
    const kf = [Wx, Gx, Vx, Hx, zx, Ux, ul.Error]
    const Us = { maxDepth: 20, plugins: kf }
    const Of = { callToJSON: !1, maxDepth: 8, plugins: kf }
    function If(e, t, r) {
      if (Object.is(e, t)) return ''
      const n = $s(e)
      let o = n
      let a = !1
      if (n === 'object' && typeof e.asymmetricMatch === 'function') {
        if (
          e.$$typeof !== Symbol.for('jest.asymmetricMatcher') ||
          typeof e.getExpectedType !== 'function'
        )
          return
        ;((o = e.getExpectedType()), (a = o === 'string'))
      }
      if (o !== $s(t)) {
        const i = function (S) {
          return S.length <= E ? S : `${S.slice(0, E)}...`
        }
        C(i, 'truncate')
        const {
          aAnnotation: s,
          aColor: l,
          aIndicator: u,
          bAnnotation: d,
          bColor: m,
          bIndicator: p,
        } = ar(r)
        const f = sa(Of, r)
        let g = Ct(e, f)
        let y = Ct(t, f)
        const E = 1e5
        ;((g = i(g)), (y = i(y)))
        const b = `${l(`${u} ${s}:`)} 
${g}`
        const x = `${m(`${p} ${d}:`)} 
${y}`
        return `${b}

${x}`
      }
      if (!a)
        switch (n) {
          case 'string':
            return Hn(
              e.split(`
`),
              t.split(`
`),
              r
            )
          case 'boolean':
          case 'number':
            return Rf(e, t, r)
          case 'map':
            return ta(Hs(e), Hs(t), r)
          case 'set':
            return ta(Vs(e), Vs(t), r)
          default:
            return ta(e, t, r)
        }
    }
    C(If, 'diff')
    function Rf(e, t, r) {
      const n = Ct(e, Us)
      const o = Ct(t, Us)
      return n === o
        ? ''
        : Hn(
            n.split(`
`),
            o.split(`
`),
            r
          )
    }
    C(Rf, 'comparePrimitive')
    function Hs(e) {
      return new Map(Array.from(e.entries()).sort())
    }
    C(Hs, 'sortMap')
    function Vs(e) {
      return new Set(Array.from(e.values()).sort())
    }
    C(Vs, 'sortSet')
    function ta(e, t, r) {
      let n
      let o = !1
      try {
        const i = sa(Us, r)
        n = zs(e, t, i, r)
      } catch {
        o = !0
      }
      const a = ia(lf, r)
      if (n === void 0 || n === a) {
        const i = sa(Of, r)
        ;((n = zs(e, t, i, r)),
          n !== a &&
            !o &&
            (n = `${ia(jx, r)}

${n}`))
      }
      return n
    }
    C(ta, 'compareObjects')
    function sa(e, t) {
      const { compareKeys: r, printBasicPrototype: n, maxDepth: o } = ar(t)
      return {
        ...e,
        compareKeys: r,
        printBasicPrototype: n,
        maxDepth: o ?? e.maxDepth,
      }
    }
    C(sa, 'getFormatOptions')
    function zs(e, t, r, n) {
      const o = { ...r, indent: 0 }
      const a = Ct(e, o)
      const i = Ct(t, o)
      if (a === i) return ia(lf, n)
      {
        const s = Ct(e, r)
        const l = Ct(t, r)
        return vf(
          s.split(`
`),
          l.split(`
`),
          a.split(`
`),
          i.split(`
`),
          n
        )
      }
    }
    C(zs, 'getObjectsDifference')
    const zm = 2e4
    function Gs(e) {
      return oa(e) === 'Object' && typeof e.asymmetricMatch === 'function'
    }
    C(Gs, 'isAsymmetricMatcher')
    function Ws(e, t) {
      const r = oa(e)
      const n = oa(t)
      return r === n && (r === 'Object' || r === 'Array')
    }
    C(Ws, 'isReplaceable')
    function Bf(e, t, r) {
      const { aAnnotation: n, bAnnotation: o } = ar(r)
      if (
        typeof t === 'string' &&
        typeof e === 'string' &&
        t.length > 0 &&
        e.length > 0 &&
        t.length <= zm &&
        e.length <= zm &&
        t !== e
      ) {
        if (
          t.includes(`
`) ||
          e.includes(`
`)
        )
          return Tf(t, e, r)
        const [u] = bl(t, e, !0)
        const d = u.some(g => g[0] === Se)
        const m = _f(n, o)
        const p = m(n) + Pf(Ys(u, Ue, d))
        const f = m(o) + Ff(Ys(u, Le, d))
        return `${p}
${f}`
      }
      const a = Ls(t, { forceWritable: !0 })
      const i = Ls(e, { forceWritable: !0 })
      const { replacedExpected: s, replacedActual: l } = El(i, a)
      return If(s, l, r)
    }
    C(Bf, 'printDiffOrStringify')
    function El(e, t, r = new WeakSet(), n = new WeakSet()) {
      return e instanceof Error &&
        t instanceof Error &&
        typeof e.cause < 'u' &&
        typeof t.cause > 'u'
        ? (delete e.cause, { replacedActual: e, replacedExpected: t })
        : Ws(e, t)
          ? r.has(e) || n.has(t)
            ? { replacedActual: e, replacedExpected: t }
            : (r.add(e),
              n.add(t),
              dl(t).forEach(o => {
                const a = t[o]
                const i = e[o]
                if (Gs(a)) a.asymmetricMatch(i) && (e[o] = a)
                else if (Gs(i)) i.asymmetricMatch(a) && (t[o] = i)
                else if (Ws(i, a)) {
                  const s = El(i, a, r, n)
                  ;((e[o] = s.replacedActual), (t[o] = s.replacedExpected))
                }
              }),
              { replacedActual: e, replacedExpected: t })
          : { replacedActual: e, replacedExpected: t }
    }
    C(El, 'replaceAsymmetricMatcher')
    function _f(...e) {
      const t = e.reduce((r, n) => (n.length > r ? n.length : r), 0)
      return r => `${r}: ${' '.repeat(t - r.length)}`
    }
    C(_f, 'getLabelPrinter')
    const Yx = '\xB7'
    function vl(e) {
      return e.replace(/\s+$/gm, t => Yx.repeat(t.length))
    }
    C(vl, 'replaceTrailingSpaces')
    function Ff(e) {
      return Ut.red(vl(an(e)))
    }
    C(Ff, 'printReceived')
    function Pf(e) {
      return Ut.green(vl(an(e)))
    }
    C(Pf, 'printExpected')
    function Ys(e, t, r) {
      return e.reduce(
        (n, o) =>
          n +
          (o[0] === Se
            ? o[1]
            : o[0] === t
              ? r
                ? Ut.inverse(o[1])
                : o[1]
              : ''),
        ''
      )
    }
    C(Ys, 'getCommonAndChangedSubstrings')
    const Kx = '@@__IMMUTABLE_RECORD__@@'
    const Xx = '@@__IMMUTABLE_ITERABLE__@@'
    function Nf(e) {
      return e && (e[Xx] || e[Kx])
    }
    C(Nf, 'isImmutable')
    const Jx = Object.getPrototypeOf({})
    function Ks(e) {
      return e instanceof Error
        ? `<unserializable>: ${e.message}`
        : typeof e === 'string'
          ? `<unserializable>: ${e}`
          : '<unserializable>'
    }
    C(Ks, 'getUnserializableMessage')
    function qt(e, t = new WeakMap()) {
      if (!e || typeof e === 'string') return e
      if (
        e instanceof Error &&
        'toJSON' in e &&
        typeof e.toJSON === 'function'
      ) {
        const r = e.toJSON()
        return (
          r &&
            r !== e &&
            typeof r === 'object' &&
            (typeof e.message === 'string' &&
              jn(() => r.message ?? (r.message = e.message)),
            typeof e.stack === 'string' &&
              jn(() => r.stack ?? (r.stack = e.stack)),
            typeof e.name === 'string' && jn(() => r.name ?? (r.name = e.name)),
            e.cause != null && jn(() => r.cause ?? (r.cause = qt(e.cause, t)))),
          qt(r, t)
        )
      }
      if (typeof e === 'function') return `Function<${e.name || 'anonymous'}>`
      if (typeof e === 'symbol') return e.toString()
      if (typeof e !== 'object') return e
      if (typeof Buffer < 'u' && e instanceof Buffer)
        return `<Buffer(${e.length}) ...>`
      if (typeof Uint8Array < 'u' && e instanceof Uint8Array)
        return `<Uint8Array(${e.length}) ...>`
      if (Nf(e)) return qt(e.toJSON(), t)
      if (
        e instanceof Promise ||
        (e.constructor && e.constructor.prototype === 'AsyncFunction')
      )
        return 'Promise'
      if (typeof Element < 'u' && e instanceof Element) return e.tagName
      if (typeof e.asymmetricMatch === 'function')
        return `${e.toString()} ${Zh(e.sample)}`
      if (typeof e.toJSON === 'function') return qt(e.toJSON(), t)
      if (t.has(e)) return t.get(e)
      if (Array.isArray(e)) {
        const r = new Array(e.length)
        return (
          t.set(e, r),
          e.forEach((n, o) => {
            try {
              r[o] = qt(n, t)
            } catch (a) {
              r[o] = Ks(a)
            }
          }),
          r
        )
      } else {
        const r = Object.create(null)
        t.set(e, r)
        let n = e
        for (; n && n !== Jx; )
          (Object.getOwnPropertyNames(n).forEach(o => {
            if (!(o in r))
              try {
                r[o] = qt(e[o], t)
              } catch (a) {
                ;(delete r[o], (r[o] = Ks(a)))
              }
          }),
            (n = Object.getPrototypeOf(n)))
        return r
      }
    }
    C(qt, 'serializeValue')
    function jn(e) {
      try {
        return e()
      } catch {}
    }
    C(jn, 'safe')
    function Lf(e) {
      return e.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, '')
    }
    C(Lf, 'normalizeErrorMessage')
    function Al(e, t, r = new WeakSet()) {
      if (!e || typeof e !== 'object') return { message: String(e) }
      const n = e
      ;((n.showDiff ||
        (n.showDiff === void 0 &&
          n.expected !== void 0 &&
          n.actual !== void 0)) &&
        (n.diff = Bf(n.actual, n.expected, { ...t, ...n.diffOptions })),
        'expected' in n &&
          typeof n.expected !== 'string' &&
          (n.expected = an(n.expected, 10)),
        'actual' in n &&
          typeof n.actual !== 'string' &&
          (n.actual = an(n.actual, 10)))
      try {
        typeof n.message === 'string' && (n.message = Lf(n.message))
      } catch {}
      try {
        !r.has(n) &&
          typeof n.cause === 'object' &&
          (r.add(n), (n.cause = Al(n.cause, t, r)))
      } catch {}
      try {
        return qt(n)
      } catch (o) {
        return qt(
          new Error(`Failed to fully serialize error: ${o?.message}
Inner error message: ${n?.message}`)
        )
      }
    }
    C(Al, 'processError')
    const Mt = {
      CALL: 'storybook/instrumenter/call',
      SYNC: 'storybook/instrumenter/sync',
      START: 'storybook/instrumenter/start',
      BACK: 'storybook/instrumenter/back',
      GOTO: 'storybook/instrumenter/goto',
      NEXT: 'storybook/instrumenter/next',
      END: 'storybook/instrumenter/end',
    }
    const Cs = globalThis.__STORYBOOK_ADDONS_PREVIEW
    var Zx = (e => (
      (e.DONE = 'done'),
      (e.ERROR = 'error'),
      (e.ACTIVE = 'active'),
      (e.WAITING = 'waiting'),
      e
    ))(Zx || {})
    const Qx = new Error(
      'This function ran after the play function completed. Did you forget to `await` it?'
    )
    const Gm = C(
      e => Object.prototype.toString.call(e) === '[object Object]',
      'isObject'
    )
    const ew = C(
      e => Object.prototype.toString.call(e) === '[object Module]',
      'isModule'
    )
    const tw = C(e => {
      if (!Gm(e) && !ew(e)) return !1
      if (e.constructor === void 0) return !0
      const t = e.constructor.prototype
      return !!Gm(t)
    }, 'isInstrumentable')
    const rw = C(e => {
      try {
        return new e.constructor()
      } catch {
        return {}
      }
    }, 'construct')
    const Ds = C(
      () => ({
        renderPhase: 'preparing',
        isDebugging: !1,
        isPlaying: !1,
        isLocked: !1,
        cursor: 0,
        calls: [],
        shadowCalls: [],
        callRefsByResult: new Map(),
        chainedCallIds: new Set(),
        ancestors: [],
        playUntil: void 0,
        resolvers: {},
        syncTimeout: void 0,
      }),
      'getInitialState'
    )
    const Wm = C((e, t = !1) => {
      const r = (t ? e.shadowCalls : e.calls).filter(o => o.retain)
      if (!r.length) return
      const n = new Map(
        Array.from(e.callRefsByResult.entries()).filter(([, o]) => o.retain)
      )
      return { cursor: r.length, calls: r, callRefsByResult: n }
    }, 'getRetainedState')
    const jf = class {
      constructor() {
        ;((this.detached = !1),
          (this.initialized = !1),
          (this.state = {}),
          (this.loadParentWindowState = C(() => {
            try {
              this.state =
                H.window?.parent
                  ?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {}
            } catch {
              this.detached = !0
            }
          }, 'loadParentWindowState')),
          (this.updateParentWindowState = C(() => {
            try {
              H.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ =
                this.state
            } catch {
              this.detached = !0
            }
          }, 'updateParentWindowState')),
          this.loadParentWindowState())
        const t = C(
          ({
            storyId: l,
            renderPhase: u,
            isPlaying: d = !0,
            isDebugging: m = !1,
          }) => {
            const p = this.getState(l)
            ;(this.setState(l, {
              ...Ds(),
              ...Wm(p, m),
              renderPhase: u || p.renderPhase,
              shadowCalls: m ? p.shadowCalls : [],
              chainedCallIds: m ? p.chainedCallIds : new Set(),
              playUntil: m ? p.playUntil : void 0,
              isPlaying: d,
              isDebugging: m,
            }),
              this.sync(l))
          },
          'resetState'
        )
        const r = C(
          l =>
            ({ storyId: u, playUntil: d }) => {
              this.getState(u).isDebugging ||
                this.setState(u, ({ calls: p }) => ({
                  calls: [],
                  shadowCalls: p.map(f => ({ ...f, status: 'waiting' })),
                  isDebugging: !0,
                }))
              const m = this.getLog(u)
              ;(this.setState(u, ({ shadowCalls: p }) => {
                if (d || !m.length) return { playUntil: d }
                const f = p.findIndex(g => g.id === m[0].callId)
                return {
                  playUntil: p
                    .slice(0, f)
                    .filter(g => g.interceptable && !g.ancestors?.length)
                    .slice(-1)[0]?.id,
                }
              }),
                l.emit(br, { storyId: u, isDebugging: !0 }))
            },
          'start'
        )
        const n = C(
          l =>
            ({ storyId: u }) => {
              const d = this.getLog(u).filter(p => !p.ancestors?.length)
              const m = d.reduceRight(
                (p, f, g) => (p >= 0 || f.status === 'waiting' ? p : g),
                -1
              )
              r(l)({ storyId: u, playUntil: d[m - 1]?.callId })
            },
          'back'
        )
        const o = C(
          l =>
            ({ storyId: u, callId: d }) => {
              const {
                calls: m,
                shadowCalls: p,
                resolvers: f,
              } = this.getState(u)
              const g = m.find(({ id: E }) => E === d)
              const y = p.find(({ id: E }) => E === d)
              if (!g && y && Object.values(f).length > 0) {
                const E = this.getLog(u).find(
                  b => b.status === 'waiting'
                )?.callId
                ;(y.id !== E && this.setState(u, { playUntil: y.id }),
                  Object.values(f).forEach(b => b()))
              } else r(l)({ storyId: u, playUntil: d })
            },
          'goto'
        )
        const a = C(
          l =>
            ({ storyId: u }) => {
              const { resolvers: d } = this.getState(u)
              if (Object.values(d).length > 0)
                Object.values(d).forEach(m => m())
              else {
                const m = this.getLog(u).find(
                  p => p.status === 'waiting'
                )?.callId
                m ? r(l)({ storyId: u, playUntil: m }) : i({ storyId: u })
              }
            },
          'next'
        )
        const i = C(({ storyId: l }) => {
          ;(this.setState(l, { playUntil: void 0, isDebugging: !1 }),
            Object.values(this.getState(l).resolvers).forEach(u => u()))
        }, 'end')
        const s = C(({ storyId: l, newPhase: u }) => {
          const { isDebugging: d } = this.getState(l)
          if (u === 'preparing' && d) return t({ storyId: l, renderPhase: u })
          if (u === 'playing')
            return t({ storyId: l, renderPhase: u, isDebugging: d })
          ;(u === 'played'
            ? this.setState(l, {
                renderPhase: u,
                isLocked: !1,
                isPlaying: !1,
                isDebugging: !1,
              })
            : u === 'errored'
              ? this.setState(l, {
                  renderPhase: u,
                  isLocked: !1,
                  isPlaying: !1,
                })
              : u === 'aborted'
                ? this.setState(l, {
                    renderPhase: u,
                    isLocked: !0,
                    isPlaying: !1,
                  })
                : this.setState(l, { renderPhase: u }),
            this.sync(l))
        }, 'renderPhaseChanged')
        Cs &&
          Cs.ready().then(() => {
            ;((this.channel = Cs.getChannel()),
              this.channel.on(br, t),
              this.channel.on(gt, s),
              this.channel.on(Ro, () => {
                this.initialized ? this.cleanup() : (this.initialized = !0)
              }),
              this.channel.on(Mt.START, r(this.channel)),
              this.channel.on(Mt.BACK, n(this.channel)),
              this.channel.on(Mt.GOTO, o(this.channel)),
              this.channel.on(Mt.NEXT, a(this.channel)),
              this.channel.on(Mt.END, i))
          })
      }
      getState(t) {
        return this.state[t] || Ds()
      }
      setState(t, r) {
        if (t) {
          const n = this.getState(t)
          const o = typeof r === 'function' ? r(n) : r
          ;((this.state = { ...this.state, [t]: { ...n, ...o } }),
            this.updateParentWindowState())
        }
      }
      cleanup() {
        this.state = Object.entries(this.state).reduce((r, [n, o]) => {
          const a = Wm(o)
          return (a && (r[n] = Object.assign(Ds(), a)), r)
        }, {})
        const t = {
          controlStates: {
            detached: this.detached,
            start: !1,
            back: !1,
            goto: !1,
            next: !1,
            end: !1,
          },
          logItems: [],
        }
        ;(this.channel?.emit(Mt.SYNC, t), this.updateParentWindowState())
      }
      getLog(t) {
        const { calls: r, shadowCalls: n } = this.getState(t)
        const o = [...n]
        r.forEach((i, s) => {
          o[s] = i
        })
        const a = new Set()
        return o.reduceRight(
          (i, s) => (
            s.args.forEach(l => {
              l?.__callId__ && a.add(l.__callId__)
            }),
            s.path.forEach(l => {
              l.__callId__ && a.add(l.__callId__)
            }),
            (s.interceptable || s.exception) &&
              !a.has(s.id) &&
              (i.unshift({
                callId: s.id,
                status: s.status,
                ancestors: s.ancestors,
              }),
              a.add(s.id)),
            i
          ),
          []
        )
      }
      instrument(t, r, n = 0) {
        if (!tw(t)) return t
        const { mutate: o = !1, path: a = [] } = r
        const i = r.getKeys ? r.getKeys(t, n) : Object.keys(t)
        return (
          (n += 1),
          i.reduce(
            (s, l) => {
              const u = Mf(t, l)
              if (typeof u?.get === 'function') {
                if (u.configurable) {
                  const m = C(() => u?.get?.bind(t)?.(), 'getter')
                  Object.defineProperty(s, l, {
                    get: C(
                      () =>
                        this.instrument(m(), { ...r, path: a.concat(l) }, n),
                      'get'
                    ),
                  })
                }
                return s
              }
              const d = t[l]
              return typeof d !== 'function'
                ? ((s[l] = this.instrument(d, { ...r, path: a.concat(l) }, n)),
                  s)
                : '__originalFn__' in d &&
                    typeof d.__originalFn__ === 'function'
                  ? ((s[l] = d), s)
                  : ((s[l] = (...m) => this.track(l, d, t, m, r)),
                    (s[l].__originalFn__ = d),
                    Object.defineProperty(s[l], 'name', {
                      value: l,
                      writable: !1,
                    }),
                    Object.keys(d).length > 0 &&
                      Object.assign(
                        s[l],
                        this.instrument(
                          { ...d },
                          { ...r, path: a.concat(l) },
                          n
                        )
                      ),
                    s)
            },
            o ? t : rw(t)
          )
        )
      }
      track(t, r, n, o, a) {
        const i =
          o?.[0]?.__storyId__ ||
          H.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId
        const { cursor: s, ancestors: l } = this.getState(i)
        this.setState(i, { cursor: s + 1 })
        const u = `${l.slice(-1)[0] || i} [${s}] ${t}`
        const { path: d = [], intercept: m = !1, retain: p = !1 } = a
        const f = typeof m === 'function' ? m(t, d) : m
        const g = {
          id: u,
          cursor: s,
          storyId: i,
          ancestors: l,
          path: d,
          method: t,
          args: o,
          interceptable: f,
          retain: p,
        }
        const y = (f && !l.length ? this.intercept : this.invoke).call(
          this,
          r,
          n,
          g,
          a
        )
        return this.instrument(y, {
          ...a,
          mutate: !0,
          path: [{ __callId__: g.id }],
        })
      }
      intercept(t, r, n, o) {
        const {
          chainedCallIds: a,
          isDebugging: i,
          playUntil: s,
        } = this.getState(n.storyId)
        const l = a.has(n.id)
        return !i || l || s
          ? (s === n.id && this.setState(n.storyId, { playUntil: void 0 }),
            this.invoke(t, r, n, o))
          : new Promise(u => {
              this.setState(n.storyId, ({ resolvers: d }) => ({
                isLocked: !1,
                resolvers: { ...d, [n.id]: u },
              }))
            }).then(
              () => (
                this.setState(n.storyId, u => {
                  const { [n.id]: d, ...m } = u.resolvers
                  return { isLocked: !0, resolvers: m }
                }),
                this.invoke(t, r, n, o)
              )
            )
      }
      invoke(t, r, n, o) {
        const { callRefsByResult: a, renderPhase: i } = this.getState(n.storyId)
        const s = 25
        const l = C((m, p, f) => {
          if (f.includes(m)) return '[Circular]'
          if (((f = [...f, m]), p > s)) return '...'
          if (a.has(m)) return a.get(m)
          if (m instanceof Array) return m.map(g => l(g, ++p, f))
          if (m instanceof Date) return { __date__: { value: m.toISOString() } }
          if (m instanceof Error) {
            const { name: g, message: y, stack: E } = m
            return { __error__: { name: g, message: y, stack: E } }
          }
          if (m instanceof RegExp) {
            const { flags: g, source: y } = m
            return { __regexp__: { flags: g, source: y } }
          }
          if (m instanceof H.window?.HTMLElement) {
            const {
              prefix: g,
              localName: y,
              id: E,
              classList: b,
              innerText: x,
            } = m
            const S = Array.from(b)
            return {
              __element__: {
                prefix: g,
                localName: y,
                id: E,
                classNames: S,
                innerText: x,
              },
            }
          }
          return typeof m === 'function'
            ? {
                __function__: {
                  name: 'getMockName' in m ? m.getMockName() : m.name,
                },
              }
            : typeof m === 'symbol'
              ? { __symbol__: { description: m.description } }
              : typeof m === 'object' &&
                  m?.constructor?.name &&
                  m?.constructor?.name !== 'Object'
                ? { __class__: { name: m.constructor.name } }
                : Object.prototype.toString.call(m) === '[object Object]'
                  ? Object.fromEntries(
                      Object.entries(m).map(([g, y]) => [g, l(y, ++p, f)])
                    )
                  : m
        }, 'serializeValues')
        const u = { ...n, args: n.args.map(m => l(m, 0, [])) }
        n.path.forEach(m => {
          m?.__callId__ &&
            this.setState(n.storyId, ({ chainedCallIds: p }) => ({
              chainedCallIds: new Set(Array.from(p).concat(m.__callId__)),
            }))
        })
        const d = C(m => {
          if (m instanceof Error) {
            const { name: p, message: f, stack: g, callId: y = n.id } = m
            const {
              showDiff: E = void 0,
              diff: b = void 0,
              actual: x = void 0,
              expected: S = void 0,
            } = m.name === 'AssertionError' ? Al(m) : m
            const T = {
              name: p,
              message: f,
              stack: g,
              callId: y,
              showDiff: E,
              diff: b,
              actual: x,
              expected: S,
            }
            if (
              (this.update({ ...u, status: 'error', exception: T }),
              this.setState(n.storyId, _ => ({
                callRefsByResult: new Map([
                  ...Array.from(_.callRefsByResult.entries()),
                  [m, { __callId__: n.id, retain: n.retain }],
                ]),
              })),
              n.ancestors?.length)
            )
              throw (
                Object.prototype.hasOwnProperty.call(m, 'callId') ||
                  Object.defineProperty(m, 'callId', { value: n.id }),
                m
              )
          }
          throw m
        }, 'handleException')
        try {
          if (i === 'played' && !n.retain) throw Qx
          const m = (
            o.getArgs ? o.getArgs(n, this.getState(n.storyId)) : n.args
          ).map(f =>
            typeof f !== 'function' || $f(f) || Object.keys(f).length
              ? f
              : (...g) => {
                  const { cursor: y, ancestors: E } = this.getState(n.storyId)
                  this.setState(n.storyId, {
                    cursor: 0,
                    ancestors: [...E, n.id],
                  })
                  const b = C(
                    () => this.setState(n.storyId, { cursor: y, ancestors: E }),
                    'restore'
                  )
                  let x = !1
                  try {
                    const S = f(...g)
                    return S instanceof Promise ? ((x = !0), S.finally(b)) : S
                  } finally {
                    x || b()
                  }
                }
          )
          const p = t.apply(r, m)
          return (
            p &&
              ['object', 'function', 'symbol'].includes(typeof p) &&
              this.setState(n.storyId, f => ({
                callRefsByResult: new Map([
                  ...Array.from(f.callRefsByResult.entries()),
                  [p, { __callId__: n.id, retain: n.retain }],
                ]),
              })),
            this.update({
              ...u,
              status: p instanceof Promise ? 'active' : 'done',
            }),
            p instanceof Promise
              ? p.then(f => (this.update({ ...u, status: 'done' }), f), d)
              : p
          )
        } catch (m) {
          return d(m)
        }
      }
      update(t) {
        ;(this.channel?.emit(Mt.CALL, t),
          this.setState(t.storyId, ({ calls: r }) => {
            const n = r
              .concat(t)
              .reduce((o, a) => Object.assign(o, { [a.id]: a }), {})
            return {
              calls: Object.values(n).sort((o, a) =>
                o.id.localeCompare(a.id, void 0, { numeric: !0 })
              ),
            }
          }),
          this.sync(t.storyId))
      }
      sync(t) {
        const r = C(() => {
          const { isLocked: n, isPlaying: o } = this.getState(t)
          const a = this.getLog(t)
          const i = a
            .filter(({ ancestors: d }) => !d.length)
            .find(d => d.status === 'waiting')?.callId
          const s = a.some(d => d.status === 'active')
          if (this.detached || n || s || a.length === 0) {
            const d = {
              controlStates: {
                detached: this.detached,
                start: !1,
                back: !1,
                goto: !1,
                next: !1,
                end: !1,
              },
              logItems: a,
            }
            this.channel?.emit(Mt.SYNC, d)
            return
          }
          const l = a.some(d => d.status === 'done' || d.status === 'error')
          const u = {
            controlStates: {
              detached: this.detached,
              start: l,
              back: l,
              goto: !0,
              next: o,
              end: o,
            },
            logItems: a,
            pausedAt: i,
          }
          this.channel?.emit(Mt.SYNC, u)
        }, 'synchronize')
        this.setState(
          t,
          ({ syncTimeout: n }) => (
            clearTimeout(n),
            { syncTimeout: setTimeout(r, 0) }
          )
        )
      }
    }
    C(jf, 'Instrumenter')
    const nw = jf
    function Vn(e, t = {}) {
      try {
        let r = !1
        let n = !1
        return (
          H.window?.location?.search?.includes('instrument=true')
            ? (r = !0)
            : H.window?.location?.search?.includes('instrument=false') &&
              (n = !0),
          (H.window?.parent === H.window && !r) || n
            ? e
            : (H.window &&
                !H.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ &&
                (H.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ =
                  new nw()),
              (H.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(
                e,
                t
              ))
        )
      } catch (r) {
        return (yt.warn(r), e)
      }
    }
    C(Vn, 'instrument')
    function Mf(e, t) {
      let r = e
      for (; r != null; ) {
        const n = Object.getOwnPropertyDescriptor(r, t)
        if (n) return n
        r = Object.getPrototypeOf(r)
      }
    }
    C(Mf, 'getPropertyDescriptor')
    function $f(e) {
      if (typeof e !== 'function') return !1
      const t = Object.getOwnPropertyDescriptor(e, 'prototype')
      return t ? !t.writable : !1
    }
    C($f, 'isClass')
    const ow = Object.create
    const Ta = Object.defineProperty
    const aw = Object.getOwnPropertyDescriptor
    const iw = Object.getOwnPropertyNames
    const sw = Object.getPrototypeOf
    const lw = Object.prototype.hasOwnProperty
    const I = (e, t) => Ta(e, 'name', { value: t, configurable: !0 })
    const uw = (e, t) => () => (
      t || e((t = { exports: {} }).exports, t),
      t.exports
    )
    const hg = (e, t) => {
      for (const r in t) Ta(e, r, { get: t[r], enumerable: !0 })
    }
    const cw = (e, t, r, n) => {
      if ((t && typeof t === 'object') || typeof t === 'function')
        for (const o of iw(t))
          !lw.call(e, o) &&
            o !== r &&
            Ta(e, o, {
              get: () => t[o],
              enumerable: !(n = aw(t, o)) || n.enumerable,
            })
      return e
    }
    const dw = (e, t, r) => (
      (r = e != null ? ow(sw(e)) : {}),
      cw(
        t || !e || !e.__esModule
          ? Ta(r, 'default', { value: e, enumerable: !0 })
          : r,
        e
      )
    )
    const pw = uw(e => {
      ;(Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.isEqual = (function () {
          const t = Object.prototype.toString
          const r = Object.getPrototypeOf
          const n = Object.getOwnPropertySymbols
            ? function (o) {
                return Object.keys(o).concat(Object.getOwnPropertySymbols(o))
              }
            : Object.keys
          return function (o, a) {
            return I(function i(s, l, u) {
              let d
              let m
              let p
              const f = t.call(s)
              const g = t.call(l)
              if (s === l) return !0
              if (s == null || l == null) return !1
              if (u.includes(s) && u.includes(l)) return !0
              if (
                (u.push(s, l),
                f != g ||
                  ((d = n(s)),
                  (m = n(l)),
                  d.length != m.length ||
                    d.some(function (y) {
                      return !i(s[y], l[y], u)
                    })))
              )
                return !1
              switch (f.slice(8, -1)) {
                case 'Symbol':
                  return s.valueOf() == l.valueOf()
                case 'Date':
                case 'Number':
                  return +s == +l || (+s != +s && +l != +l)
                case 'RegExp':
                case 'Function':
                case 'String':
                case 'Boolean':
                  return '' + s == '' + l
                case 'Set':
                case 'Map':
                  ;((d = s.entries()), (m = l.entries()))
                  do if (!i((p = d.next()).value, m.next().value, u)) return !1
                  while (!p.done)
                  return !0
                case 'ArrayBuffer':
                  ;((s = new Uint8Array(s)), (l = new Uint8Array(l)))
                case 'DataView':
                  ;((s = new Uint8Array(s.buffer)),
                    (l = new Uint8Array(l.buffer)))
                case 'Float32Array':
                case 'Float64Array':
                case 'Int8Array':
                case 'Int16Array':
                case 'Int32Array':
                case 'Uint8Array':
                case 'Uint16Array':
                case 'Uint32Array':
                case 'Uint8ClampedArray':
                case 'Arguments':
                case 'Array':
                  if (s.length != l.length) return !1
                  for (p = 0; p < s.length; p++)
                    if (
                      (p in s || p in l) &&
                      (p in s != p in l || !i(s[p], l[p], u))
                    )
                      return !1
                  return !0
                case 'Object':
                  return i(r(s), r(l), u)
                default:
                  return !1
              }
            }, 'n')(o, a, [])
          }
        })()))
    })
    function fg(e) {
      return e
        .replace(/_/g, ' ')
        .replace(/-/g, ' ')
        .replace(/\./g, ' ')
        .replace(/([^\n])([A-Z])([a-z])/g, (t, r, n, o) => `${r} ${n}${o}`)
        .replace(/([a-z])([A-Z])/g, (t, r, n) => `${r} ${n}`)
        .replace(/([a-z])([0-9])/gi, (t, r, n) => `${r} ${n}`)
        .replace(/([0-9])([a-z])/gi, (t, r, n) => `${r} ${n}`)
        .replace(/(\s|^)(\w)/g, (t, r, n) => `${r}${n.toUpperCase()}`)
        .replace(/ +/g, ' ')
        .trim()
    }
    I(fg, 'toStartCaseStr')
    const qf = dw(pw(), 1)
    const gg = I(
      e => e.map(t => typeof t < 'u').filter(Boolean).length,
      'count'
    )
    const mw = I((e, t) => {
      const { exists: r, eq: n, neq: o, truthy: a } = e
      if (gg([r, n, o, a]) > 1)
        throw new Error(
          `Invalid conditional test ${JSON.stringify({ exists: r, eq: n, neq: o })}`
        )
      if (typeof n < 'u') return (0, qf.isEqual)(t, n)
      if (typeof o < 'u') return !(0, qf.isEqual)(t, o)
      if (typeof r < 'u') {
        const i = typeof t < 'u'
        return r ? i : !i
      }
      return typeof a > 'u' || a ? !!t : !t
    }, 'testValue')
    var Zr = I((e, t, r) => {
      if (!e.if) return !0
      const { arg: n, global: o } = e.if
      if (gg([n, o]) !== 1)
        throw new Error(
          `Invalid conditional value ${JSON.stringify({ arg: n, global: o })}`
        )
      const a = n ? t[n] : r[o]
      return mw(e.if, a)
    }, 'includeConditionalArg')
    function yg() {
      const e = {
        setHandler: I(() => {}, 'setHandler'),
        send: I(() => {}, 'send'),
      }
      return new No({ transport: e })
    }
    I(yg, 'mockChannel')
    const bg = class {
      constructor() {
        ;((this.getChannel = I(() => {
          if (!this.channel) {
            const t = yg()
            return (this.setChannel(t), t)
          }
          return this.channel
        }, 'getChannel')),
          (this.ready = I(() => this.promise, 'ready')),
          (this.hasChannel = I(() => !!this.channel, 'hasChannel')),
          (this.setChannel = I(t => {
            ;((this.channel = t), this.resolve())
          }, 'setChannel')),
          (this.promise = new Promise(t => {
            this.resolve = () => t(this.getChannel())
          })))
      }
    }
    I(bg, 'AddonStore')
    const hw = bg
    const xl = '__STORYBOOK_ADDONS_PREVIEW'
    function Eg() {
      return (H[xl] || (H[xl] = new hw()), H[xl])
    }
    I(Eg, 'getAddonsStore')
    const Uf = Eg()
    const vg = class {
      constructor() {
        ;((this.hookListsMap = void 0),
          (this.mountedDecorators = void 0),
          (this.prevMountedDecorators = void 0),
          (this.currentHooks = void 0),
          (this.nextHookIndex = void 0),
          (this.currentPhase = void 0),
          (this.currentEffects = void 0),
          (this.prevEffects = void 0),
          (this.currentDecoratorName = void 0),
          (this.hasUpdates = void 0),
          (this.currentContext = void 0),
          (this.renderListener = I(t => {
            t === this.currentContext?.id &&
              (this.triggerEffects(),
              (this.currentContext = null),
              this.removeRenderListeners())
          }, 'renderListener')),
          this.init())
      }
      init() {
        ;((this.hookListsMap = new WeakMap()),
          (this.mountedDecorators = new Set()),
          (this.prevMountedDecorators = new Set()),
          (this.currentHooks = []),
          (this.nextHookIndex = 0),
          (this.currentPhase = 'NONE'),
          (this.currentEffects = []),
          (this.prevEffects = []),
          (this.currentDecoratorName = null),
          (this.hasUpdates = !1),
          (this.currentContext = null))
      }
      clean() {
        ;(this.prevEffects.forEach(t => {
          t.destroy && t.destroy()
        }),
          this.init(),
          this.removeRenderListeners())
      }
      getNextHook() {
        const t = this.currentHooks[this.nextHookIndex]
        return ((this.nextHookIndex += 1), t)
      }
      triggerEffects() {
        ;(this.prevEffects.forEach(t => {
          !this.currentEffects.includes(t) && t.destroy && t.destroy()
        }),
          this.currentEffects.forEach(t => {
            this.prevEffects.includes(t) || (t.destroy = t.create())
          }),
          (this.prevEffects = this.currentEffects),
          (this.currentEffects = []))
      }
      addRenderListeners() {
        ;(this.removeRenderListeners(),
          Uf.getChannel().on(rr, this.renderListener))
      }
      removeRenderListeners() {
        Uf.getChannel().removeListener(rr, this.renderListener)
      }
    }
    I(vg, 'HooksContext')
    const fw = vg
    function Cl(e) {
      const t = I((...r) => {
        const { hooks: n } = typeof r[0] === 'function' ? r[1] : r[0]
        const o = n.currentPhase
        const a = n.currentHooks
        const i = n.nextHookIndex
        const s = n.currentDecoratorName
        ;((n.currentDecoratorName = e.name),
          n.prevMountedDecorators.has(e)
            ? ((n.currentPhase = 'UPDATE'),
              (n.currentHooks = n.hookListsMap.get(e) || []))
            : ((n.currentPhase = 'MOUNT'),
              (n.currentHooks = []),
              n.hookListsMap.set(e, n.currentHooks),
              n.prevMountedDecorators.add(e)),
          (n.nextHookIndex = 0))
        const l = H.STORYBOOK_HOOKS_CONTEXT
        H.STORYBOOK_HOOKS_CONTEXT = n
        const u = e(...r)
        if (
          ((H.STORYBOOK_HOOKS_CONTEXT = l),
          n.currentPhase === 'UPDATE' && n.getNextHook() != null)
        )
          throw new Error(
            'Rendered fewer hooks than expected. This may be caused by an accidental early return statement.'
          )
        return (
          (n.currentPhase = o),
          (n.currentHooks = a),
          (n.nextHookIndex = i),
          (n.currentDecoratorName = s),
          u
        )
      }, 'hookified')
      return ((t.originalFn = e), t)
    }
    I(Cl, 'hookify')
    let wl = 0
    const gw = 25
    const yw = I(
      e => (t, r) => {
        const n = e(
          Cl(t),
          r.map(o => Cl(o))
        )
        return o => {
          const { hooks: a } = o
          ;((a.prevMountedDecorators ??= new Set()),
            (a.mountedDecorators = new Set([t, ...r])),
            (a.currentContext = o),
            (a.hasUpdates = !1))
          let i = n(o)
          for (wl = 1; a.hasUpdates; )
            if (
              ((a.hasUpdates = !1),
              (a.currentEffects = []),
              (i = n(o)),
              (wl += 1),
              wl > gw)
            )
              throw new Error(
                'Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.'
              )
          return (a.addRenderListeners(), i)
        }
      },
      'applyHooks'
    )
    function Aa(e) {
      if (!e || typeof e !== 'object') return !1
      const t = Object.getPrototypeOf(e)
      return t === null ||
        t === Object.prototype ||
        Object.getPrototypeOf(t) === null
        ? Object.prototype.toString.call(e) === '[object Object]'
        : !1
    }
    I(Aa, 'isPlainObject')
    function dn(e, t) {
      const r = {}
      const n = Object.keys(e)
      for (let o = 0; o < n.length; o++) {
        const a = n[o]
        const i = e[a]
        r[a] = t(i, a, e)
      }
      return r
    }
    I(dn, 'mapValues')
    function Ag(e, t) {
      const r = {}
      const n = Object.keys(e)
      for (let o = 0; o < n.length; o++) {
        const a = n[o]
        const i = e[a]
        t(i, a) && (r[a] = i)
      }
      return r
    }
    I(Ag, 'pickBy')
    function ka(e) {
      for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r]
      let n = Array.from(typeof e === 'string' ? [e] : e)
      n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, '')
      const o = n.reduce(function (s, l) {
        const u = l.match(/\n([\t ]+|(?!\s).)/g)
        return u
          ? s.concat(
              u.map(function (d) {
                let m, p
                return (p =
                  (m = d.match(/[\t ]/g)) === null || m === void 0
                    ? void 0
                    : m.length) !== null && p !== void 0
                  ? p
                  : 0
              })
            )
          : s
      }, [])
      if (o.length) {
        const a = new RegExp(
          `
[	 ]{` +
            Math.min.apply(Math, o) +
            '}',
          'g'
        )
        n = n.map(function (s) {
          return s.replace(
            a,
            `
`
          )
        })
      }
      n[0] = n[0].replace(/^\r?\n/, '')
      let i = n[0]
      return (
        t.forEach(function (s, l) {
          const u = i.match(/(?:^|\n)( *)$/)
          const d = u ? u[1] : ''
          let m = s
          ;(typeof s === 'string' &&
            s.includes(`
`) &&
            (m = String(s)
              .split(
                `
`
              )
              .map(function (p, f) {
                return f === 0 ? p : '' + d + p
              }).join(`
`)),
            (i += m + n[l + 1]))
        }),
        i
      )
    }
    I(ka, 'dedent')
    const yL = Symbol('incompatible')
    const bL = Symbol('Deeply equal')
    const xg = 'UNTARGETED'
    function wg({ args: e, argTypes: t }) {
      const r = {}
      return (
        Object.entries(e).forEach(([n, o]) => {
          const { target: a = xg } = t[n] || {}
          ;((r[a] = r[a] || {}), (r[a][n] = o))
        }),
        r
      )
    }
    I(wg, 'groupArgsByTarget')
    const bw = I(
      (e = {}) =>
        Object.entries(e).reduce(
          (t, [r, { defaultValue: n }]) => (typeof n < 'u' && (t[r] = n), t),
          {}
        ),
      'getValuesFromArgTypes'
    )
    const Ew = I(
      e => (typeof e === 'string' ? { name: e } : e),
      'normalizeType'
    )
    const vw = I(
      e => (typeof e === 'string' ? { type: e } : e),
      'normalizeControl'
    )
    const Aw = I((e, t) => {
      const { type: r, control: n, ...o } = e
      const a = { name: t, ...o }
      return (
        r && (a.type = Ew(r)),
        n ? (a.control = vw(n)) : n === !1 && (a.control = { disable: !0 }),
        a
      )
    }, 'normalizeInputType')
    const wa = I(e => dn(e, Aw), 'normalizeInputTypes')
    const oe = I(e => (Array.isArray(e) ? e : e ? [e] : []), 'normalizeArrays')
    const xw = ka`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`
    function Sg(e, t, r) {
      const n = t
      const o = typeof t === 'function' ? t : null
      const { story: a } = n
      a && (Z.debug('deprecated story', a), $r(xw))
      const i = Jo(e)
      const s =
        (typeof n !== 'function' && n.name) || n.storyName || a?.name || i
      const l = [...oe(n.decorators), ...oe(a?.decorators)]
      const u = { ...a?.parameters, ...n.parameters }
      const d = { ...a?.args, ...n.args }
      const m = { ...a?.argTypes, ...n.argTypes }
      const p = [...oe(n.loaders), ...oe(a?.loaders)]
      const f = [...oe(n.beforeEach), ...oe(a?.beforeEach)]
      const g = [...oe(n.afterEach), ...oe(a?.afterEach)]
      const { render: y, play: E, tags: b = [], globals: x = {} } = n
      const S = u.__id || Xo(r.id, i)
      return {
        moduleExport: t,
        id: S,
        name: s,
        tags: b,
        decorators: l,
        parameters: u,
        args: d,
        argTypes: wa(m),
        loaders: p,
        beforeEach: f,
        afterEach: g,
        globals: x,
        ...(y && { render: y }),
        ...(o && { userStoryFn: o }),
        ...(E && { play: E }),
      }
    }
    I(Sg, 'normalizeStory')
    function Cg(e, t = e.title, r) {
      const { id: n, argTypes: o } = e
      return {
        id: Nn(n || t),
        ...e,
        title: t,
        ...(o && { argTypes: wa(o) }),
        parameters: { fileName: r, ...e.parameters },
      }
    }
    I(Cg, 'normalizeComponentAnnotations')
    function Dg(e) {
      return e != null && Tg(e).includes('mount')
    }
    I(Dg, 'mountDestructured')
    function Tg(e) {
      const t = e.toString().match(/[^(]*\(([^)]*)/)
      if (!t) return []
      const r = Dl(t[1])
      if (!r.length) return []
      const n = r[0]
      return n.startsWith('{') && n.endsWith('}')
        ? Dl(n.slice(1, -1).replace(/\s/g, '')).map(o =>
            o.replace(/:.*|=.*/g, '')
          )
        : []
    }
    I(Tg, 'getUsedProps')
    function Dl(e) {
      const t = []
      const r = []
      let n = 0
      for (let a = 0; a < e.length; a++)
        if (e[a] === '{' || e[a] === '[') r.push(e[a] === '{' ? '}' : ']')
        else if (e[a] === r[r.length - 1]) r.pop()
        else if (!r.length && e[a] === ',') {
          const i = e.substring(n, a).trim()
          ;(i && t.push(i), (n = a + 1))
        }
      const o = e.substring(n).trim()
      return (o && t.push(o), t)
    }
    I(Dl, 'splitByComma')
    function kg(e, t, r) {
      const n = r(e)
      return o => t(n, o)
    }
    I(kg, 'decorateStory')
    function Og({
      componentId: e,
      title: t,
      kind: r,
      id: n,
      name: o,
      story: a,
      parameters: i,
      initialArgs: s,
      argTypes: l,
      ...u
    } = {}) {
      return u
    }
    I(Og, 'sanitizeStoryContextUpdate')
    function Ig(e, t) {
      const r = {}
      const n = I(
        a => i => {
          if (!r.value)
            throw new Error('Decorated function called without init')
          return ((r.value = { ...r.value, ...Og(i) }), a(r.value))
        },
        'bindWithContext'
      )
      const o = t.reduce((a, i) => kg(a, i, n), e)
      return a => ((r.value = a), o(a))
    }
    I(Ig, 'defaultDecorateStory')
    var lr = I((...e) => {
      const t = {}
      const r = e.filter(Boolean)
      const n = r.reduce(
        (o, a) => (
          Object.entries(a).forEach(([i, s]) => {
            const l = o[i]
            Array.isArray(s) || typeof l > 'u'
              ? (o[i] = s)
              : Aa(s) && Aa(l)
                ? (t[i] = !0)
                : typeof s < 'u' && (o[i] = s)
          }),
          o
        ),
        {}
      )
      return (
        Object.keys(t).forEach(o => {
          const a = r
            .filter(Boolean)
            .map(i => i[o])
            .filter(i => typeof i < 'u')
          a.every(i => Aa(i)) ? (n[o] = lr(...a)) : (n[o] = a[a.length - 1])
        }),
        n
      )
    }, 'combineParameters')
    function Rg(e, t, r) {
      const { moduleExport: n, id: o, name: a } = e || {}
      const i = Bg(e, t, r)
      const s = I(async O => {
        const k = {}
        for (const B of [oe(r.loaders), oe(t.loaders), oe(e.loaders)]) {
          if (O.abortSignal.aborted) return k
          const P = await Promise.all(B.map(L => L(O)))
          Object.assign(k, ...P)
        }
        return k
      }, 'applyLoaders')
      const l = I(async O => {
        const k = []
        for (const B of [
          ...oe(r.beforeEach),
          ...oe(t.beforeEach),
          ...oe(e.beforeEach),
        ]) {
          if (O.abortSignal.aborted) return k
          const P = await B(O)
          P && k.push(P)
        }
        return k
      }, 'applyBeforeEach')
      const u = I(async O => {
        const k = [
          ...oe(r.afterEach),
          ...oe(t.afterEach),
          ...oe(e.afterEach),
        ].reverse()
        for (const B of k) {
          if (O.abortSignal.aborted) return
          await B(O)
        }
      }, 'applyAfterEach')
      const d = I(O => O.originalStoryFn(O.args, O), 'undecoratedStoryFn')
      const { applyDecorators: m = Ig, runStep: p } = r
      const f = [
        ...oe(e?.decorators),
        ...oe(t?.decorators),
        ...oe(r?.decorators),
      ]
      const g = e?.userStoryFn || e?.render || t.render || r.render
      const y = yw(m)(d, f)
      const E = I(O => y(O), 'unboundStoryFn')
      const b = e?.play ?? t?.play
      const x = Dg(b)
      if (!g && !x) throw new Lo({ id: o })
      const S = I(
        O => async () => (await O.renderToCanvas(), O.canvas),
        'defaultMount'
      )
      const T = e.mount ?? t.mount ?? r.mount ?? S
      const _ = r.testingLibraryRender
      return {
        storyGlobals: {},
        ...i,
        moduleExport: n,
        id: o,
        name: a,
        story: a,
        originalStoryFn: g,
        undecoratedStoryFn: d,
        unboundStoryFn: E,
        applyLoaders: s,
        applyBeforeEach: l,
        applyAfterEach: u,
        playFunction: b,
        runStep: p,
        mount: T,
        testingLibraryRender: _,
        renderToCanvas: r.renderToCanvas,
        usesMount: x,
      }
    }
    I(Rg, 'prepareStory')
    function Bg(e, t, r) {
      const n = ['dev', 'test']
      const o = H.DOCS_OPTIONS?.autodocs === !0 ? ['autodocs'] : []
      const a = en(
        ...n,
        ...o,
        ...(r.tags ?? []),
        ...(t.tags ?? []),
        ...(e?.tags ?? [])
      )
      const i = lr(r.parameters, t.parameters, e?.parameters)
      const { argTypesEnhancers: s = [], argsEnhancers: l = [] } = r
      const u = lr(r.argTypes, t.argTypes, e?.argTypes)
      if (e) {
        const b = e?.userStoryFn || e?.render || t.render || r.render
        i.__isArgsStory = b && b.length > 0
      }
      const d = { ...r.args, ...t.args, ...e?.args }
      const m = { ...t.globals, ...e?.globals }
      const p = {
        componentId: t.id,
        title: t.title,
        kind: t.title,
        id: e?.id || t.id,
        name: e?.name || '__meta',
        story: e?.name || '__meta',
        component: t.component,
        subcomponents: t.subcomponents,
        tags: a,
        parameters: i,
        initialArgs: d,
        argTypes: u,
        storyGlobals: m,
      }
      p.argTypes = s.reduce((b, x) => x({ ...p, argTypes: b }), p.argTypes)
      const f = { ...d }
      p.initialArgs = [...l].reduce(
        (b, x) => ({ ...b, ...x({ ...p, initialArgs: b }) }),
        f
      )
      const { name: g, story: y, ...E } = p
      return E
    }
    I(Bg, 'preparePartialAnnotations')
    function _g(e) {
      const { args: t } = e
      let r = { ...e, allArgs: void 0, argsByTarget: void 0 }
      if (H.FEATURES?.argTypeTargetsV7) {
        const a = wg(e)
        r = { ...e, allArgs: e.args, argsByTarget: a, args: a[xg] || {} }
      }
      const n = Object.entries(r.args).reduce((a, [i, s]) => {
        if (!r.argTypes[i]?.mapping) return ((a[i] = s), a)
        const l = I(u => {
          const d = r.argTypes[i].mapping
          return d && u in d ? d[u] : u
        }, 'mappingFn')
        return ((a[i] = Array.isArray(s) ? s.map(l) : l(s)), a)
      }, {})
      const o = Object.entries(n).reduce((a, [i, s]) => {
        const l = r.argTypes[i] || {}
        return (Zr(l, n, r.globals) && (a[i] = s), a)
      }, {})
      return { ...r, unmappedArgs: t, args: o }
    }
    I(_g, 'prepareContext')
    var Tl = I((e, t, r) => {
      const n = typeof e
      switch (n) {
        case 'boolean':
        case 'string':
        case 'number':
        case 'function':
        case 'symbol':
          return { name: n }
        default:
          break
      }
      return e
        ? r.has(e)
          ? (Z.warn(ka`
        We've detected a cycle in arg '${t}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `),
            { name: 'other', value: 'cyclic object' })
          : (r.add(e),
            Array.isArray(e)
              ? {
                  name: 'array',
                  value:
                    e.length > 0
                      ? Tl(e[0], t, new Set(r))
                      : { name: 'other', value: 'unknown' },
                }
              : { name: 'object', value: dn(e, o => Tl(o, t, new Set(r))) })
        : { name: 'object', value: {} }
    }, 'inferType')
    const Fg = I(e => {
      const { id: t, argTypes: r = {}, initialArgs: n = {} } = e
      const o = dn(n, (i, s) => ({
        name: s,
        type: Tl(i, `${t}.${s}`, new Set()),
      }))
      const a = dn(r, (i, s) => ({ name: s }))
      return lr(o, a, r)
    }, 'inferArgTypes')
    Fg.secondPass = !0
    const Hf = I(
      (e, t) => (Array.isArray(t) ? t.includes(e) : e.match(t)),
      'matches'
    )
    const ww = I(
      (e, t, r) =>
        !t && !r
          ? e
          : e &&
            Ag(e, (n, o) => {
              const a = n.name || o.toString()
              return !!(!t || Hf(a, t)) && (!r || !Hf(a, r))
            }),
      'filterArgTypes'
    )
    const Sw = I((e, t, r) => {
      const { type: n, options: o } = e
      if (n) {
        if (r.color && r.color.test(t)) {
          const a = n.name
          if (a === 'string') return { control: { type: 'color' } }
          a !== 'enum' &&
            Z.warn(
              `Addon controls: Control of type color only supports string, received "${a}" instead`
            )
        }
        if (r.date && r.date.test(t)) return { control: { type: 'date' } }
        switch (n.name) {
          case 'array':
            return { control: { type: 'object' } }
          case 'boolean':
            return { control: { type: 'boolean' } }
          case 'string':
            return { control: { type: 'text' } }
          case 'number':
            return { control: { type: 'number' } }
          case 'enum': {
            const { value: a } = n
            return {
              control: { type: a?.length <= 5 ? 'radio' : 'select' },
              options: a,
            }
          }
          case 'function':
          case 'symbol':
            return null
          default:
            return { control: { type: o ? 'select' : 'object' } }
        }
      }
    }, 'inferControl')
    const Pg = I(e => {
      const {
        argTypes: t,
        parameters: {
          __isArgsStory: r,
          controls: {
            include: n = null,
            exclude: o = null,
            matchers: a = {},
          } = {},
        },
      } = e
      if (!r) return t
      const i = ww(t, n, o)
      const s = dn(i, (l, u) => l?.type && Sw(l, u.toString(), a))
      return lr(s, i)
    }, 'inferControls')
    Pg.secondPass = !0
    function Bl({
      argTypes: e,
      globalTypes: t,
      argTypesEnhancers: r,
      decorators: n,
      loaders: o,
      beforeEach: a,
      afterEach: i,
      initialGlobals: s,
      ...l
    }) {
      return {
        ...(e && { argTypes: wa(e) }),
        ...(t && { globalTypes: wa(t) }),
        decorators: oe(n),
        loaders: oe(o),
        beforeEach: oe(a),
        afterEach: oe(i),
        argTypesEnhancers: [...(r || []), Fg, Pg],
        initialGlobals: s,
        ...l,
      }
    }
    I(Bl, 'normalizeProjectAnnotations')
    const Cw = I(
      e => async () => {
        const t = []
        for (const r of e) {
          const n = await r()
          n && t.unshift(n)
        }
        return async () => {
          for (const r of t) await r()
        }
      },
      'composeBeforeAllHooks'
    )
    function Ng(e) {
      return async (t, r, n) => {
        await e.reduceRight(
          (o, a) => async () => a(t, o, n),
          async () => r(n)
        )()
      }
    }
    I(Ng, 'composeStepRunners')
    function pn(e, t) {
      return e.map(r => r.default?.[t] ?? r[t]).filter(Boolean)
    }
    I(pn, 'getField')
    function zt(e, t, r = {}) {
      return pn(e, t).reduce((n, o) => {
        const a = oe(o)
        return r.reverseFileOrder ? [...a, ...n] : [...n, ...a]
      }, [])
    }
    I(zt, 'getArrayField')
    function Gn(e, t) {
      return Object.assign({}, ...pn(e, t))
    }
    I(Gn, 'getObjectField')
    function un(e, t) {
      return pn(e, t).pop()
    }
    I(un, 'getSingletonField')
    function _l(e) {
      const t = zt(e, 'argTypesEnhancers')
      const r = pn(e, 'runStep')
      const n = zt(e, 'beforeAll')
      return {
        parameters: lr(...pn(e, 'parameters')),
        decorators: zt(e, 'decorators', {
          reverseFileOrder: !(H.FEATURES?.legacyDecoratorFileOrder ?? !1),
        }),
        args: Gn(e, 'args'),
        argsEnhancers: zt(e, 'argsEnhancers'),
        argTypes: Gn(e, 'argTypes'),
        argTypesEnhancers: [
          ...t.filter(o => !o.secondPass),
          ...t.filter(o => o.secondPass),
        ],
        initialGlobals: Gn(e, 'initialGlobals'),
        globalTypes: Gn(e, 'globalTypes'),
        loaders: zt(e, 'loaders'),
        beforeAll: Cw(n),
        beforeEach: zt(e, 'beforeEach'),
        afterEach: zt(e, 'afterEach'),
        render: un(e, 'render'),
        renderToCanvas: un(e, 'renderToCanvas'),
        applyDecorators: un(e, 'applyDecorators'),
        runStep: Ng(r),
        tags: zt(e, 'tags'),
        mount: un(e, 'mount'),
        testingLibraryRender: un(e, 'testingLibraryRender'),
      }
    }
    I(_l, 'composeConfigs')
    function Lg() {
      try {
        return (
          !!globalThis.__vitest_browser__ ||
          !!globalThis.window?.navigator?.userAgent?.match(
            /StorybookTestRunner/
          )
        )
      } catch {
        return !1
      }
    }
    I(Lg, 'isTestEnvironment')
    function jg(e = !0) {
      if (!('document' in globalThis && 'createElement' in globalThis.document))
        return () => {}
      const t = document.createElement('style')
      ;((t.textContent = `*, *:before, *:after {
    animation: none !important;
  }`),
        document.head.appendChild(t))
      const r = document.createElement('style')
      return (
        (r.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${e ? 'reverse' : 'normal'} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`),
        document.head.appendChild(r),
        document.body.clientHeight,
        document.head.removeChild(t),
        () => {
          r.parentNode?.removeChild(r)
        }
      )
    }
    I(jg, 'pauseAnimations')
    async function Mg(e) {
      if (
        !(
          'document' in globalThis &&
          'getAnimations' in globalThis.document &&
          'querySelectorAll' in globalThis.document
        )
      )
        return
      let t = !1
      await Promise.race([
        new Promise(r => {
          setTimeout(() => {
            const n = [globalThis.document, ...Fl(globalThis.document)]
            const o = I(async () => {
              if (t || e?.aborted) return
              const a = n
                .flatMap(i => i?.getAnimations?.() || [])
                .filter(i => i.playState === 'running' && !$g(i))
              a.length > 0 &&
                (await Promise.all(a.map(i => i.finished)), await o())
            }, 'checkAnimationsFinished')
            o().then(r)
          }, 100)
        }),
        new Promise(r =>
          setTimeout(() => {
            ;((t = !0), r(void 0))
          }, 5e3)
        ),
      ])
    }
    I(Mg, 'waitForAnimations')
    function Fl(e) {
      return [e, ...e.querySelectorAll('*')].reduce(
        (t, r) => (
          'shadowRoot' in r &&
            r.shadowRoot &&
            t.push(r.shadowRoot, ...Fl(r.shadowRoot)),
          t
        ),
        []
      )
    }
    I(Fl, 'getShadowRoots')
    function $g(e) {
      if (
        e instanceof CSSAnimation &&
        e.effect instanceof KeyframeEffect &&
        e.effect.target
      ) {
        const t = getComputedStyle(e.effect.target, e.effect.pseudoElement)
        const r = t.animationName?.split(', ').indexOf(e.animationName)
        return t.animationIterationCount.split(', ')[r] === 'infinite'
      }
      return !1
    }
    I($g, 'isInfiniteAnimation')
    const qg = class {
      constructor() {
        this.reports = []
      }
      async addReport(t) {
        this.reports.push(t)
      }
    }
    I(qg, 'ReporterAPI')
    const Dw = qg
    const Tw = 'ComposedStory'
    const kw = 'Unnamed Story'
    const sr = []
    function Ug(e, t, r, n, o) {
      if (e === void 0)
        throw new Error('Expected a story but received undefined.')
      t.title = t.title ?? Tw
      const a = Cg(t)
      const i = o || e.storyName || e.story?.name || e.name || kw
      const s = Sg(i, e, a)
      const l = Bl(
        _l([n ?? globalThis.globalProjectAnnotations ?? {}, r ?? {}])
      )
      const u = Rg(s, a, l)
      const d = { ...bw(l.globalTypes), ...l.initialGlobals, ...u.storyGlobals }
      const m = new Dw()
      const p = I(() => {
        const b = _g({
          hooks: new fw(),
          globals: d,
          args: { ...u.initialArgs },
          viewMode: 'story',
          reporting: m,
          loaded: {},
          abortSignal: new AbortController().signal,
          step: I((x, S) => u.runStep(x, S, b), 'step'),
          canvasElement: null,
          canvas: {},
          userEvent: {},
          globalTypes: l.globalTypes,
          ...u,
          context: null,
          mount: null,
        })
        return (
          (b.parameters.__isPortableStory = !0),
          (b.context = b),
          u.renderToCanvas &&
            (b.renderToCanvas = async () => {
              const x = await u.renderToCanvas?.(
                {
                  componentId: u.componentId,
                  title: u.title,
                  id: u.id,
                  name: u.name,
                  tags: u.tags,
                  showMain: I(() => {}, 'showMain'),
                  showError: I(S => {
                    throw new Error(`${S.title}
${S.description}`)
                  }, 'showError'),
                  showException: I(S => {
                    throw S
                  }, 'showException'),
                  forceRemount: !0,
                  storyContext: b,
                  storyFn: I(() => u.unboundStoryFn(b), 'storyFn'),
                  unboundStoryFn: u.unboundStoryFn,
                },
                b.canvasElement
              )
              x && sr.push(x)
            }),
          (b.mount = u.mount(b)),
          b
        )
      }, 'initializeContext')
      let f
      const g = I(async b => {
        const x = p()
        return (
          (x.canvasElement ??= globalThis?.document?.body),
          f && (x.loaded = f.loaded),
          Object.assign(x, b),
          u.playFunction(x)
        )
      }, 'play')
      const y = I(b => {
        const x = p()
        return (Object.assign(x, b), Hg(u, x))
      }, 'run')
      const E = u.playFunction ? g : void 0
      return Object.assign(
        I(function (b) {
          const x = p()
          return (
            f && (x.loaded = f.loaded),
            (x.args = { ...x.initialArgs, ...b }),
            u.unboundStoryFn(x)
          )
        }, 'storyFn'),
        {
          id: u.id,
          storyName: i,
          load: I(async () => {
            for (const x of [...sr].reverse()) await x()
            sr.length = 0
            const b = p()
            ;((b.loaded = await u.applyLoaders(b)),
              sr.push(...(await u.applyBeforeEach(b)).filter(Boolean)),
              (f = b))
          }, 'load'),
          globals: d,
          args: u.initialArgs,
          parameters: u.parameters,
          argTypes: u.argTypes,
          play: E,
          run: y,
          reporting: m,
          tags: u.tags,
        }
      )
    }
    I(Ug, 'composeStory')
    async function Hg(e, t) {
      for (const a of [...sr].reverse()) await a()
      if (((sr.length = 0), !t.canvasElement)) {
        const a = document.createElement('div')
        ;(globalThis?.document?.body?.appendChild(a),
          (t.canvasElement = a),
          sr.push(() => {
            globalThis?.document?.body?.contains(a) &&
              globalThis?.document?.body?.removeChild(a)
          }))
      }
      if (((t.loaded = await e.applyLoaders(t)), t.abortSignal.aborted)) return
      sr.push(...(await e.applyBeforeEach(t)).filter(Boolean))
      const r = e.playFunction
      const n = e.usesMount
      if ((n || (await t.mount()), t.abortSignal.aborted)) return
      r &&
        (n ||
          (t.mount = async () => {
            throw new qr({ playFunction: r.toString() })
          }),
        await r(t))
      let o
      ;(Lg() ? (o = jg()) : await Mg(t.abortSignal),
        await e.applyAfterEach(t),
        await o?.())
    }
    I(Hg, 'runStory')
    const Ow = !1
    const Sl = 'Invariant failed'
    function Sa(e, t) {
      if (!e) {
        if (Ow) throw new Error(Sl)
        const r = typeof t === 'function' ? t() : t
        const n = r ? ''.concat(Sl, ': ').concat(r) : Sl
        throw new Error(n)
      }
    }
    I(Sa, 'invariant')
    const Vg = {}
    hg(Vg, { argsEnhancers: () => Nw })
    const Pl = 'storybook/actions'
    const ML = `${Pl}/panel`
    const Iw = `${Pl}/action-event`
    const $L = `${Pl}/action-clear`
    const Rw = { depth: 10, clearOnStoryChange: !0, limit: 50 }
    var zg = I((e, t) => {
      const r = Object.getPrototypeOf(e)
      return !r || t(r) ? r : zg(r, t)
    }, 'findProto')
    const Bw = I(
      e =>
        !!(
          typeof e === 'object' &&
          e &&
          zg(e, t => /^Synthetic(?:Base)?Event$/.test(t.constructor.name)) &&
          typeof e.persist === 'function'
        ),
      'isReactSyntheticEvent'
    )
    const _w = I(e => {
      if (Bw(e)) {
        const t = Object.create(
          e.constructor.prototype,
          Object.getOwnPropertyDescriptors(e)
        )
        t.persist()
        const r = Object.getOwnPropertyDescriptor(t, 'view')
        const n = r?.value
        return (
          typeof n === 'object' &&
            n?.constructor.name === 'Window' &&
            Object.defineProperty(t, 'view', {
              ...r,
              value: Object.create(n.constructor.prototype),
            }),
          t
        )
      }
      return e
    }, 'serializeArg')
    function Oa(e, t = {}) {
      const r = { ...Rw, ...t }
      const n = I(function (...o) {
        if (t.implicit) {
          const m = (
            '__STORYBOOK_PREVIEW__' in H ? H.__STORYBOOK_PREVIEW__ : void 0
          )?.storyRenders.find(
            p => p.phase === 'playing' || p.phase === 'rendering'
          )
          if (m) {
            const p = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8
            const f = new Sd({ phase: m.phase, name: e, deprecated: p })
            if (p) console.warn(f)
            else throw f
          }
        }
        const a = ut.getChannel()
        const i =
          Date.now().toString(36) + Math.random().toString(36).substring(2)
        const s = 5
        const l = o.map(_w)
        const u = o.length > 1 ? l : l[0]
        const d = {
          id: i,
          count: 0,
          data: { name: e, args: u },
          options: { ...r, maxDepth: s + (r.depth || 3) },
        }
        a.emit(Iw, d)
      }, 'actionHandler')
      return ((n.isAction = !0), (n.implicit = t.implicit), n)
    }
    I(Oa, 'action')
    const Gg = I((e, t) => typeof t[e] > 'u' && !(e in t), 'isInInitialArgs')
    const Fw = I(e => {
      const {
        initialArgs: t,
        argTypes: r,
        id: n,
        parameters: { actions: o },
      } = e
      if (!o || o.disable || !o.argTypesRegex || !r) return {}
      const a = new RegExp(o.argTypesRegex)
      return Object.entries(r)
        .filter(([i]) => !!a.test(i))
        .reduce(
          (i, [s, l]) => (
            Gg(s, t) && (i[s] = Oa(s, { implicit: !0, id: n })),
            i
          ),
          {}
        )
    }, 'inferActionsFromArgTypesRegex')
    const Pw = I(e => {
      const {
        initialArgs: t,
        argTypes: r,
        parameters: { actions: n },
      } = e
      return n?.disable || !r
        ? {}
        : Object.entries(r)
            .filter(([o, a]) => !!a.action)
            .reduce(
              (o, [a, i]) => (
                Gg(a, t) &&
                  (o[a] = Oa(typeof i.action === 'string' ? i.action : a)),
                o
              ),
              {}
            )
    }, 'addActionsFromArgTypes')
    var Nw = [Pw, Fw]
    const Wg = {}
    hg(Wg, { loaders: () => jw })
    let Vf = !1
    const Lw = I(e => {
      const { parameters: t } = e
      t?.actions?.disable ||
        Vf ||
        (vm((r, n) => {
          const o = r.getMockName()
          o !== 'spy' &&
            (!/^next\/.*::/.test(o) ||
              [
                'next/router::useRouter()',
                'next/navigation::useRouter()',
                'next/navigation::redirect',
                'next/cache::',
                'next/headers::cookies().set',
                'next/headers::cookies().delete',
                'next/headers::headers().set',
                'next/headers::headers().delete',
              ].some(a => o.startsWith(a))) &&
            Oa(o)(n)
        }),
        (Vf = !0))
    }, 'logActionsWhenMockCalled')
    var jw = [Lw]
    const zf = I(() => ({ ...Vg, ...Wg }), 'default')
    const Mw = 'storybook/background'
    const Ca = 'backgrounds'
    const HL = { UPDATE: `${Mw}/update` }
    const $w = {
      light: { name: 'light', value: '#F8F8F8' },
      dark: { name: 'dark', value: '#333' },
    }
    const { document: Dt } = globalThis
    const qw = I(
      () =>
        globalThis?.matchMedia
          ? !!globalThis.matchMedia('(prefers-reduced-motion: reduce)')?.matches
          : !1,
      'isReduceMotionEnabled'
    )
    const Gf = I(e => {
      ;(Array.isArray(e) ? e : [e]).forEach(Uw)
    }, 'clearStyles')
    var Uw = I(e => {
      if (!Dt) return
      const t = Dt.getElementById(e)
      t && t.parentElement && t.parentElement.removeChild(t)
    }, 'clearStyle')
    const Hw = I((e, t) => {
      if (!Dt) return
      const r = Dt.getElementById(e)
      if (r) r.innerHTML !== t && (r.innerHTML = t)
      else {
        const n = Dt.createElement('style')
        ;(n.setAttribute('id', e), (n.innerHTML = t), Dt.head.appendChild(n))
      }
    }, 'addGridStyle')
    const Vw = I((e, t, r) => {
      if (!Dt) return
      const n = Dt.getElementById(e)
      if (n) n.innerHTML !== t && (n.innerHTML = t)
      else {
        const o = Dt.createElement('style')
        ;(o.setAttribute('id', e), (o.innerHTML = t))
        const a = `addon-backgrounds-grid${r ? `-docs-${r}` : ''}`
        const i = Dt.getElementById(a)
        i ? i.parentElement?.insertBefore(o, i) : Dt.head.appendChild(o)
      }
    }, 'addBackgroundStyle')
    const zw = { cellSize: 100, cellAmount: 10, opacity: 0.8 }
    const Wf = 'addon-backgrounds'
    const Yf = 'addon-backgrounds-grid'
    const Gw = qw() ? '' : 'transition: background-color 0.3s;'
    const Ww = I((e, t) => {
      const { globals: r = {}, parameters: n = {}, viewMode: o, id: a } = t
      const { options: i = $w, disable: s, grid: l = zw } = n[Ca] || {}
      const u = r[Ca] || {}
      const d = typeof u === 'string' ? u : u?.value
      const m = d ? i[d] : void 0
      const p = typeof m === 'string' ? m : m?.value || 'transparent'
      const f = typeof u === 'string' ? !1 : u.grid || !1
      const g = !!m && !s
      const y = o === 'docs' ? `#anchor--${a} .docs-story` : '.sb-show-main'
      const E = o === 'docs' ? `#anchor--${a} .docs-story` : '.sb-show-main'
      const b = n.layout === void 0 || n.layout === 'padded'
      const x = o === 'docs' ? 20 : b ? 16 : 0
      const {
        cellAmount: S,
        cellSize: T,
        opacity: _,
        offsetX: O = x,
        offsetY: k = x,
      } = l
      const B = o === 'docs' ? `${Wf}-docs-${a}` : `${Wf}-color`
      const P = o === 'docs' ? a : null
      Bt(() => {
        const j = `
    ${y} {
      background: ${p} !important;
      ${Gw}
      }`
        if (!g) {
          Gf(B)
          return
        }
        Vw(B, j, P)
      }, [y, B, P, g, p])
      const L = o === 'docs' ? `${Yf}-docs-${a}` : `${Yf}`
      return (
        Bt(() => {
          if (!f) {
            Gf(L)
            return
          }
          const j = [
            `${T * S}px ${T * S}px`,
            `${T * S}px ${T * S}px`,
            `${T}px ${T}px`,
            `${T}px ${T}px`,
          ].join(', ')
          const U = `
        ${E} {
          background-size: ${j} !important;
          background-position: ${O}px ${k}px, ${O}px ${k}px, ${O}px ${k}px, ${O}px ${k}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${_}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${_}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${_ / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${_ / 2}) 1px, transparent 1px) !important;
        }
      `
          Hw(L, U)
        }, [S, T, E, L, f, O, k, _]),
        e()
      )
    }, 'withBackgroundAndGrid')
    const Yw = globalThis.FEATURES?.backgrounds ? [Ww] : []
    const Kw = {
      [Ca]: {
        grid: { cellSize: 20, opacity: 0.5, cellAmount: 5 },
        disable: !1,
      },
    }
    const Xw = { [Ca]: { value: void 0, grid: !1 } }
    const Kf = I(
      () => ({ decorators: Yw, parameters: Kw, initialGlobals: Xw }),
      'default'
    )
    const { step: Jw } = Vn(
      { step: I(async (e, t, r) => t(r), 'step') },
      { intercept: !0 }
    )
    const Xf = I(
      () => ({ parameters: { throwPlayFunctionExceptions: !1 }, runStep: Jw }),
      'default'
    )
    const Ia = 'storybook/highlight'
    const Zw = `${Ia}/add`
    const Qw = `${Ia}/remove`
    const eS = `${Ia}/reset`
    const tS = `${Ia}/scroll-into-view`
    const Jf = 2147483647
    const ir = 28
    const Zf = {
      chevronLeft: [
        'M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z',
      ],
      chevronRight: [
        'M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z',
      ],
      info: [
        'M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z',
        'M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z',
      ],
      shareAlt: [
        'M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z',
        'M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z',
      ],
    }
    const rS = 'svg,path,rect,circle,line,polyline,polygon,ellipse,text'.split(
      ','
    )
    const Oe = I((e, t = {}, r) => {
      const n = rS.includes(e)
        ? document.createElementNS('http://www.w3.org/2000/svg', e)
        : document.createElement(e)
      return (
        Object.entries(t).forEach(([o, a]) => {
          ;/[A-Z]/.test(o)
            ? (o === 'onClick' &&
                (n.addEventListener('click', a),
                n.addEventListener('keydown', i => {
                  ;(i.key === 'Enter' || i.key === ' ') &&
                    (i.preventDefault(), a())
                })),
              o === 'onMouseEnter' && n.addEventListener('mouseenter', a),
              o === 'onMouseLeave' && n.addEventListener('mouseleave', a))
            : n.setAttribute(o, a)
        }),
        r?.forEach(o => {
          if (!(o == null || o === !1))
            try {
              n.appendChild(o)
            } catch {
              n.appendChild(document.createTextNode(String(o)))
            }
        }),
        n
      )
    }, 'createElement')
    const ba = I(
      e =>
        Zf[e] &&
        Oe(
          'svg',
          {
            width: '14',
            height: '14',
            viewBox: '0 0 14 14',
            xmlns: 'http://www.w3.org/2000/svg',
          },
          Zf[e].map(t =>
            Oe('path', {
              fill: 'currentColor',
              'fill-rule': 'evenodd',
              'clip-rule': 'evenodd',
              d: t,
            })
          )
        ),
      'createIcon'
    )
    const nS = I(e => {
      if ('elements' in e) {
        const { elements: n, color: o, style: a } = e
        return {
          id: void 0,
          priority: 0,
          selectors: n,
          styles: {
            outline: `2px ${a} ${o}`,
            outlineOffset: '2px',
            boxShadow: '0 0 0 6px rgba(255,255,255,0.6)',
          },
          menu: void 0,
        }
      }
      const { menu: t, ...r } = e
      return {
        id: void 0,
        priority: 0,
        styles: { outline: '2px dashed #029cfd' },
        ...r,
        menu: Array.isArray(t) ? (t.every(Array.isArray) ? t : [t]) : void 0,
      }
    }, 'normalizeOptions')
    const oS = I(e => e instanceof Function, 'isFunction')
    const zn = new Map()
    const Sr = new Map()
    const Ea = new Map()
    const Vt = I(e => {
      const t = Symbol()
      return (
        Sr.set(t, []),
        zn.set(t, e),
        {
          get: I(() => zn.get(t), 'get'),
          set: I(r => {
            const n = zn.get(t)
            const o = oS(r) ? r(n) : r
            o !== n &&
              (zn.set(t, o),
              Sr.get(t)?.forEach(a => {
                ;(Ea.get(a)?.(), Ea.set(a, a(o)))
              }))
          }, 'set'),
          subscribe: I(
            r => (
              Sr.get(t)?.push(r),
              () => {
                const n = Sr.get(t)
                n &&
                  Sr.set(
                    t,
                    n.filter(o => o !== r)
                  )
              }
            ),
            'subscribe'
          ),
          teardown: I(() => {
            ;(Sr.get(t)?.forEach(r => {
              ;(Ea.get(r)?.(), Ea.delete(r))
            }),
              Sr.delete(t),
              zn.delete(t))
          }, 'teardown'),
        }
      )
    }, 'useStore')
    const Qf = I(e => {
      const t = document.getElementById('storybook-root')
      const r = new Map()
      for (const n of e) {
        const { priority: o = 0 } = n
        for (const a of n.selectors) {
          const i = [
            ...document.querySelectorAll(
              `:is(${a}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
            ),
            ...(t?.querySelectorAll(a) || []),
          ]
          for (const s of i) {
            const l = r.get(s)
            ;(!l || l.priority <= o) &&
              r.set(s, {
                ...n,
                priority: o,
                selectors: Array.from(new Set((l?.selectors || []).concat(a))),
              })
          }
        }
      }
      return r
    }, 'mapElements')
    const aS = I(
      e =>
        Array.from(e.entries())
          .map(
            ([
              t,
              {
                selectors: r,
                styles: n,
                hoverStyles: o,
                focusStyles: a,
                menu: i,
              },
            ]) => {
              const {
                top: s,
                left: l,
                width: u,
                height: d,
              } = t.getBoundingClientRect()
              const { position: m } = getComputedStyle(t)
              return {
                element: t,
                selectors: r,
                styles: n,
                hoverStyles: o,
                focusStyles: a,
                menu: i,
                top: m === 'fixed' ? s : s + window.scrollY,
                left: m === 'fixed' ? l : l + window.scrollX,
                width: u,
                height: d,
              }
            }
          )
          .sort((t, r) => r.width * r.height - t.width * t.height),
      'mapBoxes'
    )
    const eg = I((e, t) => {
      const r = e.getBoundingClientRect()
      const { x: n, y: o } = t
      return (
        r?.top &&
        r?.left &&
        n >= r.left &&
        n <= r.left + r.width &&
        o >= r.top &&
        o <= r.top + r.height
      )
    }, 'isOverMenu')
    const tg = I((e, t, r) => {
      if (!t || !r) return !1
      let { left: n, top: o, width: a, height: i } = e
      ;(i < ir && ((o = o - Math.round((ir - i) / 2)), (i = ir)),
        a < ir && ((n = n - Math.round((ir - a) / 2)), (a = ir)),
        t.style.position === 'fixed' &&
          ((n += window.scrollX), (o += window.scrollY)))
      const { x: s, y: l } = r
      return s >= n && s <= n + a && l >= o && l <= o + i
    }, 'isTargeted')
    const iS = I((e, t, r = {}) => {
      const { x: n, y: o } = t
      const { margin: a = 5, topOffset: i = 0, centered: s = !1 } = r
      const { scrollX: l, scrollY: u, innerHeight: d, innerWidth: m } = window
      const p = Math.min(
        e.style.position === 'fixed' ? o - u : o,
        d - e.clientHeight - a - i + u
      )
      const f = s ? e.clientWidth / 2 : 0
      const g =
        e.style.position === 'fixed'
          ? Math.max(Math.min(n - l, m - f - a), f + a)
          : Math.max(Math.min(n, m - f - a + l), f + a + l)
      Object.assign(e.style, {
        ...(g !== n && { left: `${g}px` }),
        ...(p !== o && { top: `${p}px` }),
      })
    }, 'keepInViewport')
    const rg = I(e => {
      window.HTMLElement.prototype.hasOwnProperty('showPopover') &&
        e.showPopover()
    }, 'showPopover')
    const sS = I(e => {
      window.HTMLElement.prototype.hasOwnProperty('showPopover') &&
        e.hidePopover()
    }, 'hidePopover')
    const lS = I(
      e => ({
        top: e.top,
        left: e.left,
        width: e.width,
        height: e.height,
        selectors: e.selectors,
        element: {
          attributes: Object.fromEntries(
            Array.from(e.element.attributes).map(t => [t.name, t.value])
          ),
          localName: e.element.localName,
          tagName: e.element.tagName,
          outerHTML: e.element.outerHTML,
        },
      }),
      'getEventDetails'
    )
    const Ee = 'storybook-highlights-menu'
    const ng = 'storybook-highlights-root'
    const uS = 'storybook-root'
    const cS = I(e => {
      if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED) return
      globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = !0
      const { document: t } = globalThis
      const r = Vt([])
      const n = Vt(new Map())
      const o = Vt([])
      const a = Vt()
      const i = Vt()
      const s = Vt([])
      const l = Vt([])
      const u = Vt()
      const d = Vt()
      let m = t.getElementById(ng)
      ;(r.subscribe(() => {
        m || ((m = Oe('div', { id: ng })), t.body.appendChild(m))
      }),
        r.subscribe(k => {
          const B = t.getElementById(uS)
          if (!B) return
          n.set(Qf(k))
          const P = new MutationObserver(() => n.set(Qf(k)))
          return (
            P.observe(B, { subtree: !0, childList: !0 }),
            () => {
              P.disconnect()
            }
          )
        }),
        n.subscribe(k => {
          const B = I(
            () => requestAnimationFrame(() => o.set(aS(k))),
            'updateBoxes'
          )
          const P = new ResizeObserver(B)
          ;(P.observe(t.body), Array.from(k.keys()).forEach(j => P.observe(j)))
          const L = Array.from(t.body.querySelectorAll('*')).filter(j => {
            const {
              overflow: U,
              overflowX: $,
              overflowY: v,
            } = window.getComputedStyle(j)
            return ['auto', 'scroll'].some(A => [U, $, v].includes(A))
          })
          return (
            L.forEach(j => j.addEventListener('scroll', B)),
            () => {
              ;(P.disconnect(),
                L.forEach(j => j.removeEventListener('scroll', B)))
            }
          )
        }),
        n.subscribe(k => {
          const B = Array.from(k.keys()).filter(
            ({ style: L }) => L.position === 'sticky'
          )
          const P = I(
            () =>
              requestAnimationFrame(() => {
                o.set(L =>
                  L.map(j => {
                    if (B.includes(j.element)) {
                      const { top: U, left: $ } =
                        j.element.getBoundingClientRect()
                      return {
                        ...j,
                        top: U + window.scrollY,
                        left: $ + window.scrollX,
                      }
                    }
                    return j
                  })
                )
              }),
            'updateBoxes'
          )
          return (
            t.addEventListener('scroll', P),
            () => t.removeEventListener('scroll', P)
          )
        }),
        n.subscribe(k => {
          s.set(B => B.filter(({ element: P }) => k.has(P)))
        }),
        s.subscribe(k => {
          k.length
            ? (d.set(B => (k.some(P => P.element === B?.element) ? B : void 0)),
              u.set(B => (k.some(P => P.element === B?.element) ? B : void 0)))
            : (d.set(void 0), u.set(void 0), a.set(void 0))
        }))
      const p = new Map(new Map())
      r.subscribe(k => {
        ;(k.forEach(({ keyframes: B }) => {
          if (B) {
            let P = p.get(B)
            ;(P ||
              ((P = t.createElement('style')),
              P.setAttribute('data-highlight', 'keyframes'),
              p.set(B, P),
              t.head.appendChild(P)),
              (P.innerHTML = B))
          }
        }),
          p.forEach((B, P) => {
            k.some(L => L.keyframes === P) || (B.remove(), p.delete(P))
          }))
      })
      const f = new Map(new Map())
      ;(o.subscribe(k => {
        ;(k.forEach(B => {
          let P = f.get(B.element)
          if (m && !P) {
            const L = {
              popover: 'manual',
              'data-highlight-dimensions': `w${B.width.toFixed(0)}h${B.height.toFixed(0)}`,
              'data-highlight-coordinates': `x${B.left.toFixed(0)}y${B.top.toFixed(0)}`,
            }
            ;((P = m.appendChild(Oe('div', L, [Oe('div')]))),
              f.set(B.element, P))
          }
        }),
          f.forEach((B, P) => {
            k.some(({ element: L }) => L === P) || (B.remove(), f.delete(P))
          }))
      }),
        o.subscribe(k => {
          const B = k.filter(L => L.menu)
          if (!B.length) return
          const P = I(L => {
            requestAnimationFrame(() => {
              const j = t.getElementById(Ee)
              const U = { x: L.pageX, y: L.pageY }
              if (j && !eg(j, U)) {
                const $ = B.filter(v => {
                  const A = f.get(v.element)
                  return tg(v, A, U)
                })
                ;(a.set($.length ? U : void 0), s.set($))
              }
            })
          }, 'onClick')
          return (
            t.addEventListener('click', P),
            () => t.removeEventListener('click', P)
          )
        }))
      const g = I(() => {
        const k = t.getElementById(Ee)
        const B = i.get()
        !B ||
          (k && eg(k, B)) ||
          l.set(P => {
            const L = o.get().filter(v => {
              const A = f.get(v.element)
              return tg(v, A, B)
            })
            const j = P.filter(v => L.includes(v))
            const U = L.filter(v => !P.includes(v))
            const $ = P.length - j.length
            return U.length || $ ? [...j, ...U] : P
          })
      }, 'updateHovered')
      ;(i.subscribe(g), o.subscribe(g))
      const y = I(() => {
        const k = d.get()
        const B = k ? [k] : s.get()
        const P = B.length === 1 ? B[0] : u.get()
        const L = a.get() !== void 0
        o.get().forEach(j => {
          const U = f.get(j.element)
          if (U) {
            const $ = P === j
            const v = L ? (P ? $ : B.includes(j)) : l.get()?.includes(j)
            ;(Object.assign(U.style, {
              animation: 'none',
              background: 'transparent',
              border: 'none',
              boxSizing: 'border-box',
              outline: 'none',
              outlineOffset: '0px',
              ...j.styles,
              ...(v ? j.hoverStyles : {}),
              ...($ ? j.focusStyles : {}),
              position:
                getComputedStyle(j.element).position === 'fixed'
                  ? 'fixed'
                  : 'absolute',
              zIndex: Jf - 10,
              top: `${j.top}px`,
              left: `${j.left}px`,
              width: `${j.width}px`,
              height: `${j.height}px`,
              margin: 0,
              padding: 0,
              cursor: j.menu && v ? 'pointer' : 'default',
              pointerEvents: j.menu ? 'auto' : 'none',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              overflow: 'visible',
            }),
              Object.assign(U.children[0].style, {
                width: '100%',
                height: '100%',
                minHeight: `${ir}px`,
                minWidth: `${ir}px`,
                boxSizing: 'content-box',
                padding: U.style.outlineWidth || '0px',
              }),
              rg(U))
          }
        })
      }, 'updateBoxStyles')
      ;(o.subscribe(y),
        s.subscribe(y),
        l.subscribe(y),
        u.subscribe(y),
        d.subscribe(y))
      const E = I(() => {
        if (!m) return
        let k = t.getElementById(Ee)
        if (k) k.innerHTML = ''
        else {
          const j = { id: Ee, popover: 'manual' }
          ;((k = m.appendChild(Oe('div', j))),
            m.appendChild(
              Oe('style', {}, [
                `
            #${Ee} {
              position: absolute;
              z-index: ${Jf};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${Ee} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${Ee} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${Ee} li {
              padding: 0 4px;
              margin: 0;
            }
            #${Ee} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${Ee} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${Ee} button:focus-visible {
              outline-color: #029CFD;
            }
            #${Ee} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${Ee} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${Ee} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${Ee} li > button:hover svg, #${Ee} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${Ee} .element-list li svg {
              display: none;
            }
            #${Ee} li.selectable svg, #${Ee} li.selected svg {
              display: block;
            }
            #${Ee} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${Ee} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${Ee} .menu-items, #${Ee} .menu-items li {
              padding: 0;
            }
            #${Ee} .menu-item {
              display: flex;
            }
            #${Ee} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `,
              ])
            ))
        }
        const B = d.get()
        const P = B ? [B] : s.get()
        if (
          (P.length &&
            ((k.style.position =
              getComputedStyle(P[0].element).position === 'fixed'
                ? 'fixed'
                : 'absolute'),
            k.appendChild(
              Oe(
                'ul',
                { class: 'element-list' },
                P.map(j => {
                  const U =
                    P.length > 1 &&
                    !!j.menu?.some(A =>
                      A.some(
                        D =>
                          !D.selectors ||
                          D.selectors.some(N => j.selectors.includes(N))
                      )
                    )
                  const $ = U
                    ? {
                        class: 'selectable',
                        onClick: I(() => d.set(j), 'onClick'),
                        onMouseEnter: I(() => u.set(j), 'onMouseEnter'),
                        onMouseLeave: I(() => u.set(void 0), 'onMouseLeave'),
                      }
                    : B
                      ? {
                          class: 'selected',
                          onClick: I(() => d.set(void 0), 'onClick'),
                        }
                      : {}
                  const v = U || B
                  return Oe('li', $, [
                    Oe(v ? 'button' : 'div', v ? { type: 'button' } : {}, [
                      B ? ba('chevronLeft') : null,
                      Oe('code', {}, [j.element.outerHTML]),
                      U ? ba('chevronRight') : null,
                    ]),
                  ])
                })
              )
            )),
          d.get() || s.get().length === 1)
        ) {
          const j = d.get() || s.get()[0]
          const U = j.menu?.filter($ =>
            $.some(
              v =>
                !v.selectors || v.selectors.some(A => j.selectors.includes(A))
            )
          )
          U?.length &&
            k.appendChild(
              Oe(
                'ul',
                { class: 'menu-list' },
                U.map($ =>
                  Oe('li', {}, [
                    Oe(
                      'ul',
                      { class: 'menu-items' },
                      $.map(
                        ({
                          id: v,
                          title: A,
                          description: D,
                          iconLeft: N,
                          iconRight: F,
                          clickEvent: M,
                        }) => {
                          const q = M && (() => e.emit(M, v, lS(j)))
                          return Oe('li', {}, [
                            Oe(
                              q ? 'button' : 'div',
                              q
                                ? {
                                    class: 'menu-item',
                                    type: 'button',
                                    onClick: q,
                                  }
                                : { class: 'menu-item' },
                              [
                                N ? ba(N) : null,
                                Oe('div', { class: 'menu-item-content' }, [
                                  Oe(D ? 'strong' : 'span', {}, [A]),
                                  D && Oe('span', {}, [D]),
                                ]),
                                F ? ba(F) : null,
                              ]
                            ),
                          ])
                        }
                      )
                    ),
                  ])
                )
              )
            )
        }
        const L = a.get()
        L
          ? (Object.assign(k.style, {
              display: 'block',
              left: `${k.style.position === 'fixed' ? L.x - window.scrollX : L.x}px`,
              top: `${k.style.position === 'fixed' ? L.y - window.scrollY : L.y}px`,
            }),
            rg(k),
            requestAnimationFrame(() =>
              iS(k, L, { topOffset: 15, centered: !0 })
            ))
          : (sS(k), Object.assign(k.style, { display: 'none' }))
      }, 'renderMenu')
      ;(s.subscribe(E), d.subscribe(E))
      const b = I(k => {
        const B = nS(k)
        r.set(P => {
          const L = B.id ? P.filter(j => j.id !== B.id) : P
          return B.selectors?.length ? [...L, B] : L
        })
      }, 'addHighlight')
      const x = I(k => {
        k && r.set(B => B.filter(P => P.id !== k))
      }, 'removeHighlight')
      const S = I(() => {
        ;(r.set([]),
          n.set(new Map()),
          o.set([]),
          a.set(void 0),
          i.set(void 0),
          s.set([]),
          l.set([]),
          u.set(void 0),
          d.set(void 0))
      }, 'resetState')
      let T
      const _ = I((k, B) => {
        const P = 'scrollIntoView-highlight'
        ;(clearTimeout(T), x(P))
        const L = t.querySelector(k)
        if (!L) {
          console.warn(`Cannot scroll into view: ${k} not found`)
          return
        }
        L.scrollIntoView({ behavior: 'smooth', block: 'center', ...B })
        const j = `kf-${Math.random().toString(36).substring(2, 15)}`
        ;(r.set(U => [
          ...U,
          {
            id: P,
            priority: 1e3,
            selectors: [k],
            styles: {
              outline: '2px solid #1EA7FD',
              outlineOffset: '-1px',
              animation: `${j} 3s linear forwards`,
            },
            keyframes: `@keyframes ${j} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`,
          },
        ]),
          (T = setTimeout(() => x(P), 3500)))
      }, 'scrollIntoView')
      const O = I(k => {
        requestAnimationFrame(() => i.set({ x: k.pageX, y: k.pageY }))
      }, 'onMouseMove')
      ;(t.body.addEventListener('mousemove', O),
        e.on(Zw, b),
        e.on(Qw, x),
        e.on(eS, S),
        e.on(tS, _),
        e.on(gt, ({ newPhase: k }) => {
          k === 'loading' && S()
        }))
    }, 'useHighlights')
    globalThis?.FEATURES?.highlight && ut?.ready && ut.ready().then(cS)
    const og = I(() => ({}), 'default')
    const xa = 'storybook/measure-addon'
    const JL = `${xa}/tool`
    const dS = 'measureEnabled'
    const ZL = {
      RESULT: `${xa}/result`,
      REQUEST: `${xa}/request`,
      CLEAR: `${xa}/clear`,
    }
    function Nl() {
      const e = H.document.documentElement
      const t = Math.max(e.scrollHeight, e.offsetHeight)
      return { width: Math.max(e.scrollWidth, e.offsetWidth), height: t }
    }
    I(Nl, 'getDocumentWidthAndHeight')
    function Yg() {
      const e = H.document.createElement('canvas')
      e.id = 'storybook-addon-measure'
      const t = e.getContext('2d')
      Sa(t != null)
      const { width: r, height: n } = Nl()
      return (
        Da(e, t, { width: r, height: n }),
        (e.style.position = 'absolute'),
        (e.style.left = '0'),
        (e.style.top = '0'),
        (e.style.zIndex = '2147483647'),
        (e.style.pointerEvents = 'none'),
        H.document.body.appendChild(e),
        { canvas: e, context: t, width: r, height: n }
      )
    }
    I(Yg, 'createCanvas')
    function Da(e, t, { width: r, height: n }) {
      ;((e.style.width = `${r}px`), (e.style.height = `${n}px`))
      const o = H.window.devicePixelRatio
      ;((e.width = Math.floor(r * o)),
        (e.height = Math.floor(n * o)),
        t.scale(o, o))
    }
    I(Da, 'setCanvasWidthAndHeight')
    let Ie = {}
    function Kg() {
      Ie.canvas || (Ie = Yg())
    }
    I(Kg, 'init')
    function Ll() {
      Ie.context && Ie.context.clearRect(0, 0, Ie.width ?? 0, Ie.height ?? 0)
    }
    I(Ll, 'clear')
    function Xg(e) {
      ;(Ll(), e(Ie.context))
    }
    I(Xg, 'draw')
    function Jg() {
      ;(Sa(Ie.canvas, 'Canvas should exist in the state.'),
        Sa(Ie.context, 'Context should exist in the state.'),
        Da(Ie.canvas, Ie.context, { width: 0, height: 0 }))
      const { width: e, height: t } = Nl()
      ;(Da(Ie.canvas, Ie.context, { width: e, height: t }),
        (Ie.width = e),
        (Ie.height = t))
    }
    I(Jg, 'rescale')
    function Zg() {
      Ie.canvas &&
        (Ll(), Ie.canvas.parentNode?.removeChild(Ie.canvas), (Ie = {}))
    }
    I(Zg, 'destroy')
    const ln = {
      margin: '#f6b26b',
      border: '#ffe599',
      padding: '#93c47d',
      content: '#6fa8dc',
      text: '#232020',
    }
    const Gt = 6
    function kl(e, { x: t, y: r, w: n, h: o, r: a }) {
      ;((t = t - n / 2),
        (r = r - o / 2),
        n < 2 * a && (a = n / 2),
        o < 2 * a && (a = o / 2),
        e.beginPath(),
        e.moveTo(t + a, r),
        e.arcTo(t + n, r, t + n, r + o, a),
        e.arcTo(t + n, r + o, t, r + o, a),
        e.arcTo(t, r + o, t, r, a),
        e.arcTo(t, r, t + n, r, a),
        e.closePath())
    }
    I(kl, 'roundedRect')
    function Qg(
      e,
      { padding: t, border: r, width: n, height: o, top: a, left: i }
    ) {
      const s = n - r.left - r.right - t.left - t.right
      const l = o - t.top - t.bottom - r.top - r.bottom
      let u = i + r.left + t.left
      let d = a + r.top + t.top
      return (
        e === 'top'
          ? (u += s / 2)
          : e === 'right'
            ? ((u += s), (d += l / 2))
            : e === 'bottom'
              ? ((u += s / 2), (d += l))
              : e === 'left'
                ? (d += l / 2)
                : e === 'center' && ((u += s / 2), (d += l / 2)),
        { x: u, y: d }
      )
    }
    I(Qg, 'positionCoordinate')
    function e2(e, t, { margin: r, border: n, padding: o }, a, i) {
      let s = I(p => 0, 'shift')
      let l = 0
      let u = 0
      const d = i ? 1 : 0.5
      const m = i ? a * 2 : 0
      return (
        e === 'padding'
          ? (s = I(p => o[p] * d + m, 'shift'))
          : e === 'border'
            ? (s = I(p => o[p] + n[p] * d + m, 'shift'))
            : e === 'margin' &&
              (s = I(p => o[p] + n[p] + r[p] * d + m, 'shift')),
        t === 'top'
          ? (u = -s('top'))
          : t === 'right'
            ? (l = s('right'))
            : t === 'bottom'
              ? (u = s('bottom'))
              : t === 'left' && (l = -s('left')),
        { offsetX: l, offsetY: u }
      )
    }
    I(e2, 'offset')
    function t2(e, t) {
      return (
        Math.abs(e.x - t.x) < Math.abs(e.w + t.w) / 2 &&
        Math.abs(e.y - t.y) < Math.abs(e.h + t.h) / 2
      )
    }
    I(t2, 'collide')
    function r2(e, t, r) {
      return (
        e === 'top'
          ? (t.y = r.y - r.h - Gt)
          : e === 'right'
            ? (t.x = r.x + r.w / 2 + Gt + t.w / 2)
            : e === 'bottom'
              ? (t.y = r.y + r.h + Gt)
              : e === 'left' && (t.x = r.x - r.w / 2 - Gt - t.w / 2),
        { x: t.x, y: t.y }
      )
    }
    I(r2, 'overlapAdjustment')
    function jl(e, t, { x: r, y: n, w: o, h: a }, i) {
      return (
        kl(e, { x: r, y: n, w: o, h: a, r: 3 }),
        (e.fillStyle = `${ln[t]}dd`),
        e.fill(),
        (e.strokeStyle = ln[t]),
        e.stroke(),
        (e.fillStyle = ln.text),
        e.fillText(i, r, n),
        kl(e, { x: r, y: n, w: o, h: a, r: 3 }),
        (e.fillStyle = `${ln[t]}dd`),
        e.fill(),
        (e.strokeStyle = ln[t]),
        e.stroke(),
        (e.fillStyle = ln.text),
        e.fillText(i, r, n),
        { x: r, y: n, w: o, h: a }
      )
    }
    I(jl, 'textWithRect')
    function Ml(e, t) {
      ;((e.font = '600 12px monospace'),
        (e.textBaseline = 'middle'),
        (e.textAlign = 'center'))
      const r = e.measureText(t)
      const n = r.actualBoundingBoxAscent + r.actualBoundingBoxDescent
      const o = r.width + Gt * 2
      const a = n + Gt * 2
      return { w: o, h: a }
    }
    I(Ml, 'configureText')
    function n2(e, t, { type: r, position: n = 'center', text: o }, a, i = !1) {
      let { x: s, y: l } = Qg(n, t)
      const { offsetX: u, offsetY: d } = e2(r, n, t, Gt + 1, i)
      ;((s += u), (l += d))
      const { w: m, h: p } = Ml(e, o)
      if (a && t2({ x: s, y: l, w: m, h: p }, a)) {
        const f = r2(n, { x: s, y: l, w: m, h: p }, a)
        ;((s = f.x), (l = f.y))
      }
      return jl(e, r, { x: s, y: l, w: m, h: p }, o)
    }
    I(n2, 'drawLabel')
    function o2(e, { w: t, h: r }) {
      const n = t * 0.5 + Gt
      const o = r * 0.5 + Gt
      return {
        offsetX: (e.x === 'left' ? -1 : 1) * n,
        offsetY: (e.y === 'top' ? -1 : 1) * o,
      }
    }
    I(o2, 'floatingOffset')
    function a2(e, t, { type: r, text: n }) {
      const { floatingAlignment: o, extremities: a } = t
      let i = a[o.x]
      let s = a[o.y]
      const { w: l, h: u } = Ml(e, n)
      const { offsetX: d, offsetY: m } = o2(o, { w: l, h: u })
      return ((i += d), (s += m), jl(e, r, { x: i, y: s, w: l, h: u }, n))
    }
    I(a2, 'drawFloatingLabel')
    function cn(e, t, r, n) {
      const o = []
      r.forEach((a, i) => {
        const s =
          n && a.position === 'center' ? a2(e, t, a) : n2(e, t, a, o[i - 1], n)
        o[i] = s
      })
    }
    I(cn, 'drawStack')
    function i2(e, t, r, n) {
      const o = r.reduce(
        (a, i) => (
          Object.prototype.hasOwnProperty.call(a, i.position) ||
            (a[i.position] = []),
          a[i.position]?.push(i),
          a
        ),
        {}
      )
      ;(o.top && cn(e, t, o.top, n),
        o.right && cn(e, t, o.right, n),
        o.bottom && cn(e, t, o.bottom, n),
        o.left && cn(e, t, o.left, n),
        o.center && cn(e, t, o.center, n))
    }
    I(i2, 'labelStacks')
    const Ra = {
      margin: '#f6b26ba8',
      border: '#ffe599a8',
      padding: '#93c47d8c',
      content: '#6fa8dca8',
    }
    const ag = 30
    function ct(e) {
      return parseInt(e.replace('px', ''), 10)
    }
    I(ct, 'pxToNumber')
    function Cr(e) {
      return Number.isInteger(e) ? e : e.toFixed(2)
    }
    I(Cr, 'round')
    function Ba(e) {
      return e.filter(t => t.text !== 0 && t.text !== '0')
    }
    I(Ba, 'filterZeroValues')
    function s2(e) {
      const t = {
        top: H.window.scrollY,
        bottom: H.window.scrollY + H.window.innerHeight,
        left: H.window.scrollX,
        right: H.window.scrollX + H.window.innerWidth,
      }
      const r = {
        top: Math.abs(t.top - e.top),
        bottom: Math.abs(t.bottom - e.bottom),
        left: Math.abs(t.left - e.left),
        right: Math.abs(t.right - e.right),
      }
      return {
        x: r.left > r.right ? 'left' : 'right',
        y: r.top > r.bottom ? 'top' : 'bottom',
      }
    }
    I(s2, 'floatingAlignment')
    function l2(e) {
      const t = H.getComputedStyle(e)
      let {
        top: r,
        left: n,
        right: o,
        bottom: a,
        width: i,
        height: s,
      } = e.getBoundingClientRect()
      const {
        marginTop: l,
        marginBottom: u,
        marginLeft: d,
        marginRight: m,
        paddingTop: p,
        paddingBottom: f,
        paddingLeft: g,
        paddingRight: y,
        borderBottomWidth: E,
        borderTopWidth: b,
        borderLeftWidth: x,
        borderRightWidth: S,
      } = t
      ;((r = r + H.window.scrollY),
        (n = n + H.window.scrollX),
        (a = a + H.window.scrollY),
        (o = o + H.window.scrollX))
      const T = { top: ct(l), bottom: ct(u), left: ct(d), right: ct(m) }
      const _ = { top: ct(p), bottom: ct(f), left: ct(g), right: ct(y) }
      const O = { top: ct(b), bottom: ct(E), left: ct(x), right: ct(S) }
      const k = {
        top: r - T.top,
        bottom: a + T.bottom,
        left: n - T.left,
        right: o + T.right,
      }
      return {
        margin: T,
        padding: _,
        border: O,
        top: r,
        left: n,
        bottom: a,
        right: o,
        width: i,
        height: s,
        extremities: k,
        floatingAlignment: s2(k),
      }
    }
    I(l2, 'measureElement')
    function u2(
      e,
      { margin: t, width: r, height: n, top: o, left: a, bottom: i, right: s }
    ) {
      const l = n + t.bottom + t.top
      ;((e.fillStyle = Ra.margin),
        e.fillRect(a, o - t.top, r, t.top),
        e.fillRect(s, o - t.top, t.right, l),
        e.fillRect(a, i, r, t.bottom),
        e.fillRect(a - t.left, o - t.top, t.left, l))
      const u = [
        { type: 'margin', text: Cr(t.top), position: 'top' },
        { type: 'margin', text: Cr(t.right), position: 'right' },
        { type: 'margin', text: Cr(t.bottom), position: 'bottom' },
        { type: 'margin', text: Cr(t.left), position: 'left' },
      ]
      return Ba(u)
    }
    I(u2, 'drawMargin')
    function c2(
      e,
      {
        padding: t,
        border: r,
        width: n,
        height: o,
        top: a,
        left: i,
        bottom: s,
        right: l,
      }
    ) {
      const u = n - r.left - r.right
      const d = o - t.top - t.bottom - r.top - r.bottom
      ;((e.fillStyle = Ra.padding),
        e.fillRect(i + r.left, a + r.top, u, t.top),
        e.fillRect(l - t.right - r.right, a + t.top + r.top, t.right, d),
        e.fillRect(i + r.left, s - t.bottom - r.bottom, u, t.bottom),
        e.fillRect(i + r.left, a + t.top + r.top, t.left, d))
      const m = [
        { type: 'padding', text: t.top, position: 'top' },
        { type: 'padding', text: t.right, position: 'right' },
        { type: 'padding', text: t.bottom, position: 'bottom' },
        { type: 'padding', text: t.left, position: 'left' },
      ]
      return Ba(m)
    }
    I(c2, 'drawPadding')
    function d2(
      e,
      { border: t, width: r, height: n, top: o, left: a, bottom: i, right: s }
    ) {
      const l = n - t.top - t.bottom
      ;((e.fillStyle = Ra.border),
        e.fillRect(a, o, r, t.top),
        e.fillRect(a, i - t.bottom, r, t.bottom),
        e.fillRect(a, o + t.top, t.left, l),
        e.fillRect(s - t.right, o + t.top, t.right, l))
      const u = [
        { type: 'border', text: t.top, position: 'top' },
        { type: 'border', text: t.right, position: 'right' },
        { type: 'border', text: t.bottom, position: 'bottom' },
        { type: 'border', text: t.left, position: 'left' },
      ]
      return Ba(u)
    }
    I(d2, 'drawBorder')
    function p2(
      e,
      { padding: t, border: r, width: n, height: o, top: a, left: i }
    ) {
      const s = n - r.left - r.right - t.left - t.right
      const l = o - t.top - t.bottom - r.top - r.bottom
      return (
        (e.fillStyle = Ra.content),
        e.fillRect(i + r.left + t.left, a + r.top + t.top, s, l),
        [{ type: 'content', position: 'center', text: `${Cr(s)} x ${Cr(l)}` }]
      )
    }
    I(p2, 'drawContent')
    function m2(e) {
      return t => {
        if (e && t) {
          const r = l2(e)
          const n = u2(t, r)
          const o = c2(t, r)
          const a = d2(t, r)
          const i = p2(t, r)
          const s = r.width <= ag * 3 || r.height <= ag
          i2(t, r, [...i, ...o, ...a, ...n], s)
        }
      }
    }
    I(m2, 'drawBoxModel')
    function h2(e) {
      Xg(m2(e))
    }
    I(h2, 'drawSelectedElement')
    const pS = I((e, t) => {
      const r = H.document.elementFromPoint(e, t)
      const n = I(o => {
        if (o && o.shadowRoot) {
          const a = o.shadowRoot.elementFromPoint(e, t)
          return o.isEqualNode(a) ? o : a.shadowRoot ? n(a) : a
        }
        return o
      }, 'crawlShadows')
      return n(r) || r
    }, 'deepElementFromPoint')
    let ig
    const va = { x: 0, y: 0 }
    function Ol(e, t) {
      ;((ig = pS(e, t)), h2(ig))
    }
    I(Ol, 'findAndDrawElement')
    const mS = I((e, t) => {
      const { measureEnabled: r } = t.globals || {}
      return (
        Bt(() => {
          if (typeof globalThis.document > 'u') return
          const n = I(o => {
            window.requestAnimationFrame(() => {
              ;(o.stopPropagation(), (va.x = o.clientX), (va.y = o.clientY))
            })
          }, 'onPointerMove')
          return (
            globalThis.document.addEventListener('pointermove', n),
            () => {
              globalThis.document.removeEventListener('pointermove', n)
            }
          )
        }, []),
        Bt(() => {
          const n = I(a => {
            window.requestAnimationFrame(() => {
              ;(a.stopPropagation(), Ol(a.clientX, a.clientY))
            })
          }, 'onPointerOver')
          const o = I(() => {
            window.requestAnimationFrame(() => {
              Jg()
            })
          }, 'onResize')
          return (
            t.viewMode === 'story' &&
              r &&
              (globalThis.document.addEventListener('pointerover', n),
              Kg(),
              globalThis.window.addEventListener('resize', o),
              Ol(va.x, va.y)),
            () => {
              ;(globalThis.window.removeEventListener('resize', o), Zg())
            }
          )
        }, [r, t.viewMode]),
        e()
      )
    }, 'withMeasure')
    const hS = globalThis.FEATURES?.measure ? [mS] : []
    const fS = { [dS]: !1 }
    const sg = I(() => ({ decorators: hS, initialGlobals: fS }), 'default')
    const f2 = 'outline'
    const lg = I(e => {
      ;(Array.isArray(e) ? e : [e]).forEach(gS)
    }, 'clearStyles')
    var gS = I(e => {
      const t = typeof e === 'string' ? e : e.join('')
      const r = H.document.getElementById(t)
      r && r.parentElement && r.parentElement.removeChild(r)
    }, 'clearStyle')
    const yS = I((e, t) => {
      const r = H.document.getElementById(e)
      if (r) r.innerHTML !== t && (r.innerHTML = t)
      else {
        const n = H.document.createElement('style')
        ;(n.setAttribute('id', e),
          (n.innerHTML = t),
          H.document.head.appendChild(n))
      }
    }, 'addOutlineStyles')
    function g2(e) {
      return ka`
    ${e} body {
      outline: 1px solid #2980b9 !important;
    }

    ${e} article {
      outline: 1px solid #3498db !important;
    }

    ${e} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${e} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${e} section {
      outline: 1px solid #66b8da !important;
    }

    ${e} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${e} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${e} h1 {
      outline: 1px solid #162544 !important;
    }

    ${e} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${e} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${e} h4 {
      outline: 1px solid #449baf !important;
    }

    ${e} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${e} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${e} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${e} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${e} div {
      outline: 1px solid #036cdb !important;
    }

    ${e} p {
      outline: 1px solid #ac050b !important;
    }

    ${e} hr {
      outline: 1px solid #ff063f !important;
    }

    ${e} pre {
      outline: 1px solid #850440 !important;
    }

    ${e} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${e} ol {
      outline: 1px solid #ff050c !important;
    }

    ${e} ul {
      outline: 1px solid #d90416 !important;
    }

    ${e} li {
      outline: 1px solid #d90416 !important;
    }

    ${e} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${e} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${e} dd {
      outline: 1px solid #e80174 !important;
    }

    ${e} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${e} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${e} table {
      outline: 1px solid #00cc99 !important;
    }

    ${e} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} thead {
      outline: 1px solid #98daca !important;
    }

    ${e} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${e} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${e} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${e} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${e} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${e} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${e} button {
      outline: 1px solid #da8301 !important;
    }

    ${e} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${e} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${e} form {
      outline: 1px solid #d23600 !important;
    }

    ${e} input {
      outline: 1px solid #fca600 !important;
    }

    ${e} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${e} label {
      outline: 1px solid #ee8900 !important;
    }

    ${e} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${e} meter {
      outline: 1px solid #e8630c !important;
    }

    ${e} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${e} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${e} output {
      outline: 1px solid #ff9619 !important;
    }

    ${e} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${e} select {
      outline: 1px solid #e26e0f !important;
    }

    ${e} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${e} details {
      outline: 1px solid #33848f !important;
    }

    ${e} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${e} command {
      outline: 1px solid #438da1 !important;
    }

    ${e} menu {
      outline: 1px solid #449da6 !important;
    }

    ${e} del {
      outline: 1px solid #bf0000 !important;
    }

    ${e} ins {
      outline: 1px solid #400000 !important;
    }

    ${e} img {
      outline: 1px solid #22746b !important;
    }

    ${e} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} embed {
      outline: 1px solid #98daca !important;
    }

    ${e} object {
      outline: 1px solid #00cc99 !important;
    }

    ${e} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} video {
      outline: 1px solid #6ee866 !important;
    }

    ${e} audio {
      outline: 1px solid #027353 !important;
    }

    ${e} source {
      outline: 1px solid #012426 !important;
    }

    ${e} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${e} track {
      outline: 1px solid #59a600 !important;
    }

    ${e} map {
      outline: 1px solid #7be500 !important;
    }

    ${e} area {
      outline: 1px solid #305900 !important;
    }

    ${e} a {
      outline: 1px solid #ff62ab !important;
    }

    ${e} em {
      outline: 1px solid #800b41 !important;
    }

    ${e} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${e} i {
      outline: 1px solid #803156 !important;
    }

    ${e} b {
      outline: 1px solid #cc1169 !important;
    }

    ${e} u {
      outline: 1px solid #ff0430 !important;
    }

    ${e} s {
      outline: 1px solid #f805e3 !important;
    }

    ${e} small {
      outline: 1px solid #d107b2 !important;
    }

    ${e} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${e} q {
      outline: 1px solid #240018 !important;
    }

    ${e} cite {
      outline: 1px solid #64003c !important;
    }

    ${e} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${e} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${e} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${e} time {
      outline: 1px solid #d6606d !important;
    }

    ${e} code {
      outline: 1px solid #e04251 !important;
    }

    ${e} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${e} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${e} var {
      outline: 1px solid #d90047 !important;
    }

    ${e} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${e} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${e} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${e} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${e} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${e} rp {
      outline: 1px solid #803e49 !important;
    }

    ${e} span {
      outline: 1px solid #cc2643 !important;
    }

    ${e} br {
      outline: 1px solid #db687d !important;
    }

    ${e} wbr {
      outline: 1px solid #db175b !important;
    }`
    }
    I(g2, 'outlineCSS')
    const bS = I((e, t) => {
      const r = t.globals || {}
      const n = [!0, 'true'].includes(r[f2])
      const o = t.viewMode === 'docs'
      const a = us(
        () => g2(o ? '[data-story-block="true"]' : '.sb-show-main'),
        [t]
      )
      return (
        Bt(() => {
          const i = o ? `addon-outline-docs-${t.id}` : 'addon-outline'
          return (
            n ? yS(i, a) : lg(i),
            () => {
              lg(i)
            }
          )
        }, [n, a, t]),
        e()
      )
    }, 'withOutline')
    const ES = globalThis.FEATURES?.outline ? [bS] : []
    const vS = { [f2]: !1 }
    const ug = I(() => ({ decorators: ES, initialGlobals: vS }), 'default')
    const AS = I(({ parameters: e }) => {
      e?.test?.mockReset === !0
        ? Am()
        : e?.test?.clearMocks === !0
          ? ym()
          : e?.test?.restoreMocks !== !1 && xm()
    }, 'resetAllMocksLoader')
    var Il = I((e, t = 0, r) => {
      if (t > 5 || e == null) return e
      if (Em(e)) return (r && e.mockName(r), e)
      if (
        typeof e === 'function' &&
        'isAction' in e &&
        e.isAction &&
        !('implicit' in e && e.implicit)
      ) {
        const n = bm(e)
        return (r && n.mockName(r), n)
      }
      if (Array.isArray(e)) {
        t++
        for (let n = 0; n < e.length; n++)
          Object.getOwnPropertyDescriptor(e, n)?.writable &&
            (e[n] = Il(e[n], t))
        return e
      }
      if (typeof e === 'object' && e.constructor === Object) {
        t++
        for (const [n, o] of Object.entries(e))
          Object.getOwnPropertyDescriptor(e, n)?.writable &&
            (e[n] = Il(o, t, n))
        return e
      }
      return e
    }, 'traverseArgs')
    const xS = I(({ initialArgs: e }) => {
      Il(e)
    }, 'nameSpiesAndWrapActionsInSpies')
    let cg = !1
    const wS = I(async e => {
      globalThis.HTMLElement &&
        e.canvasElement instanceof globalThis.HTMLElement &&
        (e.canvas = Sm(e.canvasElement))
      const t = globalThis.window?.navigator?.clipboard
      if (t) {
        ;((e.userEvent = Vn(
          { userEvent: wm.setup() },
          { intercept: !0 }
        ).userEvent),
          Object.defineProperty(globalThis.window.navigator, 'clipboard', {
            get: I(() => t, 'get'),
            configurable: !0,
          }))
        let r = HTMLElement.prototype.focus
        cg ||
          Object.defineProperties(HTMLElement.prototype, {
            focus: {
              configurable: !0,
              set: I(n => {
                ;((r = n), (cg = !0))
              }, 'set'),
              get: I(() => r, 'get'),
            },
          })
      }
    }, 'enhanceContext')
    const dg = I(() => ({ loaders: [AS, xS, wS] }), 'default')
    const y2 = 'storybook/viewport'
    const SS = 'viewport'
    const c8 = `${y2}/panel`
    const d8 = `${y2}/tool`
    const CS = { [SS]: { value: void 0, isRotated: !1 } }
    const pg = I(() => ({ initialGlobals: CS }), 'default')
    function Qr() {
      return [
        (sg.default ?? sg)(),
        (Kf.default ?? Kf)(),
        (og.default ?? og)(),
        (ug.default ?? ug)(),
        (pg.default ?? pg)(),
        (zf.default ?? zf)(),
        (Xf.default ?? Xf)(),
        (dg.default ?? dg)(),
      ]
    }
    I(Qr, 'getCoreAnnotations')
    function DS(e) {
      let t
      const r = {
        _tag: 'Preview',
        input: e,
        get composed() {
          if (t) return t
          const { addons: n, ...o } = e
          return ((t = Bl(_l([...Qr(), ...(n ?? []), o]))), t)
        },
        meta(n) {
          return b2(n, this)
        },
      }
      return ((globalThis.globalProjectAnnotations = r.composed), r)
    }
    I(DS, 'definePreview')
    function Wt(e) {
      return e
    }
    I(Wt, 'definePreviewAddon')
    function TS(e) {
      return (
        e != null &&
        typeof e === 'object' &&
        '_tag' in e &&
        e?._tag === 'Preview'
      )
    }
    I(TS, 'isPreview')
    function kS(e) {
      return (
        e != null && typeof e === 'object' && '_tag' in e && e?._tag === 'Meta'
      )
    }
    I(kS, 'isMeta')
    function b2(e, t) {
      return {
        _tag: 'Meta',
        input: e,
        preview: t,
        get composed() {
          throw new Error('Not implemented')
        },
        story(r = {}) {
          return $l(typeof r === 'function' ? { render: r } : r, this)
        },
      }
    }
    I(b2, 'defineMeta')
    function Ar(e) {
      return (
        e != null && typeof e === 'object' && '_tag' in e && e?._tag === 'Story'
      )
    }
    I(Ar, 'isStory')
    function $l(e, t) {
      let r
      const n = I(
        () => (r || (r = Ug(e, t.input, void 0, t.preview.composed)), r),
        'compose'
      )
      return {
        _tag: 'Story',
        input: e,
        meta: t,
        __compose: n,
        get composed() {
          const o = n()
          const {
            args: a,
            argTypes: i,
            parameters: s,
            id: l,
            tags: u,
            globals: d,
            storyName: m,
          } = o
          return {
            args: a,
            argTypes: i,
            parameters: s,
            id: l,
            tags: u,
            name: m,
            globals: d,
          }
        },
        get play() {
          return e.play ?? t.input?.play ?? (async () => {})
        },
        get run() {
          return n().run ?? (async () => {})
        },
        extend(o) {
          return $l(
            {
              ...this.input,
              ...o,
              args: { ...this.input.args, ...o.args },
              argTypes: lr(this.input.argTypes, o.argTypes),
              afterEach: [
                ...oe(this.input?.afterEach ?? []),
                ...oe(o.afterEach ?? []),
              ],
              beforeEach: [
                ...oe(this.input?.beforeEach ?? []),
                ...oe(o.beforeEach ?? []),
              ],
              decorators: [
                ...oe(this.input?.decorators ?? []),
                ...oe(o.decorators ?? []),
              ],
              globals: { ...this.input.globals, ...o.globals },
              loaders: [
                ...oe(this.input?.loaders ?? []),
                ...oe(o.loaders ?? []),
              ],
              parameters: lr(this.input.parameters, o.parameters),
              tags: en(...(this.input.tags ?? []), ...(o.tags ?? [])),
            },
            this.meta
          )
        },
      }
    }
    I($l, 'defineStory')
    var Nn = I(
      e =>
        e
          .toLowerCase()
          .replace(/[ â€™â€“â€”â€•â€²Â¿'`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '-')
          .replace(/-+/g, '-')
          .replace(/^-+/, '')
          .replace(/-+$/, ''),
      'sanitize'
    )
    const mg = I((e, t) => {
      const r = Nn(e)
      if (r === '')
        throw new Error(
          `Invalid ${t} '${e}', must include alphanumeric characters`
        )
      return r
    }, 'sanitizeSafe')
    var Xo = I(
      (e, t) => `${mg(e, 'kind')}${t ? `--${mg(t, 'name')}` : ''}`,
      'toId'
    )
    var Jo = I(e => fg(e), 'storyNameFromExport')
    function Rl(e, t) {
      return Array.isArray(t) ? t.includes(e) : e.match(t)
    }
    I(Rl, 'matches')
    function Xr(e, { includeStories: t, excludeStories: r }) {
      return e !== '__esModule' && (!t || Rl(e, t)) && (!r || !Rl(e, r))
    }
    I(Xr, 'isExportStory')
    const p8 = I((e, { rootSeparator: t, groupSeparator: r }) => {
      const [n, o] = e.split(t, 2)
      const a = (o || e).split(r).filter(i => !!i)
      return { root: o ? n : null, groups: a }
    }, 'parseKind')
    var en = I((...e) => {
      const t = e.reduce(
        (r, n) => (n.startsWith('!') ? r.delete(n.slice(1)) : r.add(n), r),
        new Set()
      )
      return Array.from(t)
    }, 'combineTags')
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    J()
    const OS = Object.create
    const ci = Object.defineProperty
    const IS = Object.getOwnPropertyDescriptor
    const RS = Object.getOwnPropertyNames
    const BS = Object.getPrototypeOf
    const _S = Object.prototype.hasOwnProperty
    const h = (e, t) => ci(e, 'name', { value: t, configurable: !0 })
    const _a = (e =>
      typeof Ke < 'u'
        ? Ke
        : typeof Proxy < 'u'
          ? new Proxy(e, { get: (t, r) => (typeof Ke < 'u' ? Ke : t)[r] })
          : e)(function (e) {
      if (typeof Ke < 'u') return Ke.apply(this, arguments)
      throw new Error('Dynamic require of "' + e + '" is not supported')
    })
    const ie = (e, t) => () => (e && (t = e((e = 0))), t)
    const ge = (e, t) => () => (
      t || e((t = { exports: {} }).exports, t),
      t.exports
    )
    const FS = (e, t) => {
      for (const r in t) ci(e, r, { get: t[r], enumerable: !0 })
    }
    const PS = (e, t, r, n) => {
      if ((t && typeof t === 'object') || typeof t === 'function')
        for (const o of RS(t))
          !_S.call(e, o) &&
            o !== r &&
            ci(e, o, {
              get: () => t[o],
              enumerable: !(n = IS(t, o)) || n.enumerable,
            })
      return e
    }
    const it = (e, t, r) => (
      (r = e != null ? OS(BS(e)) : {}),
      PS(
        t || !e || !e.__esModule
          ? ci(r, 'default', { value: e, enumerable: !0 })
          : r,
        e
      )
    )
    function $u(e) {
      return typeof e === 'symbol' || e instanceof Symbol
    }
    const $0 = ie(() => {
      h($u, 'isSymbol')
    })
    function q0(e) {
      return $u(e) ? NaN : Number(e)
    }
    const NS = ie(() => {
      ;($0(), h(q0, 'toNumber'))
    })
    function U0(e) {
      return e
        ? ((e = q0(e)),
          e === 1 / 0 || e === -1 / 0
            ? (e < 0 ? -1 : 1) * Number.MAX_VALUE
            : e === e
              ? e
              : 0)
        : e === 0
          ? e
          : 0
    }
    const LS = ie(() => {
      ;(NS(), h(U0, 'toFinite'))
    })
    function H0(e) {
      const t = U0(e)
      const r = t % 1
      return r ? t - r : t
    }
    const jS = ie(() => {
      ;(LS(), h(H0, 'toInteger'))
    })
    function V0(e) {
      return Array.from(new Set(e))
    }
    const MS = ie(() => {
      h(V0, 'uniq')
    })
    function z0(e) {
      return e == null || (typeof e !== 'object' && typeof e !== 'function')
    }
    const $S = ie(() => {
      h(z0, 'isPrimitive')
    })
    function qu(e) {
      return ArrayBuffer.isView(e) && !(e instanceof DataView)
    }
    const G0 = ie(() => {
      h(qu, 'isTypedArray')
    })
    function Uu(e) {
      return Object.getOwnPropertySymbols(e).filter(t =>
        Object.prototype.propertyIsEnumerable.call(e, t)
      )
    }
    const W0 = ie(() => {
      h(Uu, 'getSymbols')
    })
    function Y0(e) {
      return e == null
        ? e === void 0
          ? '[object Undefined]'
          : '[object Null]'
        : Object.prototype.toString.call(e)
    }
    const qS = ie(() => {
      h(Y0, 'getTag')
    })
    let K0
    let Hu
    let Vu
    let zu
    let Gu
    let X0
    let J0
    let Z0
    let Q0
    let ey
    let ty
    let ry
    let ny
    let oy
    let ay
    let iy
    let sy
    let ly
    let uy
    let cy
    let dy
    let py
    const my = ie(() => {
      ;((K0 = '[object RegExp]'),
        (Hu = '[object String]'),
        (Vu = '[object Number]'),
        (zu = '[object Boolean]'),
        (Gu = '[object Arguments]'),
        (X0 = '[object Symbol]'),
        (J0 = '[object Date]'),
        (Z0 = '[object Map]'),
        (Q0 = '[object Set]'),
        (ey = '[object Array]'),
        (ty = '[object ArrayBuffer]'),
        (ry = '[object Object]'),
        (ny = '[object DataView]'),
        (oy = '[object Uint8Array]'),
        (ay = '[object Uint8ClampedArray]'),
        (iy = '[object Uint16Array]'),
        (sy = '[object Uint32Array]'),
        (ly = '[object Int8Array]'),
        (uy = '[object Int16Array]'),
        (cy = '[object Int32Array]'),
        (dy = '[object Float32Array]'),
        (py = '[object Float64Array]'))
    })
    function hy(e, t) {
      return Ir(e, void 0, e, new Map(), t)
    }
    function Ir(e, t, r, n = new Map(), o = void 0) {
      const a = o?.(e, t, r, n)
      if (a != null) return a
      if (z0(e)) return e
      if (n.has(e)) return n.get(e)
      if (Array.isArray(e)) {
        const i = new Array(e.length)
        n.set(e, i)
        for (let s = 0; s < e.length; s++) i[s] = Ir(e[s], s, r, n, o)
        return (
          Object.hasOwn(e, 'index') && (i.index = e.index),
          Object.hasOwn(e, 'input') && (i.input = e.input),
          i
        )
      }
      if (e instanceof Date) return new Date(e.getTime())
      if (e instanceof RegExp) {
        const i = new RegExp(e.source, e.flags)
        return ((i.lastIndex = e.lastIndex), i)
      }
      if (e instanceof Map) {
        const i = new Map()
        n.set(e, i)
        for (const [s, l] of e) i.set(s, Ir(l, s, r, n, o))
        return i
      }
      if (e instanceof Set) {
        const i = new Set()
        n.set(e, i)
        for (const s of e) i.add(Ir(s, void 0, r, n, o))
        return i
      }
      if (typeof Buffer < 'u' && Buffer.isBuffer(e)) return e.subarray()
      if (qu(e)) {
        const i = new (Object.getPrototypeOf(e).constructor)(e.length)
        n.set(e, i)
        for (let s = 0; s < e.length; s++) i[s] = Ir(e[s], s, r, n, o)
        return i
      }
      if (
        e instanceof ArrayBuffer ||
        (typeof SharedArrayBuffer < 'u' && e instanceof SharedArrayBuffer)
      )
        return e.slice(0)
      if (e instanceof DataView) {
        const i = new DataView(e.buffer.slice(0), e.byteOffset, e.byteLength)
        return (n.set(e, i), pr(i, e, r, n, o), i)
      }
      if (typeof File < 'u' && e instanceof File) {
        const i = new File([e], e.name, { type: e.type })
        return (n.set(e, i), pr(i, e, r, n, o), i)
      }
      if (e instanceof Blob) {
        const i = new Blob([e], { type: e.type })
        return (n.set(e, i), pr(i, e, r, n, o), i)
      }
      if (e instanceof Error) {
        const i = new e.constructor()
        return (
          n.set(e, i),
          (i.message = e.message),
          (i.name = e.name),
          (i.stack = e.stack),
          (i.cause = e.cause),
          pr(i, e, r, n, o),
          i
        )
      }
      if (typeof e === 'object' && fy(e)) {
        const i = Object.create(Object.getPrototypeOf(e))
        return (n.set(e, i), pr(i, e, r, n, o), i)
      }
      return e
    }
    function pr(e, t, r = e, n, o) {
      const a = [...Object.keys(t), ...Uu(t)]
      for (let i = 0; i < a.length; i++) {
        const s = a[i]
        const l = Object.getOwnPropertyDescriptor(e, s)
        ;(l == null || l.writable) && (e[s] = Ir(t[s], s, r, n, o))
      }
    }
    function fy(e) {
      switch (Y0(e)) {
        case Gu:
        case ey:
        case ty:
        case ny:
        case zu:
        case J0:
        case dy:
        case py:
        case ly:
        case uy:
        case cy:
        case Z0:
        case Vu:
        case ry:
        case K0:
        case Q0:
        case Hu:
        case X0:
        case oy:
        case ay:
        case iy:
        case sy:
          return !0
        default:
          return !1
      }
    }
    const US = ie(() => {
      ;(W0(),
        qS(),
        my(),
        $S(),
        G0(),
        h(hy, 'cloneDeepWith'),
        h(Ir, 'cloneDeepWithImpl'),
        h(pr, 'copyProperties'),
        h(fy, 'isCloneableObject'))
    })
    function gy(e) {
      return Number.isSafeInteger(e) && e >= 0
    }
    const HS = ie(() => {
      h(gy, 'isLength')
    })
    function di(e) {
      return e != null && typeof e !== 'function' && gy(e.length)
    }
    const Wu = ie(() => {
      ;(HS(), h(di, 'isArrayLike'))
    })
    function yy(e, t) {
      return hy(e, (r, n, o, a) => {
        const i = t?.(r, n, o, a)
        if (i != null) return i
        if (typeof e === 'object')
          switch (Object.prototype.toString.call(e)) {
            case Vu:
            case Hu:
            case zu: {
              const s = new e.constructor(e?.valueOf())
              return (pr(s, e), s)
            }
            case Gu: {
              const s = {}
              return (
                pr(s, e),
                (s.length = e.length),
                (s[Symbol.iterator] = e[Symbol.iterator]),
                s
              )
            }
            default:
          }
      })
    }
    const VS = ie(() => {
      ;(US(), my(), h(yy, 'cloneDeepWith'))
    })
    function by(e) {
      return yy(e)
    }
    const zS = ie(() => {
      ;(VS(), h(by, 'cloneDeep'))
    })
    function Ey(e, t, r = 1) {
      if ((t == null && ((t = e), (e = 0)), !Number.isInteger(r) || r === 0))
        throw new Error('The step value must be a non-zero integer.')
      const n = Math.max(Math.ceil((t - e) / r), 0)
      const o = new Array(n)
      for (let a = 0; a < n; a++) o[a] = e + a * r
      return o
    }
    const GS = ie(() => {
      h(Ey, 'range')
    })
    function vy(e) {
      return di(e) ? V0(Array.from(e)) : []
    }
    const WS = ie(() => {
      ;(MS(), Wu(), h(vy, 'uniq'))
    })
    function Ay(e, t, { signal: r, edges: n } = {}) {
      let o
      let a = null
      const i = n != null && n.includes('leading')
      const s = n == null || n.includes('trailing')
      const l = h(() => {
        a !== null && (e.apply(o, a), (o = void 0), (a = null))
      }, 'invoke')
      const u = h(() => {
        ;(s && l(), f())
      }, 'onTimerEnd')
      let d = null
      const m = h(() => {
        ;(d != null && clearTimeout(d),
          (d = setTimeout(() => {
            ;((d = null), u())
          }, t)))
      }, 'schedule')
      const p = h(() => {
        d !== null && (clearTimeout(d), (d = null))
      }, 'cancelTimer')
      const f = h(() => {
        ;(p(), (o = void 0), (a = null))
      }, 'cancel')
      const g = h(() => {
        ;(p(), l())
      }, 'flush')
      const y = h(function (...E) {
        if (r?.aborted) return
        ;((o = this), (a = E))
        const b = d == null
        ;(m(), i && b && l())
      }, 'debounced')
      return (
        (y.schedule = m),
        (y.cancel = f),
        (y.flush = g),
        r?.addEventListener('abort', f, { once: !0 }),
        y
      )
    }
    const YS = ie(() => {
      h(Ay, 'debounce')
    })
    function xy(e, t = 0, r = {}) {
      typeof r !== 'object' && (r = {})
      const { signal: n, leading: o = !1, trailing: a = !0, maxWait: i } = r
      const s = Array(2)
      ;(o && (s[0] = 'leading'), a && (s[1] = 'trailing'))
      let l
      let u = null
      const d = Ay(
        function (...f) {
          ;((l = e.apply(this, f)), (u = null))
        },
        t,
        { signal: n, edges: s }
      )
      const m = h(function (...f) {
        if (i != null) {
          if (u === null) u = Date.now()
          else if (Date.now() - u >= i)
            return (
              (l = e.apply(this, f)),
              (u = Date.now()),
              d.cancel(),
              d.schedule(),
              l
            )
        }
        return (d.apply(this, f), l)
      }, 'debounced')
      const p = h(() => (d.flush(), l), 'flush')
      return ((m.cancel = d.cancel), (m.flush = p), m)
    }
    const KS = ie(() => {
      ;(YS(), h(xy, 'debounce'))
    })
    function wy(e) {
      return typeof Buffer < 'u' && Buffer.isBuffer(e)
    }
    const XS = ie(() => {
      h(wy, 'isBuffer')
    })
    function Sy(e) {
      const t = e?.constructor
      const r = typeof t === 'function' ? t.prototype : Object.prototype
      return e === r
    }
    const JS = ie(() => {
      h(Sy, 'isPrototype')
    })
    function Cy(e) {
      return qu(e)
    }
    const ZS = ie(() => {
      ;(G0(), h(Cy, 'isTypedArray'))
    })
    function Dy(e, t) {
      if (((e = H0(e)), e < 1 || !Number.isSafeInteger(e))) return []
      const r = new Array(e)
      for (let n = 0; n < e; n++) r[n] = typeof t === 'function' ? t(n) : n
      return r
    }
    const QS = ie(() => {
      ;(jS(), h(Dy, 'times'))
    })
    function Ty(e) {
      if (e == null) return []
      switch (typeof e) {
        case 'object':
        case 'function':
          return di(e) ? Oy(e) : Sy(e) ? ky(e) : ao(e)
        default:
          return ao(Object(e))
      }
    }
    function ao(e) {
      const t = []
      for (const r in e) t.push(r)
      return t
    }
    function ky(e) {
      return ao(e).filter(t => t !== 'constructor')
    }
    function Oy(e) {
      const t = Dy(e.length, n => `${n}`)
      const r = new Set(t)
      return (
        wy(e) && (r.add('offset'), r.add('parent')),
        Cy(e) && (r.add('buffer'), r.add('byteLength'), r.add('byteOffset')),
        [...t, ...ao(e).filter(n => !r.has(n))]
      )
    }
    const eC = ie(() => {
      ;(XS(),
        JS(),
        Wu(),
        ZS(),
        QS(),
        h(Ty, 'keysIn'),
        h(ao, 'keysInImpl'),
        h(ky, 'prototypeKeysIn'),
        h(Oy, 'arrayLikeKeysIn'))
    })
    function Iy(e) {
      const t = []
      for (; e; ) (t.push(...Uu(e)), (e = Object.getPrototypeOf(e)))
      return t
    }
    const tC = ie(() => {
      ;(W0(), h(Iy, 'getSymbolsIn'))
    })
    function Ry(e, t) {
      if (e == null) return {}
      const r = {}
      if (t == null) return e
      const n = di(e) ? Ey(0, e.length) : [...Ty(e), ...Iy(e)]
      for (let o = 0; o < n.length; o++) {
        const a = $u(n[o]) ? n[o] : n[o].toString()
        const i = e[a]
        t(i, a, e) && (r[a] = i)
      }
      return r
    }
    const rC = ie(() => {
      ;(eC(), GS(), tC(), Wu(), $0(), h(Ry, 'pickBy'))
    })
    const pi = ie(() => {
      ;(WS(), KS(), zS(), rC())
    })
    let mt
    let so
    const Ot = ie(() => {
      'use strict'
      ;((mt = h(e => `control-${e.replace(/\s+/g, '-')}`, 'getControlId')),
        (so = h(
          e => `set-${e.replace(/\s+/g, '-')}`,
          'getControlSetterButtonId'
        )))
    })
    const nC = ge((e, t) => {
      'use strict'
      t.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50],
      }
    })
    const By = ge((e, t) => {
      const r = nC()
      const n = {}
      for (const i of Object.keys(r)) n[r[i]] = i
      const o = {
        rgb: { channels: 3, labels: 'rgb' },
        hsl: { channels: 3, labels: 'hsl' },
        hsv: { channels: 3, labels: 'hsv' },
        hwb: { channels: 3, labels: 'hwb' },
        cmyk: { channels: 4, labels: 'cmyk' },
        xyz: { channels: 3, labels: 'xyz' },
        lab: { channels: 3, labels: 'lab' },
        lch: { channels: 3, labels: 'lch' },
        hex: { channels: 1, labels: ['hex'] },
        keyword: { channels: 1, labels: ['keyword'] },
        ansi16: { channels: 1, labels: ['ansi16'] },
        ansi256: { channels: 1, labels: ['ansi256'] },
        hcg: { channels: 3, labels: ['h', 'c', 'g'] },
        apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
        gray: { channels: 1, labels: ['gray'] },
      }
      t.exports = o
      for (const i of Object.keys(o)) {
        if (!('channels' in o[i]))
          throw new Error('missing channels property: ' + i)
        if (!('labels' in o[i]))
          throw new Error('missing channel labels property: ' + i)
        if (o[i].labels.length !== o[i].channels)
          throw new Error('channel and label counts mismatch: ' + i)
        const { channels: s, labels: l } = o[i]
        ;(delete o[i].channels,
          delete o[i].labels,
          Object.defineProperty(o[i], 'channels', { value: s }),
          Object.defineProperty(o[i], 'labels', { value: l }))
      }
      ;((o.rgb.hsl = function (i) {
        const s = i[0] / 255
        const l = i[1] / 255
        const u = i[2] / 255
        const d = Math.min(s, l, u)
        const m = Math.max(s, l, u)
        const p = m - d
        let f
        let g
        ;(m === d
          ? (f = 0)
          : s === m
            ? (f = (l - u) / p)
            : l === m
              ? (f = 2 + (u - s) / p)
              : u === m && (f = 4 + (s - l) / p),
          (f = Math.min(f * 60, 360)),
          f < 0 && (f += 360))
        const y = (d + m) / 2
        return (
          m === d
            ? (g = 0)
            : y <= 0.5
              ? (g = p / (m + d))
              : (g = p / (2 - m - d)),
          [f, g * 100, y * 100]
        )
      }),
        (o.rgb.hsv = function (i) {
          let s
          let l
          let u
          let d
          let m
          const p = i[0] / 255
          const f = i[1] / 255
          const g = i[2] / 255
          const y = Math.max(p, f, g)
          const E = y - Math.min(p, f, g)
          const b = h(function (x) {
            return (y - x) / 6 / E + 1 / 2
          }, 'diffc')
          return (
            E === 0
              ? ((d = 0), (m = 0))
              : ((m = E / y),
                (s = b(p)),
                (l = b(f)),
                (u = b(g)),
                p === y
                  ? (d = u - l)
                  : f === y
                    ? (d = 1 / 3 + s - u)
                    : g === y && (d = 2 / 3 + l - s),
                d < 0 ? (d += 1) : d > 1 && (d -= 1)),
            [d * 360, m * 100, y * 100]
          )
        }),
        (o.rgb.hwb = function (i) {
          const s = i[0]
          const l = i[1]
          let u = i[2]
          const d = o.rgb.hsl(i)[0]
          const m = (1 / 255) * Math.min(s, Math.min(l, u))
          return (
            (u = 1 - (1 / 255) * Math.max(s, Math.max(l, u))),
            [d, m * 100, u * 100]
          )
        }),
        (o.rgb.cmyk = function (i) {
          const s = i[0] / 255
          const l = i[1] / 255
          const u = i[2] / 255
          const d = Math.min(1 - s, 1 - l, 1 - u)
          const m = (1 - s - d) / (1 - d) || 0
          const p = (1 - l - d) / (1 - d) || 0
          const f = (1 - u - d) / (1 - d) || 0
          return [m * 100, p * 100, f * 100, d * 100]
        }))
      function a(i, s) {
        return (i[0] - s[0]) ** 2 + (i[1] - s[1]) ** 2 + (i[2] - s[2]) ** 2
      }
      ;(h(a, 'comparativeDistance'),
        (o.rgb.keyword = function (i) {
          const s = n[i]
          if (s) return s
          let l = 1 / 0
          let u
          for (const d of Object.keys(r)) {
            const m = r[d]
            const p = a(i, m)
            p < l && ((l = p), (u = d))
          }
          return u
        }),
        (o.keyword.rgb = function (i) {
          return r[i]
        }),
        (o.rgb.xyz = function (i) {
          let s = i[0] / 255
          let l = i[1] / 255
          let u = i[2] / 255
          ;((s = s > 0.04045 ? ((s + 0.055) / 1.055) ** 2.4 : s / 12.92),
            (l = l > 0.04045 ? ((l + 0.055) / 1.055) ** 2.4 : l / 12.92),
            (u = u > 0.04045 ? ((u + 0.055) / 1.055) ** 2.4 : u / 12.92))
          const d = s * 0.4124 + l * 0.3576 + u * 0.1805
          const m = s * 0.2126 + l * 0.7152 + u * 0.0722
          const p = s * 0.0193 + l * 0.1192 + u * 0.9505
          return [d * 100, m * 100, p * 100]
        }),
        (o.rgb.lab = function (i) {
          const s = o.rgb.xyz(i)
          let l = s[0]
          let u = s[1]
          let d = s[2]
          ;((l /= 95.047),
            (u /= 100),
            (d /= 108.883),
            (l = l > 0.008856 ? l ** (1 / 3) : 7.787 * l + 16 / 116),
            (u = u > 0.008856 ? u ** (1 / 3) : 7.787 * u + 16 / 116),
            (d = d > 0.008856 ? d ** (1 / 3) : 7.787 * d + 16 / 116))
          const m = 116 * u - 16
          const p = 500 * (l - u)
          const f = 200 * (u - d)
          return [m, p, f]
        }),
        (o.hsl.rgb = function (i) {
          const s = i[0] / 360
          const l = i[1] / 100
          const u = i[2] / 100
          let d
          let m
          let p
          if (l === 0) return ((p = u * 255), [p, p, p])
          u < 0.5 ? (d = u * (1 + l)) : (d = u + l - u * l)
          const f = 2 * u - d
          const g = [0, 0, 0]
          for (let y = 0; y < 3; y++)
            ((m = s + (1 / 3) * -(y - 1)),
              m < 0 && m++,
              m > 1 && m--,
              6 * m < 1
                ? (p = f + (d - f) * 6 * m)
                : 2 * m < 1
                  ? (p = d)
                  : 3 * m < 2
                    ? (p = f + (d - f) * (2 / 3 - m) * 6)
                    : (p = f),
              (g[y] = p * 255))
          return g
        }),
        (o.hsl.hsv = function (i) {
          const s = i[0]
          let l = i[1] / 100
          let u = i[2] / 100
          let d = l
          const m = Math.max(u, 0.01)
          ;((u *= 2), (l *= u <= 1 ? u : 2 - u), (d *= m <= 1 ? m : 2 - m))
          const p = (u + l) / 2
          const f = u === 0 ? (2 * d) / (m + d) : (2 * l) / (u + l)
          return [s, f * 100, p * 100]
        }),
        (o.hsv.rgb = function (i) {
          const s = i[0] / 60
          const l = i[1] / 100
          let u = i[2] / 100
          const d = Math.floor(s) % 6
          const m = s - Math.floor(s)
          const p = 255 * u * (1 - l)
          const f = 255 * u * (1 - l * m)
          const g = 255 * u * (1 - l * (1 - m))
          switch (((u *= 255), d)) {
            case 0:
              return [u, g, p]
            case 1:
              return [f, u, p]
            case 2:
              return [p, u, g]
            case 3:
              return [p, f, u]
            case 4:
              return [g, p, u]
            case 5:
              return [u, p, f]
          }
        }),
        (o.hsv.hsl = function (i) {
          const s = i[0]
          const l = i[1] / 100
          const u = i[2] / 100
          const d = Math.max(u, 0.01)
          let m
          let p
          p = (2 - l) * u
          const f = (2 - l) * d
          return (
            (m = l * d),
            (m /= f <= 1 ? f : 2 - f),
            (m = m || 0),
            (p /= 2),
            [s, m * 100, p * 100]
          )
        }),
        (o.hwb.rgb = function (i) {
          const s = i[0] / 360
          let l = i[1] / 100
          let u = i[2] / 100
          const d = l + u
          let m
          d > 1 && ((l /= d), (u /= d))
          const p = Math.floor(6 * s)
          const f = 1 - u
          ;((m = 6 * s - p), (p & 1) !== 0 && (m = 1 - m))
          const g = l + m * (f - l)
          let y
          let E
          let b
          switch (p) {
            default:
            case 6:
            case 0:
              ;((y = f), (E = g), (b = l))
              break
            case 1:
              ;((y = g), (E = f), (b = l))
              break
            case 2:
              ;((y = l), (E = f), (b = g))
              break
            case 3:
              ;((y = l), (E = g), (b = f))
              break
            case 4:
              ;((y = g), (E = l), (b = f))
              break
            case 5:
              ;((y = f), (E = l), (b = g))
              break
          }
          return [y * 255, E * 255, b * 255]
        }),
        (o.cmyk.rgb = function (i) {
          const s = i[0] / 100
          const l = i[1] / 100
          const u = i[2] / 100
          const d = i[3] / 100
          const m = 1 - Math.min(1, s * (1 - d) + d)
          const p = 1 - Math.min(1, l * (1 - d) + d)
          const f = 1 - Math.min(1, u * (1 - d) + d)
          return [m * 255, p * 255, f * 255]
        }),
        (o.xyz.rgb = function (i) {
          const s = i[0] / 100
          const l = i[1] / 100
          const u = i[2] / 100
          let d
          let m
          let p
          return (
            (d = s * 3.2406 + l * -1.5372 + u * -0.4986),
            (m = s * -0.9689 + l * 1.8758 + u * 0.0415),
            (p = s * 0.0557 + l * -0.204 + u * 1.057),
            (d = d > 0.0031308 ? 1.055 * d ** (1 / 2.4) - 0.055 : d * 12.92),
            (m = m > 0.0031308 ? 1.055 * m ** (1 / 2.4) - 0.055 : m * 12.92),
            (p = p > 0.0031308 ? 1.055 * p ** (1 / 2.4) - 0.055 : p * 12.92),
            (d = Math.min(Math.max(0, d), 1)),
            (m = Math.min(Math.max(0, m), 1)),
            (p = Math.min(Math.max(0, p), 1)),
            [d * 255, m * 255, p * 255]
          )
        }),
        (o.xyz.lab = function (i) {
          let s = i[0]
          let l = i[1]
          let u = i[2]
          ;((s /= 95.047),
            (l /= 100),
            (u /= 108.883),
            (s = s > 0.008856 ? s ** (1 / 3) : 7.787 * s + 16 / 116),
            (l = l > 0.008856 ? l ** (1 / 3) : 7.787 * l + 16 / 116),
            (u = u > 0.008856 ? u ** (1 / 3) : 7.787 * u + 16 / 116))
          const d = 116 * l - 16
          const m = 500 * (s - l)
          const p = 200 * (l - u)
          return [d, m, p]
        }),
        (o.lab.xyz = function (i) {
          const s = i[0]
          const l = i[1]
          const u = i[2]
          let d
          let m
          let p
          ;((m = (s + 16) / 116), (d = l / 500 + m), (p = m - u / 200))
          const f = m ** 3
          const g = d ** 3
          const y = p ** 3
          return (
            (m = f > 0.008856 ? f : (m - 16 / 116) / 7.787),
            (d = g > 0.008856 ? g : (d - 16 / 116) / 7.787),
            (p = y > 0.008856 ? y : (p - 16 / 116) / 7.787),
            (d *= 95.047),
            (m *= 100),
            (p *= 108.883),
            [d, m, p]
          )
        }),
        (o.lab.lch = function (i) {
          const s = i[0]
          const l = i[1]
          const u = i[2]
          let d
          ;((d = (Math.atan2(u, l) * 360) / 2 / Math.PI), d < 0 && (d += 360))
          const m = Math.sqrt(l * l + u * u)
          return [s, m, d]
        }),
        (o.lch.lab = function (i) {
          const s = i[0]
          const l = i[1]
          const u = (i[2] / 360) * 2 * Math.PI
          const d = l * Math.cos(u)
          const m = l * Math.sin(u)
          return [s, d, m]
        }),
        (o.rgb.ansi16 = function (i, s = null) {
          const [l, u, d] = i
          let m = s === null ? o.rgb.hsv(i)[2] : s
          if (((m = Math.round(m / 50)), m === 0)) return 30
          let p =
            30 +
            ((Math.round(d / 255) << 2) |
              (Math.round(u / 255) << 1) |
              Math.round(l / 255))
          return (m === 2 && (p += 60), p)
        }),
        (o.hsv.ansi16 = function (i) {
          return o.rgb.ansi16(o.hsv.rgb(i), i[2])
        }),
        (o.rgb.ansi256 = function (i) {
          const s = i[0]
          const l = i[1]
          const u = i[2]
          return s === l && l === u
            ? s < 8
              ? 16
              : s > 248
                ? 231
                : Math.round(((s - 8) / 247) * 24) + 232
            : 16 +
                36 * Math.round((s / 255) * 5) +
                6 * Math.round((l / 255) * 5) +
                Math.round((u / 255) * 5)
        }),
        (o.ansi16.rgb = function (i) {
          let s = i % 10
          if (s === 0 || s === 7)
            return (i > 50 && (s += 3.5), (s = (s / 10.5) * 255), [s, s, s])
          const l = (~~(i > 50) + 1) * 0.5
          const u = (s & 1) * l * 255
          const d = ((s >> 1) & 1) * l * 255
          const m = ((s >> 2) & 1) * l * 255
          return [u, d, m]
        }),
        (o.ansi256.rgb = function (i) {
          if (i >= 232) {
            const m = (i - 232) * 10 + 8
            return [m, m, m]
          }
          i -= 16
          let s
          const l = (Math.floor(i / 36) / 5) * 255
          const u = (Math.floor((s = i % 36) / 6) / 5) * 255
          const d = ((s % 6) / 5) * 255
          return [l, u, d]
        }),
        (o.rgb.hex = function (i) {
          const s = (
            ((Math.round(i[0]) & 255) << 16) +
            ((Math.round(i[1]) & 255) << 8) +
            (Math.round(i[2]) & 255)
          )
            .toString(16)
            .toUpperCase()
          return '000000'.substring(s.length) + s
        }),
        (o.hex.rgb = function (i) {
          const s = i.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i)
          if (!s) return [0, 0, 0]
          let l = s[0]
          s[0].length === 3 &&
            (l = l
              .split('')
              .map(f => f + f)
              .join(''))
          const u = parseInt(l, 16)
          const d = (u >> 16) & 255
          const m = (u >> 8) & 255
          const p = u & 255
          return [d, m, p]
        }),
        (o.rgb.hcg = function (i) {
          const s = i[0] / 255
          const l = i[1] / 255
          const u = i[2] / 255
          const d = Math.max(Math.max(s, l), u)
          const m = Math.min(Math.min(s, l), u)
          const p = d - m
          let f
          let g
          return (
            p < 1 ? (f = m / (1 - p)) : (f = 0),
            p <= 0
              ? (g = 0)
              : d === s
                ? (g = ((l - u) / p) % 6)
                : d === l
                  ? (g = 2 + (u - s) / p)
                  : (g = 4 + (s - l) / p),
            (g /= 6),
            (g %= 1),
            [g * 360, p * 100, f * 100]
          )
        }),
        (o.hsl.hcg = function (i) {
          const s = i[1] / 100
          const l = i[2] / 100
          const u = l < 0.5 ? 2 * s * l : 2 * s * (1 - l)
          let d = 0
          return (
            u < 1 && (d = (l - 0.5 * u) / (1 - u)),
            [i[0], u * 100, d * 100]
          )
        }),
        (o.hsv.hcg = function (i) {
          const s = i[1] / 100
          const l = i[2] / 100
          const u = s * l
          let d = 0
          return (u < 1 && (d = (l - u) / (1 - u)), [i[0], u * 100, d * 100])
        }),
        (o.hcg.rgb = function (i) {
          const s = i[0] / 360
          const l = i[1] / 100
          const u = i[2] / 100
          if (l === 0) return [u * 255, u * 255, u * 255]
          const d = [0, 0, 0]
          const m = (s % 1) * 6
          const p = m % 1
          const f = 1 - p
          let g = 0
          switch (Math.floor(m)) {
            case 0:
              ;((d[0] = 1), (d[1] = p), (d[2] = 0))
              break
            case 1:
              ;((d[0] = f), (d[1] = 1), (d[2] = 0))
              break
            case 2:
              ;((d[0] = 0), (d[1] = 1), (d[2] = p))
              break
            case 3:
              ;((d[0] = 0), (d[1] = f), (d[2] = 1))
              break
            case 4:
              ;((d[0] = p), (d[1] = 0), (d[2] = 1))
              break
            default:
              ;((d[0] = 1), (d[1] = 0), (d[2] = f))
          }
          return (
            (g = (1 - l) * u),
            [(l * d[0] + g) * 255, (l * d[1] + g) * 255, (l * d[2] + g) * 255]
          )
        }),
        (o.hcg.hsv = function (i) {
          const s = i[1] / 100
          const l = i[2] / 100
          const u = s + l * (1 - s)
          let d = 0
          return (u > 0 && (d = s / u), [i[0], d * 100, u * 100])
        }),
        (o.hcg.hsl = function (i) {
          const s = i[1] / 100
          const l = (i[2] / 100) * (1 - s) + 0.5 * s
          let u = 0
          return (
            l > 0 && l < 0.5
              ? (u = s / (2 * l))
              : l >= 0.5 && l < 1 && (u = s / (2 * (1 - l))),
            [i[0], u * 100, l * 100]
          )
        }),
        (o.hcg.hwb = function (i) {
          const s = i[1] / 100
          const l = i[2] / 100
          const u = s + l * (1 - s)
          return [i[0], (u - s) * 100, (1 - u) * 100]
        }),
        (o.hwb.hcg = function (i) {
          const s = i[1] / 100
          const l = 1 - i[2] / 100
          const u = l - s
          let d = 0
          return (u < 1 && (d = (l - u) / (1 - u)), [i[0], u * 100, d * 100])
        }),
        (o.apple.rgb = function (i) {
          return [
            (i[0] / 65535) * 255,
            (i[1] / 65535) * 255,
            (i[2] / 65535) * 255,
          ]
        }),
        (o.rgb.apple = function (i) {
          return [
            (i[0] / 255) * 65535,
            (i[1] / 255) * 65535,
            (i[2] / 255) * 65535,
          ]
        }),
        (o.gray.rgb = function (i) {
          return [(i[0] / 100) * 255, (i[0] / 100) * 255, (i[0] / 100) * 255]
        }),
        (o.gray.hsl = function (i) {
          return [0, 0, i[0]]
        }),
        (o.gray.hsv = o.gray.hsl),
        (o.gray.hwb = function (i) {
          return [0, 100, i[0]]
        }),
        (o.gray.cmyk = function (i) {
          return [0, 0, 0, i[0]]
        }),
        (o.gray.lab = function (i) {
          return [i[0], 0, 0]
        }),
        (o.gray.hex = function (i) {
          const s = Math.round((i[0] / 100) * 255) & 255
          const l = ((s << 16) + (s << 8) + s).toString(16).toUpperCase()
          return '000000'.substring(l.length) + l
        }),
        (o.rgb.gray = function (i) {
          return [((i[0] + i[1] + i[2]) / 3 / 255) * 100]
        }))
    })
    const oC = ge((e, t) => {
      const r = By()
      function n() {
        const s = {}
        const l = Object.keys(r)
        for (let u = l.length, d = 0; d < u; d++)
          s[l[d]] = { distance: -1, parent: null }
        return s
      }
      h(n, 'buildGraph')
      function o(s) {
        const l = n()
        const u = [s]
        for (l[s].distance = 0; u.length; ) {
          const d = u.pop()
          const m = Object.keys(r[d])
          for (let p = m.length, f = 0; f < p; f++) {
            const g = m[f]
            const y = l[g]
            y.distance === -1 &&
              ((y.distance = l[d].distance + 1), (y.parent = d), u.unshift(g))
          }
        }
        return l
      }
      h(o, 'deriveBFS')
      function a(s, l) {
        return function (u) {
          return l(s(u))
        }
      }
      h(a, 'link')
      function i(s, l) {
        const u = [l[s].parent, s]
        let d = r[l[s].parent][s]
        let m = l[s].parent
        for (; l[m].parent; )
          (u.unshift(l[m].parent),
            (d = a(r[l[m].parent][m], d)),
            (m = l[m].parent))
        return ((d.conversion = u), d)
      }
      ;(h(i, 'wrapConversion'),
        (t.exports = function (s) {
          const l = o(s)
          const u = {}
          const d = Object.keys(l)
          for (let m = d.length, p = 0; p < m; p++) {
            const f = d[p]
            l[f].parent !== null && (u[f] = i(f, l))
          }
          return u
        }))
    })
    const aC = ge((e, t) => {
      const r = By()
      const n = oC()
      const o = {}
      const a = Object.keys(r)
      function i(l) {
        const u = h(function (...d) {
          const m = d[0]
          return m == null ? m : (m.length > 1 && (d = m), l(d))
        }, 'wrappedFn')
        return ('conversion' in l && (u.conversion = l.conversion), u)
      }
      h(i, 'wrapRaw')
      function s(l) {
        const u = h(function (...d) {
          const m = d[0]
          if (m == null) return m
          m.length > 1 && (d = m)
          const p = l(d)
          if (typeof p === 'object')
            for (let f = p.length, g = 0; g < f; g++) p[g] = Math.round(p[g])
          return p
        }, 'wrappedFn')
        return ('conversion' in l && (u.conversion = l.conversion), u)
      }
      ;(h(s, 'wrapRounded'),
        a.forEach(l => {
          ;((o[l] = {}),
            Object.defineProperty(o[l], 'channels', { value: r[l].channels }),
            Object.defineProperty(o[l], 'labels', { value: r[l].labels }))
          const u = n(l)
          Object.keys(u).forEach(d => {
            const m = u[d]
            ;((o[l][d] = s(m)), (o[l][d].raw = i(m)))
          })
        }),
        (t.exports = o))
    })
    function ur() {
      return (ur =
        Object.assign ||
        function (e) {
          for (let t = 1; t < arguments.length; t++) {
            const r = arguments[t]
            for (const n in r)
              Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
          }
          return e
        }).apply(this, arguments)
    }
    function Fa(e, t) {
      if (e == null) return {}
      let r
      let n
      const o = {}
      const a = Object.keys(e)
      for (n = 0; n < a.length; n++) t.includes((r = a[n])) || (o[r] = e[r])
      return o
    }
    function Wa(e) {
      const t = ye(e)
      const r = ye(function (n) {
        t.current && t.current(n)
      })
      return ((t.current = e), r.current)
    }
    function ql(e, t, r) {
      const n = Wa(r)
      const o = z(function () {
        return e.toHsva(t)
      })
      const a = o[0]
      const i = o[1]
      const s = ye({ color: t, hsva: a })
      ;(X(
        function () {
          if (!e.equal(t, s.current.color)) {
            const u = e.toHsva(t)
            ;((s.current = { hsva: u, color: t }), i(u))
          }
        },
        [t, e]
      ),
        X(
          function () {
            let u
            gu(a, s.current.hsva) ||
              e.equal((u = e.fromHsva(a)), s.current.color) ||
              ((s.current = { hsva: a, color: u }), n(u))
          },
          [a, e, n]
        ))
      const l = Q(function (u) {
        i(function (d) {
          return Object.assign({}, d, u)
        })
      }, [])
      return [a, l]
    }
    let Dr
    let mn
    let Pa
    let Ul
    let Hl
    let Na
    let hn
    let La
    let Re
    let E2
    let v2
    let ja
    let A2
    let x2
    let w2
    let S2
    let Vl
    let Ma
    let Wn
    let zl
    let C2
    let Yn
    let D2
    let Gl
    let Wl
    let Yl
    let gu
    let Kl
    let T2
    let iC
    let k2
    let O2
    let Xl
    let Jl
    let I2
    let R2
    let _y
    let B2
    let Zl
    let _2
    let Fy
    let F2
    let Py
    const sC = ie(() => {
      ;(h(ur, 'u'),
        h(Fa, 'c'),
        h(Wa, 'i'),
        (Dr = h(function (e, t, r) {
          return (
            t === void 0 && (t = 0),
            r === void 0 && (r = 1),
            e > r ? r : e < t ? t : e
          )
        }, 's')),
        (mn = h(function (e) {
          return 'touches' in e
        }, 'f')),
        (Pa = h(function (e) {
          return (e && e.ownerDocument.defaultView) || self
        }, 'v')),
        (Ul = h(function (e, t, r) {
          const n = e.getBoundingClientRect()
          const o = mn(t)
            ? (function (a, i) {
                for (let s = 0; s < a.length; s++)
                  if (a[s].identifier === i) return a[s]
                return a[0]
              })(t.touches, r)
            : t
          return {
            left: Dr((o.pageX - (n.left + Pa(e).pageXOffset)) / n.width),
            top: Dr((o.pageY - (n.top + Pa(e).pageYOffset)) / n.height),
          }
        }, 'd')),
        (Hl = h(function (e) {
          !mn(e) && e.preventDefault()
        }, 'h')),
        (Na = c.memo(function (e) {
          const t = e.onMove
          const r = e.onKey
          const n = Fa(e, ['onMove', 'onKey'])
          const o = ye(null)
          const a = Wa(t)
          const i = Wa(r)
          const s = ye(null)
          const l = ye(!1)
          const u = Me(
            function () {
              const f = h(function (E) {
                ;(Hl(E),
                  (mn(E) ? E.touches.length > 0 : E.buttons > 0) && o.current
                    ? a(Ul(o.current, E, s.current))
                    : y(!1))
              }, 'e')
              const g = h(function () {
                return y(!1)
              }, 'r')
              function y(E) {
                const b = l.current
                const x = Pa(o.current)
                const S = E ? x.addEventListener : x.removeEventListener
                ;(S(b ? 'touchmove' : 'mousemove', f),
                  S(b ? 'touchend' : 'mouseup', g))
              }
              return (
                h(y, 't'),
                [
                  function (E) {
                    const b = E.nativeEvent
                    const x = o.current
                    if (
                      x &&
                      (Hl(b),
                      !(function (T, _) {
                        return _ && !mn(T)
                      })(b, l.current) && x)
                    ) {
                      if (mn(b)) {
                        l.current = !0
                        const S = b.changedTouches || []
                        S.length && (s.current = S[0].identifier)
                      }
                      ;(x.focus(), a(Ul(x, b, s.current)), y(!0))
                    }
                  },
                  function (E) {
                    const b = E.which || E.keyCode
                    b < 37 ||
                      b > 40 ||
                      (E.preventDefault(),
                      i({
                        left: b === 39 ? 0.05 : b === 37 ? -0.05 : 0,
                        top: b === 40 ? 0.05 : b === 38 ? -0.05 : 0,
                      }))
                  },
                  y,
                ]
              )
            },
            [i, a]
          )
          const d = u[0]
          const m = u[1]
          const p = u[2]
          return (
            X(
              function () {
                return p
              },
              [p]
            ),
            c.createElement(
              'div',
              ur({}, n, {
                onTouchStart: d,
                onMouseDown: d,
                className: 'react-colorful__interactive',
                ref: o,
                onKeyDown: m,
                tabIndex: 0,
                role: 'slider',
              })
            )
          )
        })),
        (hn = h(function (e) {
          return e.filter(Boolean).join(' ')
        }, 'g')),
        (La = h(function (e) {
          const t = e.color
          const r = e.left
          const n = e.top
          const o = n === void 0 ? 0.5 : n
          const a = hn(['react-colorful__pointer', e.className])
          return c.createElement(
            'div',
            {
              className: a,
              style: { top: 100 * o + '%', left: 100 * r + '%' },
            },
            c.createElement('div', {
              className: 'react-colorful__pointer-fill',
              style: { backgroundColor: t },
            })
          )
        }, 'p')),
        (Re = h(function (e, t, r) {
          return (
            t === void 0 && (t = 0),
            r === void 0 && (r = Math.pow(10, t)),
            Math.round(r * e) / r
          )
        }, 'b')),
        (E2 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }),
        (v2 = h(function (e) {
          return Gl(ja(e))
        }, 'x')),
        (ja = h(function (e) {
          return (
            e[0] === '#' && (e = e.substring(1)),
            e.length < 6
              ? {
                  r: parseInt(e[0] + e[0], 16),
                  g: parseInt(e[1] + e[1], 16),
                  b: parseInt(e[2] + e[2], 16),
                  a:
                    e.length === 4 ? Re(parseInt(e[3] + e[3], 16) / 255, 2) : 1,
                }
              : {
                  r: parseInt(e.substring(0, 2), 16),
                  g: parseInt(e.substring(2, 4), 16),
                  b: parseInt(e.substring(4, 6), 16),
                  a:
                    e.length === 8
                      ? Re(parseInt(e.substring(6, 8), 16) / 255, 2)
                      : 1,
                }
          )
        }, 'C')),
        (A2 = h(function (e, t) {
          return (t === void 0 && (t = 'deg'), Number(e) * (E2[t] || 1))
        }, 'E')),
        (x2 = h(function (e) {
          const t =
            /hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(
              e
            )
          return t
            ? w2({
                h: A2(t[1], t[2]),
                s: Number(t[3]),
                l: Number(t[4]),
                a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1),
              })
            : { h: 0, s: 0, v: 0, a: 1 }
        }, 'H')),
        (w2 = h(function (e) {
          let t = e.s
          const r = e.l
          return {
            h: e.h,
            s:
              (t *= (r < 50 ? r : 100 - r) / 100) > 0
                ? ((2 * t) / (r + t)) * 100
                : 0,
            v: r + t,
            a: e.a,
          }
        }, 'N')),
        (S2 = h(function (e) {
          return D2(zl(e))
        }, 'w')),
        (Vl = h(function (e) {
          const t = e.s
          const r = e.v
          const n = e.a
          const o = ((200 - t) * r) / 100
          return {
            h: Re(e.h),
            s: Re(
              o > 0 && o < 200
                ? ((t * r) / 100 / (o <= 100 ? o : 200 - o)) * 100
                : 0
            ),
            l: Re(o / 2),
            a: Re(n, 2),
          }
        }, 'y')),
        (Ma = h(function (e) {
          const t = Vl(e)
          return 'hsl(' + t.h + ', ' + t.s + '%, ' + t.l + '%)'
        }, 'q')),
        (Wn = h(function (e) {
          const t = Vl(e)
          return 'hsla(' + t.h + ', ' + t.s + '%, ' + t.l + '%, ' + t.a + ')'
        }, 'k')),
        (zl = h(function (e) {
          let t = e.h
          let r = e.s
          let n = e.v
          const o = e.a
          ;((t = (t / 360) * 6), (r /= 100), (n /= 100))
          const a = Math.floor(t)
          const i = n * (1 - r)
          const s = n * (1 - (t - a) * r)
          const l = n * (1 - (1 - t + a) * r)
          const u = a % 6
          return {
            r: Re(255 * [n, s, i, i, l, n][u]),
            g: Re(255 * [l, n, n, s, i, i][u]),
            b: Re(255 * [i, i, l, n, n, s][u]),
            a: Re(o, 2),
          }
        }, 'I')),
        (C2 = h(function (e) {
          const t =
            /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(
              e
            )
          return t
            ? Gl({
                r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
                g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
                b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
                a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1),
              })
            : { h: 0, s: 0, v: 0, a: 1 }
        }, 'z')),
        (Yn = h(function (e) {
          const t = e.toString(16)
          return t.length < 2 ? '0' + t : t
        }, 'D')),
        (D2 = h(function (e) {
          const t = e.r
          const r = e.g
          const n = e.b
          const o = e.a
          const a = o < 1 ? Yn(Re(255 * o)) : ''
          return '#' + Yn(t) + Yn(r) + Yn(n) + a
        }, 'K')),
        (Gl = h(function (e) {
          const t = e.r
          const r = e.g
          const n = e.b
          const o = e.a
          const a = Math.max(t, r, n)
          const i = a - Math.min(t, r, n)
          const s = i
            ? a === t
              ? (r - n) / i
              : a === r
                ? 2 + (n - t) / i
                : 4 + (t - r) / i
            : 0
          return {
            h: Re(60 * (s < 0 ? s + 6 : s)),
            s: Re(a ? (i / a) * 100 : 0),
            v: Re((a / 255) * 100),
            a: o,
          }
        }, 'L')),
        (Wl = c.memo(function (e) {
          const t = e.hue
          const r = e.onChange
          const n = hn(['react-colorful__hue', e.className])
          return c.createElement(
            'div',
            { className: n },
            c.createElement(
              Na,
              {
                onMove: h(function (o) {
                  r({ h: 360 * o.left })
                }, 'onMove'),
                onKey: h(function (o) {
                  r({ h: Dr(t + 360 * o.left, 0, 360) })
                }, 'onKey'),
                'aria-label': 'Hue',
                'aria-valuenow': Re(t),
                'aria-valuemax': '360',
                'aria-valuemin': '0',
              },
              c.createElement(La, {
                className: 'react-colorful__hue-pointer',
                left: t / 360,
                color: Ma({ h: t, s: 100, v: 100, a: 1 }),
              })
            )
          )
        })),
        (Yl = c.memo(function (e) {
          const t = e.hsva
          const r = e.onChange
          const n = { backgroundColor: Ma({ h: t.h, s: 100, v: 100, a: 1 }) }
          return c.createElement(
            'div',
            { className: 'react-colorful__saturation', style: n },
            c.createElement(
              Na,
              {
                onMove: h(function (o) {
                  r({ s: 100 * o.left, v: 100 - 100 * o.top })
                }, 'onMove'),
                onKey: h(function (o) {
                  r({
                    s: Dr(t.s + 100 * o.left, 0, 100),
                    v: Dr(t.v - 100 * o.top, 0, 100),
                  })
                }, 'onKey'),
                'aria-label': 'Color',
                'aria-valuetext':
                  'Saturation ' + Re(t.s) + '%, Brightness ' + Re(t.v) + '%',
              },
              c.createElement(La, {
                className: 'react-colorful__saturation-pointer',
                top: 1 - t.v / 100,
                left: t.s / 100,
                color: Ma(t),
              })
            )
          )
        })),
        (gu = h(function (e, t) {
          if (e === t) return !0
          for (const r in e) if (e[r] !== t[r]) return !1
          return !0
        }, 'F')),
        (Kl = h(function (e, t) {
          return e.replace(/\s/g, '') === t.replace(/\s/g, '')
        }, 'P')),
        (T2 = h(function (e, t) {
          return e.toLowerCase() === t.toLowerCase() || gu(ja(e), ja(t))
        }, 'X')),
        h(ql, 'Y'),
        (k2 = typeof window < 'u' ? ho : X),
        (O2 = h(function () {
          return (
            iC || (typeof __webpack_nonce__ < 'u' ? __webpack_nonce__ : void 0)
          )
        }, '$')),
        (Xl = new Map()),
        (Jl = h(function (e) {
          k2(function () {
            const t = e.current ? e.current.ownerDocument : document
            if (t !== void 0 && !Xl.has(t)) {
              const r = t.createElement('style')
              ;((r.innerHTML = `.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`),
                Xl.set(t, r))
              const n = O2()
              ;(n && r.setAttribute('nonce', n), t.head.appendChild(r))
            }
          }, [])
        }, 'Q')),
        (I2 = h(function (e) {
          const t = e.className
          const r = e.colorModel
          const n = e.color
          const o = n === void 0 ? r.defaultColor : n
          const a = e.onChange
          const i = Fa(e, ['className', 'colorModel', 'color', 'onChange'])
          const s = ye(null)
          Jl(s)
          const l = ql(r, o, a)
          const u = l[0]
          const d = l[1]
          const m = hn(['react-colorful', t])
          return c.createElement(
            'div',
            ur({}, i, { ref: s, className: m }),
            c.createElement(Yl, { hsva: u, onChange: d }),
            c.createElement(Wl, {
              hue: u.h,
              onChange: d,
              className: 'react-colorful__last-control',
            })
          )
        }, 'U')),
        (R2 = {
          defaultColor: '000',
          toHsva: v2,
          fromHsva: h(function (e) {
            return S2({ h: e.h, s: e.s, v: e.v, a: 1 })
          }, 'fromHsva'),
          equal: T2,
        }),
        (_y = h(function (e) {
          return c.createElement(I2, ur({}, e, { colorModel: R2 }))
        }, 'Z')),
        (B2 = h(function (e) {
          const t = e.className
          const r = e.hsva
          const n = e.onChange
          const o = {
            backgroundImage:
              'linear-gradient(90deg, ' +
              Wn(Object.assign({}, r, { a: 0 })) +
              ', ' +
              Wn(Object.assign({}, r, { a: 1 })) +
              ')',
          }
          const a = hn(['react-colorful__alpha', t])
          const i = Re(100 * r.a)
          return c.createElement(
            'div',
            { className: a },
            c.createElement('div', {
              className: 'react-colorful__alpha-gradient',
              style: o,
            }),
            c.createElement(
              Na,
              {
                onMove: h(function (s) {
                  n({ a: s.left })
                }, 'onMove'),
                onKey: h(function (s) {
                  n({ a: Dr(r.a + s.left) })
                }, 'onKey'),
                'aria-label': 'Alpha',
                'aria-valuetext': i + '%',
                'aria-valuenow': i,
                'aria-valuemin': '0',
                'aria-valuemax': '100',
              },
              c.createElement(La, {
                className: 'react-colorful__alpha-pointer',
                left: r.a,
                color: Wn(r),
              })
            )
          )
        }, 'ee')),
        (Zl = h(function (e) {
          const t = e.className
          const r = e.colorModel
          const n = e.color
          const o = n === void 0 ? r.defaultColor : n
          const a = e.onChange
          const i = Fa(e, ['className', 'colorModel', 'color', 'onChange'])
          const s = ye(null)
          Jl(s)
          const l = ql(r, o, a)
          const u = l[0]
          const d = l[1]
          const m = hn(['react-colorful', t])
          return c.createElement(
            'div',
            ur({}, i, { ref: s, className: m }),
            c.createElement(Yl, { hsva: u, onChange: d }),
            c.createElement(Wl, { hue: u.h, onChange: d }),
            c.createElement(B2, {
              hsva: u,
              onChange: d,
              className: 'react-colorful__last-control',
            })
          )
        }, 're')),
        (_2 = {
          defaultColor: 'hsla(0, 0%, 0%, 1)',
          toHsva: x2,
          fromHsva: Wn,
          equal: Kl,
        }),
        (Fy = h(function (e) {
          return c.createElement(Zl, ur({}, e, { colorModel: _2 }))
        }, 'ue')),
        (F2 = {
          defaultColor: 'rgba(0, 0, 0, 1)',
          toHsva: C2,
          fromHsva: h(function (e) {
            const t = zl(e)
            return 'rgba(' + t.r + ', ' + t.g + ', ' + t.b + ', ' + t.a + ')'
          }, 'fromHsva'),
          equal: Kl,
        }),
        (Py = h(function (e) {
          return c.createElement(Zl, ur({}, e, { colorModel: F2 }))
        }, 'He')))
    })
    const Ny = {}
    FS(Ny, { ColorControl: () => yu, default: () => Ly })
    let dt
    let P2
    let N2
    let L2
    let j2
    let M2
    let $2
    let q2
    let Ql
    let U2
    let H2
    let eu
    let $a
    let V2
    let z2
    let G2
    let qa
    let W2
    let Y2
    let Kn
    let tu
    let K2
    let X2
    let J2
    let Tr
    let Z2
    let Q2
    let Xn
    let e0
    let yu
    let Ly
    const lC = ie(() => {
      'use strict'
      ;((dt = it(aC())),
        pi(),
        sC(),
        Ot(),
        (P2 = R.div({
          position: 'relative',
          maxWidth: 250,
          '&[aria-readonly="true"]': { opacity: 0.5 },
        })),
        (N2 = R(De)({
          position: 'absolute',
          zIndex: 1,
          top: 4,
          left: 4,
          '[aria-readonly=true] &': { cursor: 'not-allowed' },
        })),
        (L2 = R.div({
          width: 200,
          margin: 5,
          '.react-colorful__saturation': { borderRadius: '4px 4px 0 0' },
          '.react-colorful__hue': {
            boxShadow: 'inset 0 0 0 1px rgb(0 0 0 / 5%)',
          },
          '.react-colorful__last-control': { borderRadius: '0 0 4px 4px' },
        })),
        (j2 = R(vt)(({ theme: e }) => ({
          fontFamily: e.typography.fonts.base,
        }))),
        (M2 = R.div({
          display: 'grid',
          gridTemplateColumns: 'repeat(9, 16px)',
          gap: 6,
          padding: 3,
          marginTop: 5,
          width: 200,
        })),
        ($2 = R.div(({ theme: e, active: t }) => ({
          width: 16,
          height: 16,
          boxShadow: t
            ? `${e.appBorderColor} 0 0 0 1px inset, ${e.textMutedColor}50 0 0 0 4px`
            : `${e.appBorderColor} 0 0 0 1px inset`,
          borderRadius: e.appBorderRadius,
        }))),
        (q2 = `url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')`),
        (Ql = h(({ value: e, style: t, ...r }) => {
          const n = `linear-gradient(${e}, ${e}), ${q2}, linear-gradient(#fff, #fff)`
          return c.createElement($2, {
            ...r,
            style: { ...t, backgroundImage: n },
          })
        }, 'Swatch')),
        (U2 = R($e.Input)(({ theme: e, readOnly: t }) => ({
          width: '100%',
          paddingLeft: 30,
          paddingRight: 30,
          boxSizing: 'border-box',
          fontFamily: e.typography.fonts.base,
        }))),
        (H2 = R(_c)(({ theme: e }) => ({
          position: 'absolute',
          zIndex: 1,
          top: 6,
          right: 7,
          width: 20,
          height: 20,
          padding: 4,
          boxSizing: 'border-box',
          cursor: 'pointer',
          color: e.input.color,
        }))),
        (eu = (e => ((e.RGB = 'rgb'), (e.HSL = 'hsl'), (e.HEX = 'hex'), e))(
          eu || {}
        )),
        ($a = Object.values(eu)),
        (V2 = /\(([0-9]+),\s*([0-9]+)%?,\s*([0-9]+)%?,?\s*([0-9.]+)?\)/),
        (z2 =
          /^\s*rgba?\(([0-9]+),\s*([0-9]+),\s*([0-9]+),?\s*([0-9.]+)?\)\s*$/i),
        (G2 =
          /^\s*hsla?\(([0-9]+),\s*([0-9]+)%,\s*([0-9]+)%,?\s*([0-9.]+)?\)\s*$/i),
        (qa = /^\s*#?([0-9a-f]{3}|[0-9a-f]{6})\s*$/i),
        (W2 = /^\s*#?([0-9a-f]{3})\s*$/i),
        (Y2 = { hex: _y, rgb: Py, hsl: Fy }),
        (Kn = {
          hex: 'transparent',
          rgb: 'rgba(0, 0, 0, 0)',
          hsl: 'hsla(0, 0%, 0%, 0)',
        }),
        (tu = h(e => {
          const t = e?.match(V2)
          if (!t) return [0, 0, 0, 1]
          const [, r, n, o, a = 1] = t
          return [r, n, o, a].map(Number)
        }, 'stringToArgs')),
        (K2 = h(e => {
          const [t, r, n, o] = tu(e)
          const [a, i, s] = dt.default.rgb.hsl([t, r, n]) || [0, 0, 0]
          return {
            valid: !0,
            value: e,
            keyword: dt.default.rgb.keyword([t, r, n]),
            colorSpace: 'rgb',
            rgb: e,
            hsl: `hsla(${a}, ${i}%, ${s}%, ${o})`,
            hex: `#${dt.default.rgb.hex([t, r, n]).toLowerCase()}`,
          }
        }, 'parseRgb')),
        (X2 = h(e => {
          const [t, r, n, o] = tu(e)
          const [a, i, s] = dt.default.hsl.rgb([t, r, n]) || [0, 0, 0]
          return {
            valid: !0,
            value: e,
            keyword: dt.default.hsl.keyword([t, r, n]),
            colorSpace: 'hsl',
            rgb: `rgba(${a}, ${i}, ${s}, ${o})`,
            hsl: e,
            hex: `#${dt.default.hsl.hex([t, r, n]).toLowerCase()}`,
          }
        }, 'parseHsl')),
        (J2 = h(e => {
          const t = e.replace('#', '')
          const r = dt.default.keyword.rgb(t) || dt.default.hex.rgb(t)
          const n = dt.default.rgb.hsl(r)
          let o = e
          ;/[^#a-f0-9]/i.test(e) ? (o = t) : qa.test(e) && (o = `#${t}`)
          let a = !0
          if (o.startsWith('#')) a = qa.test(o)
          else
            try {
              dt.default.keyword.hex(o)
            } catch {
              a = !1
            }
          return {
            valid: a,
            value: o,
            keyword: dt.default.rgb.keyword(r),
            colorSpace: 'hex',
            rgb: `rgba(${r[0]}, ${r[1]}, ${r[2]}, 1)`,
            hsl: `hsla(${n[0]}, ${n[1]}%, ${n[2]}%, 1)`,
            hex: o,
          }
        }, 'parseHexOrKeyword')),
        (Tr = h(e => {
          if (e) return z2.test(e) ? K2(e) : G2.test(e) ? X2(e) : J2(e)
        }, 'parseValue')),
        (Z2 = h((e, t, r) => {
          if (!e || !t?.valid) return Kn[r]
          if (r !== 'hex') return t?.[r] || Kn[r]
          if (!t.hex.startsWith('#'))
            try {
              return `#${dt.default.keyword.hex(t.hex)}`
            } catch {
              return Kn.hex
            }
          const n = t.hex.match(W2)
          if (!n) return qa.test(t.hex) ? t.hex : Kn.hex
          const [o, a, i] = n[1].split('')
          return `#${o}${o}${a}${a}${i}${i}`
        }, 'getRealValue')),
        (Q2 = h((e, t) => {
          const [r, n] = z(e || '')
          const [o, a] = z(() => Tr(r))
          const [i, s] = z(o?.colorSpace || 'hex')
          X(() => {
            const m = e || ''
            const p = Tr(m)
            ;(n(m), a(p), s(p?.colorSpace || 'hex'))
          }, [e])
          const l = Me(() => Z2(r, o, i).toLowerCase(), [r, o, i])
          const u = Q(
            m => {
              const p = Tr(m)
              const f = p?.value || m || ''
              ;(n(f),
                f === '' && (a(void 0), t(void 0)),
                p && (a(p), s(p.colorSpace), t(p.value)))
            },
            [t]
          )
          const d = Q(() => {
            const m = ($a.indexOf(i) + 1) % $a.length
            const p = $a[m]
            s(p)
            const f = o?.[p] || ''
            ;(n(f), t(f))
          }, [o, i, t])
          return {
            value: r,
            realValue: l,
            updateValue: u,
            color: o,
            colorSpace: i,
            cycleColorSpace: d,
          }
        }, 'useColorInput')),
        (Xn = h(e => e.replace(/\s*/, '').toLowerCase(), 'id')),
        (e0 = h((e, t, r) => {
          const [n, o] = z(t?.valid ? [t] : [])
          X(() => {
            t === void 0 && o([])
          }, [t])
          const a = Me(
            () =>
              (e || [])
                .map(s =>
                  typeof s === 'string'
                    ? Tr(s)
                    : s.title
                      ? { ...Tr(s.color), keyword: s.title }
                      : Tr(s.color)
                )
                .concat(n)
                .filter(Boolean)
                .slice(-27),
            [e, n]
          )
          const i = Q(
            s => {
              s?.valid &&
                (a.some(l => l && l[r] && Xn(l[r] || '') === Xn(s[r] || '')) ||
                  o(l => l.concat(s)))
            },
            [r, a]
          )
          return { presets: a, addPreset: i }
        }, 'usePresets')),
        (yu = h(
          ({
            name: e,
            value: t,
            onChange: r,
            onFocus: n,
            onBlur: o,
            presetColors: a,
            startOpen: i = !1,
            argType: s,
          }) => {
            const l = Q(xy(r, 200), [r])
            const {
              value: u,
              realValue: d,
              updateValue: m,
              color: p,
              colorSpace: f,
              cycleColorSpace: g,
            } = Q2(t, l)
            const { presets: y, addPreset: E } = e0(a ?? [], p, f)
            const b = Y2[f]
            const x = !!s?.table?.readonly
            return c.createElement(
              P2,
              { 'aria-readonly': x },
              c.createElement(
                N2,
                {
                  startOpen: i,
                  trigger: x ? null : void 0,
                  closeOnOutsideClick: !0,
                  onVisibleChange: () => p && E(p),
                  tooltip: c.createElement(
                    L2,
                    null,
                    c.createElement(b, {
                      color: d === 'transparent' ? '#000000' : d,
                      onChange: m,
                      onFocus: n,
                      onBlur: o,
                    }),
                    y.length > 0 &&
                      c.createElement(
                        M2,
                        null,
                        y.map((S, T) =>
                          c.createElement(
                            De,
                            {
                              key: `${S?.value || T}-${T}`,
                              hasChrome: !1,
                              tooltip: c.createElement(j2, {
                                note: S?.keyword || S?.value || '',
                              }),
                            },
                            c.createElement(Ql, {
                              value: S?.[f] || '',
                              active: !!(
                                p &&
                                S &&
                                S[f] &&
                                Xn(S[f] || '') === Xn(p[f])
                              ),
                              onClick: () => S && m(S.value || ''),
                            })
                          )
                        )
                      )
                  ),
                },
                c.createElement(Ql, { value: d, style: { margin: 4 } })
              ),
              c.createElement(U2, {
                id: mt(e),
                value: u,
                onChange: S => m(S.target.value),
                onFocus: S => S.target.select(),
                readOnly: x,
                placeholder: 'Choose color...',
              }),
              u ? c.createElement(H2, { onClick: g }) : null
            )
          },
          'ColorControl'
        )),
        (Ly = yu))
    })
    const uC = ge((e, t) => {
      ;(function (r) {
        if (typeof e === 'object' && typeof t < 'u') t.exports = r()
        else if (typeof define === 'function' && define.amd) define([], r)
        else {
          let n
          ;(typeof window < 'u' || typeof window < 'u'
            ? (n = window)
            : typeof self < 'u'
              ? (n = self)
              : (n = this),
            (n.memoizerific = r()))
        }
      })(function () {
        let r, n, o
        return h(function a(i, s, l) {
          function u(p, f) {
            if (!s[p]) {
              if (!i[p]) {
                const g = typeof _a === 'function' && _a
                if (!f && g) return g(p, !0)
                if (d) return d(p, !0)
                const y = new Error("Cannot find module '" + p + "'")
                throw ((y.code = 'MODULE_NOT_FOUND'), y)
              }
              const E = (s[p] = { exports: {} })
              i[p][0].call(
                E.exports,
                function (b) {
                  const x = i[p][1][b]
                  return u(x || b)
                },
                E,
                E.exports,
                a,
                i,
                s,
                l
              )
            }
            return s[p].exports
          }
          h(u, 's')
          for (var d = typeof _a === 'function' && _a, m = 0; m < l.length; m++)
            u(l[m])
          return u
        }, 'e')(
          {
            1: [
              function (a, i, s) {
                i.exports = function (l) {
                  if (typeof Map !== 'function' || l) {
                    const u = a('./similar')
                    return new u()
                  } else return new Map()
                }
              },
              { './similar': 2 },
            ],
            2: [
              function (a, i, s) {
                function l() {
                  return (
                    (this.list = []),
                    (this.lastItem = void 0),
                    (this.size = 0),
                    this
                  )
                }
                ;(h(l, 'Similar'),
                  (l.prototype.get = function (u) {
                    let d
                    if (this.lastItem && this.isEqual(this.lastItem.key, u))
                      return this.lastItem.val
                    if (((d = this.indexOf(u)), d >= 0))
                      return ((this.lastItem = this.list[d]), this.list[d].val)
                  }),
                  (l.prototype.set = function (u, d) {
                    let m
                    return this.lastItem && this.isEqual(this.lastItem.key, u)
                      ? ((this.lastItem.val = d), this)
                      : ((m = this.indexOf(u)),
                        m >= 0
                          ? ((this.lastItem = this.list[m]),
                            (this.list[m].val = d),
                            this)
                          : ((this.lastItem = { key: u, val: d }),
                            this.list.push(this.lastItem),
                            this.size++,
                            this))
                  }),
                  (l.prototype.delete = function (u) {
                    let d
                    if (
                      (this.lastItem &&
                        this.isEqual(this.lastItem.key, u) &&
                        (this.lastItem = void 0),
                      (d = this.indexOf(u)),
                      d >= 0)
                    )
                      return (this.size--, this.list.splice(d, 1)[0])
                  }),
                  (l.prototype.has = function (u) {
                    let d
                    return this.lastItem && this.isEqual(this.lastItem.key, u)
                      ? !0
                      : ((d = this.indexOf(u)),
                        d >= 0 ? ((this.lastItem = this.list[d]), !0) : !1)
                  }),
                  (l.prototype.forEach = function (u, d) {
                    let m
                    for (m = 0; m < this.size; m++)
                      u.call(
                        d || this,
                        this.list[m].val,
                        this.list[m].key,
                        this
                      )
                  }),
                  (l.prototype.indexOf = function (u) {
                    let d
                    for (d = 0; d < this.size; d++)
                      if (this.isEqual(this.list[d].key, u)) return d
                    return -1
                  }),
                  (l.prototype.isEqual = function (u, d) {
                    return u === d || (u !== u && d !== d)
                  }),
                  (i.exports = l))
              },
              {},
            ],
            3: [
              function (a, i, s) {
                const l = a('map-or-similar')
                i.exports = function (p) {
                  const f = new l(!1)
                  const g = []
                  return function (y) {
                    var E = h(function () {
                      let b = f
                      let x
                      let S
                      const T = arguments.length - 1
                      const _ = Array(T + 1)
                      let O = !0
                      let k
                      if ((E.numArgs || E.numArgs === 0) && E.numArgs !== T + 1)
                        throw new Error(
                          'Memoizerific functions should always be called with the same number of arguments'
                        )
                      for (k = 0; k < T; k++) {
                        if (
                          ((_[k] = { cacheItem: b, arg: arguments[k] }),
                          b.has(arguments[k]))
                        ) {
                          b = b.get(arguments[k])
                          continue
                        }
                        ;((O = !1),
                          (x = new l(!1)),
                          b.set(arguments[k], x),
                          (b = x))
                      }
                      return (
                        O &&
                          (b.has(arguments[T])
                            ? (S = b.get(arguments[T]))
                            : (O = !1)),
                        O ||
                          ((S = y.apply(null, arguments)),
                          b.set(arguments[T], S)),
                        p > 0 &&
                          ((_[T] = { cacheItem: b, arg: arguments[T] }),
                          O ? u(g, _) : g.push(_),
                          g.length > p && d(g.shift())),
                        (E.wasMemoized = O),
                        (E.numArgs = T + 1),
                        S
                      )
                    }, 'memoizerific')
                    return (
                      (E.limit = p),
                      (E.wasMemoized = !1),
                      (E.cache = f),
                      (E.lru = g),
                      E
                    )
                  }
                }
                function u(p, f) {
                  const g = p.length
                  const y = f.length
                  let E
                  let b
                  let x
                  for (b = 0; b < g; b++) {
                    for (E = !0, x = 0; x < y; x++)
                      if (!m(p[b][x].arg, f[x].arg)) {
                        E = !1
                        break
                      }
                    if (E) break
                  }
                  p.push(p.splice(b, 1)[0])
                }
                h(u, 'moveToMostRecentLru')
                function d(p) {
                  const f = p.length
                  let g = p[f - 1]
                  let y
                  let E
                  for (
                    g.cacheItem.delete(g.arg), E = f - 2;
                    E >= 0 &&
                    ((g = p[E]), (y = g.cacheItem.get(g.arg)), !y || !y.size);
                    E--
                  )
                    g.cacheItem.delete(g.arg)
                }
                h(d, 'removeCachedResult')
                function m(p, f) {
                  return p === f || (p !== p && f !== f)
                }
                h(m, 'isEqual')
              },
              { 'map-or-similar': 1 },
            ],
          },
          {},
          [3]
        )(3)
      })
    })
    const jy = ge((e, t) => {
      t.exports = {
        Aacute: '\xC1',
        aacute: '\xE1',
        Abreve: '\u0102',
        abreve: '\u0103',
        ac: '\u223E',
        acd: '\u223F',
        acE: '\u223E\u0333',
        Acirc: '\xC2',
        acirc: '\xE2',
        acute: '\xB4',
        Acy: '\u0410',
        acy: '\u0430',
        AElig: '\xC6',
        aelig: '\xE6',
        af: '\u2061',
        Afr: '\u{1D504}',
        afr: '\u{1D51E}',
        Agrave: '\xC0',
        agrave: '\xE0',
        alefsym: '\u2135',
        aleph: '\u2135',
        Alpha: '\u0391',
        alpha: '\u03B1',
        Amacr: '\u0100',
        amacr: '\u0101',
        amalg: '\u2A3F',
        amp: '&',
        AMP: '&',
        andand: '\u2A55',
        And: '\u2A53',
        and: '\u2227',
        andd: '\u2A5C',
        andslope: '\u2A58',
        andv: '\u2A5A',
        ang: '\u2220',
        ange: '\u29A4',
        angle: '\u2220',
        angmsdaa: '\u29A8',
        angmsdab: '\u29A9',
        angmsdac: '\u29AA',
        angmsdad: '\u29AB',
        angmsdae: '\u29AC',
        angmsdaf: '\u29AD',
        angmsdag: '\u29AE',
        angmsdah: '\u29AF',
        angmsd: '\u2221',
        angrt: '\u221F',
        angrtvb: '\u22BE',
        angrtvbd: '\u299D',
        angsph: '\u2222',
        angst: '\xC5',
        angzarr: '\u237C',
        Aogon: '\u0104',
        aogon: '\u0105',
        Aopf: '\u{1D538}',
        aopf: '\u{1D552}',
        apacir: '\u2A6F',
        ap: '\u2248',
        apE: '\u2A70',
        ape: '\u224A',
        apid: '\u224B',
        apos: "'",
        ApplyFunction: '\u2061',
        approx: '\u2248',
        approxeq: '\u224A',
        Aring: '\xC5',
        aring: '\xE5',
        Ascr: '\u{1D49C}',
        ascr: '\u{1D4B6}',
        Assign: '\u2254',
        ast: '*',
        asymp: '\u2248',
        asympeq: '\u224D',
        Atilde: '\xC3',
        atilde: '\xE3',
        Auml: '\xC4',
        auml: '\xE4',
        awconint: '\u2233',
        awint: '\u2A11',
        backcong: '\u224C',
        backepsilon: '\u03F6',
        backprime: '\u2035',
        backsim: '\u223D',
        backsimeq: '\u22CD',
        Backslash: '\u2216',
        Barv: '\u2AE7',
        barvee: '\u22BD',
        barwed: '\u2305',
        Barwed: '\u2306',
        barwedge: '\u2305',
        bbrk: '\u23B5',
        bbrktbrk: '\u23B6',
        bcong: '\u224C',
        Bcy: '\u0411',
        bcy: '\u0431',
        bdquo: '\u201E',
        becaus: '\u2235',
        because: '\u2235',
        Because: '\u2235',
        bemptyv: '\u29B0',
        bepsi: '\u03F6',
        bernou: '\u212C',
        Bernoullis: '\u212C',
        Beta: '\u0392',
        beta: '\u03B2',
        beth: '\u2136',
        between: '\u226C',
        Bfr: '\u{1D505}',
        bfr: '\u{1D51F}',
        bigcap: '\u22C2',
        bigcirc: '\u25EF',
        bigcup: '\u22C3',
        bigodot: '\u2A00',
        bigoplus: '\u2A01',
        bigotimes: '\u2A02',
        bigsqcup: '\u2A06',
        bigstar: '\u2605',
        bigtriangledown: '\u25BD',
        bigtriangleup: '\u25B3',
        biguplus: '\u2A04',
        bigvee: '\u22C1',
        bigwedge: '\u22C0',
        bkarow: '\u290D',
        blacklozenge: '\u29EB',
        blacksquare: '\u25AA',
        blacktriangle: '\u25B4',
        blacktriangledown: '\u25BE',
        blacktriangleleft: '\u25C2',
        blacktriangleright: '\u25B8',
        blank: '\u2423',
        blk12: '\u2592',
        blk14: '\u2591',
        blk34: '\u2593',
        block: '\u2588',
        bne: '=\u20E5',
        bnequiv: '\u2261\u20E5',
        bNot: '\u2AED',
        bnot: '\u2310',
        Bopf: '\u{1D539}',
        bopf: '\u{1D553}',
        bot: '\u22A5',
        bottom: '\u22A5',
        bowtie: '\u22C8',
        boxbox: '\u29C9',
        boxdl: '\u2510',
        boxdL: '\u2555',
        boxDl: '\u2556',
        boxDL: '\u2557',
        boxdr: '\u250C',
        boxdR: '\u2552',
        boxDr: '\u2553',
        boxDR: '\u2554',
        boxh: '\u2500',
        boxH: '\u2550',
        boxhd: '\u252C',
        boxHd: '\u2564',
        boxhD: '\u2565',
        boxHD: '\u2566',
        boxhu: '\u2534',
        boxHu: '\u2567',
        boxhU: '\u2568',
        boxHU: '\u2569',
        boxminus: '\u229F',
        boxplus: '\u229E',
        boxtimes: '\u22A0',
        boxul: '\u2518',
        boxuL: '\u255B',
        boxUl: '\u255C',
        boxUL: '\u255D',
        boxur: '\u2514',
        boxuR: '\u2558',
        boxUr: '\u2559',
        boxUR: '\u255A',
        boxv: '\u2502',
        boxV: '\u2551',
        boxvh: '\u253C',
        boxvH: '\u256A',
        boxVh: '\u256B',
        boxVH: '\u256C',
        boxvl: '\u2524',
        boxvL: '\u2561',
        boxVl: '\u2562',
        boxVL: '\u2563',
        boxvr: '\u251C',
        boxvR: '\u255E',
        boxVr: '\u255F',
        boxVR: '\u2560',
        bprime: '\u2035',
        breve: '\u02D8',
        Breve: '\u02D8',
        brvbar: '\xA6',
        bscr: '\u{1D4B7}',
        Bscr: '\u212C',
        bsemi: '\u204F',
        bsim: '\u223D',
        bsime: '\u22CD',
        bsolb: '\u29C5',
        bsol: '\\',
        bsolhsub: '\u27C8',
        bull: '\u2022',
        bullet: '\u2022',
        bump: '\u224E',
        bumpE: '\u2AAE',
        bumpe: '\u224F',
        Bumpeq: '\u224E',
        bumpeq: '\u224F',
        Cacute: '\u0106',
        cacute: '\u0107',
        capand: '\u2A44',
        capbrcup: '\u2A49',
        capcap: '\u2A4B',
        cap: '\u2229',
        Cap: '\u22D2',
        capcup: '\u2A47',
        capdot: '\u2A40',
        CapitalDifferentialD: '\u2145',
        caps: '\u2229\uFE00',
        caret: '\u2041',
        caron: '\u02C7',
        Cayleys: '\u212D',
        ccaps: '\u2A4D',
        Ccaron: '\u010C',
        ccaron: '\u010D',
        Ccedil: '\xC7',
        ccedil: '\xE7',
        Ccirc: '\u0108',
        ccirc: '\u0109',
        Cconint: '\u2230',
        ccups: '\u2A4C',
        ccupssm: '\u2A50',
        Cdot: '\u010A',
        cdot: '\u010B',
        cedil: '\xB8',
        Cedilla: '\xB8',
        cemptyv: '\u29B2',
        cent: '\xA2',
        centerdot: '\xB7',
        CenterDot: '\xB7',
        cfr: '\u{1D520}',
        Cfr: '\u212D',
        CHcy: '\u0427',
        chcy: '\u0447',
        check: '\u2713',
        checkmark: '\u2713',
        Chi: '\u03A7',
        chi: '\u03C7',
        circ: '\u02C6',
        circeq: '\u2257',
        circlearrowleft: '\u21BA',
        circlearrowright: '\u21BB',
        circledast: '\u229B',
        circledcirc: '\u229A',
        circleddash: '\u229D',
        CircleDot: '\u2299',
        circledR: '\xAE',
        circledS: '\u24C8',
        CircleMinus: '\u2296',
        CirclePlus: '\u2295',
        CircleTimes: '\u2297',
        cir: '\u25CB',
        cirE: '\u29C3',
        cire: '\u2257',
        cirfnint: '\u2A10',
        cirmid: '\u2AEF',
        cirscir: '\u29C2',
        ClockwiseContourIntegral: '\u2232',
        CloseCurlyDoubleQuote: '\u201D',
        CloseCurlyQuote: '\u2019',
        clubs: '\u2663',
        clubsuit: '\u2663',
        colon: ':',
        Colon: '\u2237',
        Colone: '\u2A74',
        colone: '\u2254',
        coloneq: '\u2254',
        comma: ',',
        commat: '@',
        comp: '\u2201',
        compfn: '\u2218',
        complement: '\u2201',
        complexes: '\u2102',
        cong: '\u2245',
        congdot: '\u2A6D',
        Congruent: '\u2261',
        conint: '\u222E',
        Conint: '\u222F',
        ContourIntegral: '\u222E',
        copf: '\u{1D554}',
        Copf: '\u2102',
        coprod: '\u2210',
        Coproduct: '\u2210',
        copy: '\xA9',
        COPY: '\xA9',
        copysr: '\u2117',
        CounterClockwiseContourIntegral: '\u2233',
        crarr: '\u21B5',
        cross: '\u2717',
        Cross: '\u2A2F',
        Cscr: '\u{1D49E}',
        cscr: '\u{1D4B8}',
        csub: '\u2ACF',
        csube: '\u2AD1',
        csup: '\u2AD0',
        csupe: '\u2AD2',
        ctdot: '\u22EF',
        cudarrl: '\u2938',
        cudarrr: '\u2935',
        cuepr: '\u22DE',
        cuesc: '\u22DF',
        cularr: '\u21B6',
        cularrp: '\u293D',
        cupbrcap: '\u2A48',
        cupcap: '\u2A46',
        CupCap: '\u224D',
        cup: '\u222A',
        Cup: '\u22D3',
        cupcup: '\u2A4A',
        cupdot: '\u228D',
        cupor: '\u2A45',
        cups: '\u222A\uFE00',
        curarr: '\u21B7',
        curarrm: '\u293C',
        curlyeqprec: '\u22DE',
        curlyeqsucc: '\u22DF',
        curlyvee: '\u22CE',
        curlywedge: '\u22CF',
        curren: '\xA4',
        curvearrowleft: '\u21B6',
        curvearrowright: '\u21B7',
        cuvee: '\u22CE',
        cuwed: '\u22CF',
        cwconint: '\u2232',
        cwint: '\u2231',
        cylcty: '\u232D',
        dagger: '\u2020',
        Dagger: '\u2021',
        daleth: '\u2138',
        darr: '\u2193',
        Darr: '\u21A1',
        dArr: '\u21D3',
        dash: '\u2010',
        Dashv: '\u2AE4',
        dashv: '\u22A3',
        dbkarow: '\u290F',
        dblac: '\u02DD',
        Dcaron: '\u010E',
        dcaron: '\u010F',
        Dcy: '\u0414',
        dcy: '\u0434',
        ddagger: '\u2021',
        ddarr: '\u21CA',
        DD: '\u2145',
        dd: '\u2146',
        DDotrahd: '\u2911',
        ddotseq: '\u2A77',
        deg: '\xB0',
        Del: '\u2207',
        Delta: '\u0394',
        delta: '\u03B4',
        demptyv: '\u29B1',
        dfisht: '\u297F',
        Dfr: '\u{1D507}',
        dfr: '\u{1D521}',
        dHar: '\u2965',
        dharl: '\u21C3',
        dharr: '\u21C2',
        DiacriticalAcute: '\xB4',
        DiacriticalDot: '\u02D9',
        DiacriticalDoubleAcute: '\u02DD',
        DiacriticalGrave: '`',
        DiacriticalTilde: '\u02DC',
        diam: '\u22C4',
        diamond: '\u22C4',
        Diamond: '\u22C4',
        diamondsuit: '\u2666',
        diams: '\u2666',
        die: '\xA8',
        DifferentialD: '\u2146',
        digamma: '\u03DD',
        disin: '\u22F2',
        div: '\xF7',
        divide: '\xF7',
        divideontimes: '\u22C7',
        divonx: '\u22C7',
        DJcy: '\u0402',
        djcy: '\u0452',
        dlcorn: '\u231E',
        dlcrop: '\u230D',
        dollar: '$',
        Dopf: '\u{1D53B}',
        dopf: '\u{1D555}',
        Dot: '\xA8',
        dot: '\u02D9',
        DotDot: '\u20DC',
        doteq: '\u2250',
        doteqdot: '\u2251',
        DotEqual: '\u2250',
        dotminus: '\u2238',
        dotplus: '\u2214',
        dotsquare: '\u22A1',
        doublebarwedge: '\u2306',
        DoubleContourIntegral: '\u222F',
        DoubleDot: '\xA8',
        DoubleDownArrow: '\u21D3',
        DoubleLeftArrow: '\u21D0',
        DoubleLeftRightArrow: '\u21D4',
        DoubleLeftTee: '\u2AE4',
        DoubleLongLeftArrow: '\u27F8',
        DoubleLongLeftRightArrow: '\u27FA',
        DoubleLongRightArrow: '\u27F9',
        DoubleRightArrow: '\u21D2',
        DoubleRightTee: '\u22A8',
        DoubleUpArrow: '\u21D1',
        DoubleUpDownArrow: '\u21D5',
        DoubleVerticalBar: '\u2225',
        DownArrowBar: '\u2913',
        downarrow: '\u2193',
        DownArrow: '\u2193',
        Downarrow: '\u21D3',
        DownArrowUpArrow: '\u21F5',
        DownBreve: '\u0311',
        downdownarrows: '\u21CA',
        downharpoonleft: '\u21C3',
        downharpoonright: '\u21C2',
        DownLeftRightVector: '\u2950',
        DownLeftTeeVector: '\u295E',
        DownLeftVectorBar: '\u2956',
        DownLeftVector: '\u21BD',
        DownRightTeeVector: '\u295F',
        DownRightVectorBar: '\u2957',
        DownRightVector: '\u21C1',
        DownTeeArrow: '\u21A7',
        DownTee: '\u22A4',
        drbkarow: '\u2910',
        drcorn: '\u231F',
        drcrop: '\u230C',
        Dscr: '\u{1D49F}',
        dscr: '\u{1D4B9}',
        DScy: '\u0405',
        dscy: '\u0455',
        dsol: '\u29F6',
        Dstrok: '\u0110',
        dstrok: '\u0111',
        dtdot: '\u22F1',
        dtri: '\u25BF',
        dtrif: '\u25BE',
        duarr: '\u21F5',
        duhar: '\u296F',
        dwangle: '\u29A6',
        DZcy: '\u040F',
        dzcy: '\u045F',
        dzigrarr: '\u27FF',
        Eacute: '\xC9',
        eacute: '\xE9',
        easter: '\u2A6E',
        Ecaron: '\u011A',
        ecaron: '\u011B',
        Ecirc: '\xCA',
        ecirc: '\xEA',
        ecir: '\u2256',
        ecolon: '\u2255',
        Ecy: '\u042D',
        ecy: '\u044D',
        eDDot: '\u2A77',
        Edot: '\u0116',
        edot: '\u0117',
        eDot: '\u2251',
        ee: '\u2147',
        efDot: '\u2252',
        Efr: '\u{1D508}',
        efr: '\u{1D522}',
        eg: '\u2A9A',
        Egrave: '\xC8',
        egrave: '\xE8',
        egs: '\u2A96',
        egsdot: '\u2A98',
        el: '\u2A99',
        Element: '\u2208',
        elinters: '\u23E7',
        ell: '\u2113',
        els: '\u2A95',
        elsdot: '\u2A97',
        Emacr: '\u0112',
        emacr: '\u0113',
        empty: '\u2205',
        emptyset: '\u2205',
        EmptySmallSquare: '\u25FB',
        emptyv: '\u2205',
        EmptyVerySmallSquare: '\u25AB',
        emsp13: '\u2004',
        emsp14: '\u2005',
        emsp: '\u2003',
        ENG: '\u014A',
        eng: '\u014B',
        ensp: '\u2002',
        Eogon: '\u0118',
        eogon: '\u0119',
        Eopf: '\u{1D53C}',
        eopf: '\u{1D556}',
        epar: '\u22D5',
        eparsl: '\u29E3',
        eplus: '\u2A71',
        epsi: '\u03B5',
        Epsilon: '\u0395',
        epsilon: '\u03B5',
        epsiv: '\u03F5',
        eqcirc: '\u2256',
        eqcolon: '\u2255',
        eqsim: '\u2242',
        eqslantgtr: '\u2A96',
        eqslantless: '\u2A95',
        Equal: '\u2A75',
        equals: '=',
        EqualTilde: '\u2242',
        equest: '\u225F',
        Equilibrium: '\u21CC',
        equiv: '\u2261',
        equivDD: '\u2A78',
        eqvparsl: '\u29E5',
        erarr: '\u2971',
        erDot: '\u2253',
        escr: '\u212F',
        Escr: '\u2130',
        esdot: '\u2250',
        Esim: '\u2A73',
        esim: '\u2242',
        Eta: '\u0397',
        eta: '\u03B7',
        ETH: '\xD0',
        eth: '\xF0',
        Euml: '\xCB',
        euml: '\xEB',
        euro: '\u20AC',
        excl: '!',
        exist: '\u2203',
        Exists: '\u2203',
        expectation: '\u2130',
        exponentiale: '\u2147',
        ExponentialE: '\u2147',
        fallingdotseq: '\u2252',
        Fcy: '\u0424',
        fcy: '\u0444',
        female: '\u2640',
        ffilig: '\uFB03',
        fflig: '\uFB00',
        ffllig: '\uFB04',
        Ffr: '\u{1D509}',
        ffr: '\u{1D523}',
        filig: '\uFB01',
        FilledSmallSquare: '\u25FC',
        FilledVerySmallSquare: '\u25AA',
        fjlig: 'fj',
        flat: '\u266D',
        fllig: '\uFB02',
        fltns: '\u25B1',
        fnof: '\u0192',
        Fopf: '\u{1D53D}',
        fopf: '\u{1D557}',
        forall: '\u2200',
        ForAll: '\u2200',
        fork: '\u22D4',
        forkv: '\u2AD9',
        Fouriertrf: '\u2131',
        fpartint: '\u2A0D',
        frac12: '\xBD',
        frac13: '\u2153',
        frac14: '\xBC',
        frac15: '\u2155',
        frac16: '\u2159',
        frac18: '\u215B',
        frac23: '\u2154',
        frac25: '\u2156',
        frac34: '\xBE',
        frac35: '\u2157',
        frac38: '\u215C',
        frac45: '\u2158',
        frac56: '\u215A',
        frac58: '\u215D',
        frac78: '\u215E',
        frasl: '\u2044',
        frown: '\u2322',
        fscr: '\u{1D4BB}',
        Fscr: '\u2131',
        gacute: '\u01F5',
        Gamma: '\u0393',
        gamma: '\u03B3',
        Gammad: '\u03DC',
        gammad: '\u03DD',
        gap: '\u2A86',
        Gbreve: '\u011E',
        gbreve: '\u011F',
        Gcedil: '\u0122',
        Gcirc: '\u011C',
        gcirc: '\u011D',
        Gcy: '\u0413',
        gcy: '\u0433',
        Gdot: '\u0120',
        gdot: '\u0121',
        ge: '\u2265',
        gE: '\u2267',
        gEl: '\u2A8C',
        gel: '\u22DB',
        geq: '\u2265',
        geqq: '\u2267',
        geqslant: '\u2A7E',
        gescc: '\u2AA9',
        ges: '\u2A7E',
        gesdot: '\u2A80',
        gesdoto: '\u2A82',
        gesdotol: '\u2A84',
        gesl: '\u22DB\uFE00',
        gesles: '\u2A94',
        Gfr: '\u{1D50A}',
        gfr: '\u{1D524}',
        gg: '\u226B',
        Gg: '\u22D9',
        ggg: '\u22D9',
        gimel: '\u2137',
        GJcy: '\u0403',
        gjcy: '\u0453',
        gla: '\u2AA5',
        gl: '\u2277',
        glE: '\u2A92',
        glj: '\u2AA4',
        gnap: '\u2A8A',
        gnapprox: '\u2A8A',
        gne: '\u2A88',
        gnE: '\u2269',
        gneq: '\u2A88',
        gneqq: '\u2269',
        gnsim: '\u22E7',
        Gopf: '\u{1D53E}',
        gopf: '\u{1D558}',
        grave: '`',
        GreaterEqual: '\u2265',
        GreaterEqualLess: '\u22DB',
        GreaterFullEqual: '\u2267',
        GreaterGreater: '\u2AA2',
        GreaterLess: '\u2277',
        GreaterSlantEqual: '\u2A7E',
        GreaterTilde: '\u2273',
        Gscr: '\u{1D4A2}',
        gscr: '\u210A',
        gsim: '\u2273',
        gsime: '\u2A8E',
        gsiml: '\u2A90',
        gtcc: '\u2AA7',
        gtcir: '\u2A7A',
        gt: '>',
        GT: '>',
        Gt: '\u226B',
        gtdot: '\u22D7',
        gtlPar: '\u2995',
        gtquest: '\u2A7C',
        gtrapprox: '\u2A86',
        gtrarr: '\u2978',
        gtrdot: '\u22D7',
        gtreqless: '\u22DB',
        gtreqqless: '\u2A8C',
        gtrless: '\u2277',
        gtrsim: '\u2273',
        gvertneqq: '\u2269\uFE00',
        gvnE: '\u2269\uFE00',
        Hacek: '\u02C7',
        hairsp: '\u200A',
        half: '\xBD',
        hamilt: '\u210B',
        HARDcy: '\u042A',
        hardcy: '\u044A',
        harrcir: '\u2948',
        harr: '\u2194',
        hArr: '\u21D4',
        harrw: '\u21AD',
        Hat: '^',
        hbar: '\u210F',
        Hcirc: '\u0124',
        hcirc: '\u0125',
        hearts: '\u2665',
        heartsuit: '\u2665',
        hellip: '\u2026',
        hercon: '\u22B9',
        hfr: '\u{1D525}',
        Hfr: '\u210C',
        HilbertSpace: '\u210B',
        hksearow: '\u2925',
        hkswarow: '\u2926',
        hoarr: '\u21FF',
        homtht: '\u223B',
        hookleftarrow: '\u21A9',
        hookrightarrow: '\u21AA',
        hopf: '\u{1D559}',
        Hopf: '\u210D',
        horbar: '\u2015',
        HorizontalLine: '\u2500',
        hscr: '\u{1D4BD}',
        Hscr: '\u210B',
        hslash: '\u210F',
        Hstrok: '\u0126',
        hstrok: '\u0127',
        HumpDownHump: '\u224E',
        HumpEqual: '\u224F',
        hybull: '\u2043',
        hyphen: '\u2010',
        Iacute: '\xCD',
        iacute: '\xED',
        ic: '\u2063',
        Icirc: '\xCE',
        icirc: '\xEE',
        Icy: '\u0418',
        icy: '\u0438',
        Idot: '\u0130',
        IEcy: '\u0415',
        iecy: '\u0435',
        iexcl: '\xA1',
        iff: '\u21D4',
        ifr: '\u{1D526}',
        Ifr: '\u2111',
        Igrave: '\xCC',
        igrave: '\xEC',
        ii: '\u2148',
        iiiint: '\u2A0C',
        iiint: '\u222D',
        iinfin: '\u29DC',
        iiota: '\u2129',
        IJlig: '\u0132',
        ijlig: '\u0133',
        Imacr: '\u012A',
        imacr: '\u012B',
        image: '\u2111',
        ImaginaryI: '\u2148',
        imagline: '\u2110',
        imagpart: '\u2111',
        imath: '\u0131',
        Im: '\u2111',
        imof: '\u22B7',
        imped: '\u01B5',
        Implies: '\u21D2',
        incare: '\u2105',
        in: '\u2208',
        infin: '\u221E',
        infintie: '\u29DD',
        inodot: '\u0131',
        intcal: '\u22BA',
        int: '\u222B',
        Int: '\u222C',
        integers: '\u2124',
        Integral: '\u222B',
        intercal: '\u22BA',
        Intersection: '\u22C2',
        intlarhk: '\u2A17',
        intprod: '\u2A3C',
        InvisibleComma: '\u2063',
        InvisibleTimes: '\u2062',
        IOcy: '\u0401',
        iocy: '\u0451',
        Iogon: '\u012E',
        iogon: '\u012F',
        Iopf: '\u{1D540}',
        iopf: '\u{1D55A}',
        Iota: '\u0399',
        iota: '\u03B9',
        iprod: '\u2A3C',
        iquest: '\xBF',
        iscr: '\u{1D4BE}',
        Iscr: '\u2110',
        isin: '\u2208',
        isindot: '\u22F5',
        isinE: '\u22F9',
        isins: '\u22F4',
        isinsv: '\u22F3',
        isinv: '\u2208',
        it: '\u2062',
        Itilde: '\u0128',
        itilde: '\u0129',
        Iukcy: '\u0406',
        iukcy: '\u0456',
        Iuml: '\xCF',
        iuml: '\xEF',
        Jcirc: '\u0134',
        jcirc: '\u0135',
        Jcy: '\u0419',
        jcy: '\u0439',
        Jfr: '\u{1D50D}',
        jfr: '\u{1D527}',
        jmath: '\u0237',
        Jopf: '\u{1D541}',
        jopf: '\u{1D55B}',
        Jscr: '\u{1D4A5}',
        jscr: '\u{1D4BF}',
        Jsercy: '\u0408',
        jsercy: '\u0458',
        Jukcy: '\u0404',
        jukcy: '\u0454',
        Kappa: '\u039A',
        kappa: '\u03BA',
        kappav: '\u03F0',
        Kcedil: '\u0136',
        kcedil: '\u0137',
        Kcy: '\u041A',
        kcy: '\u043A',
        Kfr: '\u{1D50E}',
        kfr: '\u{1D528}',
        kgreen: '\u0138',
        KHcy: '\u0425',
        khcy: '\u0445',
        KJcy: '\u040C',
        kjcy: '\u045C',
        Kopf: '\u{1D542}',
        kopf: '\u{1D55C}',
        Kscr: '\u{1D4A6}',
        kscr: '\u{1D4C0}',
        lAarr: '\u21DA',
        Lacute: '\u0139',
        lacute: '\u013A',
        laemptyv: '\u29B4',
        lagran: '\u2112',
        Lambda: '\u039B',
        lambda: '\u03BB',
        lang: '\u27E8',
        Lang: '\u27EA',
        langd: '\u2991',
        langle: '\u27E8',
        lap: '\u2A85',
        Laplacetrf: '\u2112',
        laquo: '\xAB',
        larrb: '\u21E4',
        larrbfs: '\u291F',
        larr: '\u2190',
        Larr: '\u219E',
        lArr: '\u21D0',
        larrfs: '\u291D',
        larrhk: '\u21A9',
        larrlp: '\u21AB',
        larrpl: '\u2939',
        larrsim: '\u2973',
        larrtl: '\u21A2',
        latail: '\u2919',
        lAtail: '\u291B',
        lat: '\u2AAB',
        late: '\u2AAD',
        lates: '\u2AAD\uFE00',
        lbarr: '\u290C',
        lBarr: '\u290E',
        lbbrk: '\u2772',
        lbrace: '{',
        lbrack: '[',
        lbrke: '\u298B',
        lbrksld: '\u298F',
        lbrkslu: '\u298D',
        Lcaron: '\u013D',
        lcaron: '\u013E',
        Lcedil: '\u013B',
        lcedil: '\u013C',
        lceil: '\u2308',
        lcub: '{',
        Lcy: '\u041B',
        lcy: '\u043B',
        ldca: '\u2936',
        ldquo: '\u201C',
        ldquor: '\u201E',
        ldrdhar: '\u2967',
        ldrushar: '\u294B',
        ldsh: '\u21B2',
        le: '\u2264',
        lE: '\u2266',
        LeftAngleBracket: '\u27E8',
        LeftArrowBar: '\u21E4',
        leftarrow: '\u2190',
        LeftArrow: '\u2190',
        Leftarrow: '\u21D0',
        LeftArrowRightArrow: '\u21C6',
        leftarrowtail: '\u21A2',
        LeftCeiling: '\u2308',
        LeftDoubleBracket: '\u27E6',
        LeftDownTeeVector: '\u2961',
        LeftDownVectorBar: '\u2959',
        LeftDownVector: '\u21C3',
        LeftFloor: '\u230A',
        leftharpoondown: '\u21BD',
        leftharpoonup: '\u21BC',
        leftleftarrows: '\u21C7',
        leftrightarrow: '\u2194',
        LeftRightArrow: '\u2194',
        Leftrightarrow: '\u21D4',
        leftrightarrows: '\u21C6',
        leftrightharpoons: '\u21CB',
        leftrightsquigarrow: '\u21AD',
        LeftRightVector: '\u294E',
        LeftTeeArrow: '\u21A4',
        LeftTee: '\u22A3',
        LeftTeeVector: '\u295A',
        leftthreetimes: '\u22CB',
        LeftTriangleBar: '\u29CF',
        LeftTriangle: '\u22B2',
        LeftTriangleEqual: '\u22B4',
        LeftUpDownVector: '\u2951',
        LeftUpTeeVector: '\u2960',
        LeftUpVectorBar: '\u2958',
        LeftUpVector: '\u21BF',
        LeftVectorBar: '\u2952',
        LeftVector: '\u21BC',
        lEg: '\u2A8B',
        leg: '\u22DA',
        leq: '\u2264',
        leqq: '\u2266',
        leqslant: '\u2A7D',
        lescc: '\u2AA8',
        les: '\u2A7D',
        lesdot: '\u2A7F',
        lesdoto: '\u2A81',
        lesdotor: '\u2A83',
        lesg: '\u22DA\uFE00',
        lesges: '\u2A93',
        lessapprox: '\u2A85',
        lessdot: '\u22D6',
        lesseqgtr: '\u22DA',
        lesseqqgtr: '\u2A8B',
        LessEqualGreater: '\u22DA',
        LessFullEqual: '\u2266',
        LessGreater: '\u2276',
        lessgtr: '\u2276',
        LessLess: '\u2AA1',
        lesssim: '\u2272',
        LessSlantEqual: '\u2A7D',
        LessTilde: '\u2272',
        lfisht: '\u297C',
        lfloor: '\u230A',
        Lfr: '\u{1D50F}',
        lfr: '\u{1D529}',
        lg: '\u2276',
        lgE: '\u2A91',
        lHar: '\u2962',
        lhard: '\u21BD',
        lharu: '\u21BC',
        lharul: '\u296A',
        lhblk: '\u2584',
        LJcy: '\u0409',
        ljcy: '\u0459',
        llarr: '\u21C7',
        ll: '\u226A',
        Ll: '\u22D8',
        llcorner: '\u231E',
        Lleftarrow: '\u21DA',
        llhard: '\u296B',
        lltri: '\u25FA',
        Lmidot: '\u013F',
        lmidot: '\u0140',
        lmoustache: '\u23B0',
        lmoust: '\u23B0',
        lnap: '\u2A89',
        lnapprox: '\u2A89',
        lne: '\u2A87',
        lnE: '\u2268',
        lneq: '\u2A87',
        lneqq: '\u2268',
        lnsim: '\u22E6',
        loang: '\u27EC',
        loarr: '\u21FD',
        lobrk: '\u27E6',
        longleftarrow: '\u27F5',
        LongLeftArrow: '\u27F5',
        Longleftarrow: '\u27F8',
        longleftrightarrow: '\u27F7',
        LongLeftRightArrow: '\u27F7',
        Longleftrightarrow: '\u27FA',
        longmapsto: '\u27FC',
        longrightarrow: '\u27F6',
        LongRightArrow: '\u27F6',
        Longrightarrow: '\u27F9',
        looparrowleft: '\u21AB',
        looparrowright: '\u21AC',
        lopar: '\u2985',
        Lopf: '\u{1D543}',
        lopf: '\u{1D55D}',
        loplus: '\u2A2D',
        lotimes: '\u2A34',
        lowast: '\u2217',
        lowbar: '_',
        LowerLeftArrow: '\u2199',
        LowerRightArrow: '\u2198',
        loz: '\u25CA',
        lozenge: '\u25CA',
        lozf: '\u29EB',
        lpar: '(',
        lparlt: '\u2993',
        lrarr: '\u21C6',
        lrcorner: '\u231F',
        lrhar: '\u21CB',
        lrhard: '\u296D',
        lrm: '\u200E',
        lrtri: '\u22BF',
        lsaquo: '\u2039',
        lscr: '\u{1D4C1}',
        Lscr: '\u2112',
        lsh: '\u21B0',
        Lsh: '\u21B0',
        lsim: '\u2272',
        lsime: '\u2A8D',
        lsimg: '\u2A8F',
        lsqb: '[',
        lsquo: '\u2018',
        lsquor: '\u201A',
        Lstrok: '\u0141',
        lstrok: '\u0142',
        ltcc: '\u2AA6',
        ltcir: '\u2A79',
        lt: '<',
        LT: '<',
        Lt: '\u226A',
        ltdot: '\u22D6',
        lthree: '\u22CB',
        ltimes: '\u22C9',
        ltlarr: '\u2976',
        ltquest: '\u2A7B',
        ltri: '\u25C3',
        ltrie: '\u22B4',
        ltrif: '\u25C2',
        ltrPar: '\u2996',
        lurdshar: '\u294A',
        luruhar: '\u2966',
        lvertneqq: '\u2268\uFE00',
        lvnE: '\u2268\uFE00',
        macr: '\xAF',
        male: '\u2642',
        malt: '\u2720',
        maltese: '\u2720',
        Map: '\u2905',
        map: '\u21A6',
        mapsto: '\u21A6',
        mapstodown: '\u21A7',
        mapstoleft: '\u21A4',
        mapstoup: '\u21A5',
        marker: '\u25AE',
        mcomma: '\u2A29',
        Mcy: '\u041C',
        mcy: '\u043C',
        mdash: '\u2014',
        mDDot: '\u223A',
        measuredangle: '\u2221',
        MediumSpace: '\u205F',
        Mellintrf: '\u2133',
        Mfr: '\u{1D510}',
        mfr: '\u{1D52A}',
        mho: '\u2127',
        micro: '\xB5',
        midast: '*',
        midcir: '\u2AF0',
        mid: '\u2223',
        middot: '\xB7',
        minusb: '\u229F',
        minus: '\u2212',
        minusd: '\u2238',
        minusdu: '\u2A2A',
        MinusPlus: '\u2213',
        mlcp: '\u2ADB',
        mldr: '\u2026',
        mnplus: '\u2213',
        models: '\u22A7',
        Mopf: '\u{1D544}',
        mopf: '\u{1D55E}',
        mp: '\u2213',
        mscr: '\u{1D4C2}',
        Mscr: '\u2133',
        mstpos: '\u223E',
        Mu: '\u039C',
        mu: '\u03BC',
        multimap: '\u22B8',
        mumap: '\u22B8',
        nabla: '\u2207',
        Nacute: '\u0143',
        nacute: '\u0144',
        nang: '\u2220\u20D2',
        nap: '\u2249',
        napE: '\u2A70\u0338',
        napid: '\u224B\u0338',
        napos: '\u0149',
        napprox: '\u2249',
        natural: '\u266E',
        naturals: '\u2115',
        natur: '\u266E',
        nbsp: '\xA0',
        nbump: '\u224E\u0338',
        nbumpe: '\u224F\u0338',
        ncap: '\u2A43',
        Ncaron: '\u0147',
        ncaron: '\u0148',
        Ncedil: '\u0145',
        ncedil: '\u0146',
        ncong: '\u2247',
        ncongdot: '\u2A6D\u0338',
        ncup: '\u2A42',
        Ncy: '\u041D',
        ncy: '\u043D',
        ndash: '\u2013',
        nearhk: '\u2924',
        nearr: '\u2197',
        neArr: '\u21D7',
        nearrow: '\u2197',
        ne: '\u2260',
        nedot: '\u2250\u0338',
        NegativeMediumSpace: '\u200B',
        NegativeThickSpace: '\u200B',
        NegativeThinSpace: '\u200B',
        NegativeVeryThinSpace: '\u200B',
        nequiv: '\u2262',
        nesear: '\u2928',
        nesim: '\u2242\u0338',
        NestedGreaterGreater: '\u226B',
        NestedLessLess: '\u226A',
        NewLine: `
`,
        nexist: '\u2204',
        nexists: '\u2204',
        Nfr: '\u{1D511}',
        nfr: '\u{1D52B}',
        ngE: '\u2267\u0338',
        nge: '\u2271',
        ngeq: '\u2271',
        ngeqq: '\u2267\u0338',
        ngeqslant: '\u2A7E\u0338',
        nges: '\u2A7E\u0338',
        nGg: '\u22D9\u0338',
        ngsim: '\u2275',
        nGt: '\u226B\u20D2',
        ngt: '\u226F',
        ngtr: '\u226F',
        nGtv: '\u226B\u0338',
        nharr: '\u21AE',
        nhArr: '\u21CE',
        nhpar: '\u2AF2',
        ni: '\u220B',
        nis: '\u22FC',
        nisd: '\u22FA',
        niv: '\u220B',
        NJcy: '\u040A',
        njcy: '\u045A',
        nlarr: '\u219A',
        nlArr: '\u21CD',
        nldr: '\u2025',
        nlE: '\u2266\u0338',
        nle: '\u2270',
        nleftarrow: '\u219A',
        nLeftarrow: '\u21CD',
        nleftrightarrow: '\u21AE',
        nLeftrightarrow: '\u21CE',
        nleq: '\u2270',
        nleqq: '\u2266\u0338',
        nleqslant: '\u2A7D\u0338',
        nles: '\u2A7D\u0338',
        nless: '\u226E',
        nLl: '\u22D8\u0338',
        nlsim: '\u2274',
        nLt: '\u226A\u20D2',
        nlt: '\u226E',
        nltri: '\u22EA',
        nltrie: '\u22EC',
        nLtv: '\u226A\u0338',
        nmid: '\u2224',
        NoBreak: '\u2060',
        NonBreakingSpace: '\xA0',
        nopf: '\u{1D55F}',
        Nopf: '\u2115',
        Not: '\u2AEC',
        not: '\xAC',
        NotCongruent: '\u2262',
        NotCupCap: '\u226D',
        NotDoubleVerticalBar: '\u2226',
        NotElement: '\u2209',
        NotEqual: '\u2260',
        NotEqualTilde: '\u2242\u0338',
        NotExists: '\u2204',
        NotGreater: '\u226F',
        NotGreaterEqual: '\u2271',
        NotGreaterFullEqual: '\u2267\u0338',
        NotGreaterGreater: '\u226B\u0338',
        NotGreaterLess: '\u2279',
        NotGreaterSlantEqual: '\u2A7E\u0338',
        NotGreaterTilde: '\u2275',
        NotHumpDownHump: '\u224E\u0338',
        NotHumpEqual: '\u224F\u0338',
        notin: '\u2209',
        notindot: '\u22F5\u0338',
        notinE: '\u22F9\u0338',
        notinva: '\u2209',
        notinvb: '\u22F7',
        notinvc: '\u22F6',
        NotLeftTriangleBar: '\u29CF\u0338',
        NotLeftTriangle: '\u22EA',
        NotLeftTriangleEqual: '\u22EC',
        NotLess: '\u226E',
        NotLessEqual: '\u2270',
        NotLessGreater: '\u2278',
        NotLessLess: '\u226A\u0338',
        NotLessSlantEqual: '\u2A7D\u0338',
        NotLessTilde: '\u2274',
        NotNestedGreaterGreater: '\u2AA2\u0338',
        NotNestedLessLess: '\u2AA1\u0338',
        notni: '\u220C',
        notniva: '\u220C',
        notnivb: '\u22FE',
        notnivc: '\u22FD',
        NotPrecedes: '\u2280',
        NotPrecedesEqual: '\u2AAF\u0338',
        NotPrecedesSlantEqual: '\u22E0',
        NotReverseElement: '\u220C',
        NotRightTriangleBar: '\u29D0\u0338',
        NotRightTriangle: '\u22EB',
        NotRightTriangleEqual: '\u22ED',
        NotSquareSubset: '\u228F\u0338',
        NotSquareSubsetEqual: '\u22E2',
        NotSquareSuperset: '\u2290\u0338',
        NotSquareSupersetEqual: '\u22E3',
        NotSubset: '\u2282\u20D2',
        NotSubsetEqual: '\u2288',
        NotSucceeds: '\u2281',
        NotSucceedsEqual: '\u2AB0\u0338',
        NotSucceedsSlantEqual: '\u22E1',
        NotSucceedsTilde: '\u227F\u0338',
        NotSuperset: '\u2283\u20D2',
        NotSupersetEqual: '\u2289',
        NotTilde: '\u2241',
        NotTildeEqual: '\u2244',
        NotTildeFullEqual: '\u2247',
        NotTildeTilde: '\u2249',
        NotVerticalBar: '\u2224',
        nparallel: '\u2226',
        npar: '\u2226',
        nparsl: '\u2AFD\u20E5',
        npart: '\u2202\u0338',
        npolint: '\u2A14',
        npr: '\u2280',
        nprcue: '\u22E0',
        nprec: '\u2280',
        npreceq: '\u2AAF\u0338',
        npre: '\u2AAF\u0338',
        nrarrc: '\u2933\u0338',
        nrarr: '\u219B',
        nrArr: '\u21CF',
        nrarrw: '\u219D\u0338',
        nrightarrow: '\u219B',
        nRightarrow: '\u21CF',
        nrtri: '\u22EB',
        nrtrie: '\u22ED',
        nsc: '\u2281',
        nsccue: '\u22E1',
        nsce: '\u2AB0\u0338',
        Nscr: '\u{1D4A9}',
        nscr: '\u{1D4C3}',
        nshortmid: '\u2224',
        nshortparallel: '\u2226',
        nsim: '\u2241',
        nsime: '\u2244',
        nsimeq: '\u2244',
        nsmid: '\u2224',
        nspar: '\u2226',
        nsqsube: '\u22E2',
        nsqsupe: '\u22E3',
        nsub: '\u2284',
        nsubE: '\u2AC5\u0338',
        nsube: '\u2288',
        nsubset: '\u2282\u20D2',
        nsubseteq: '\u2288',
        nsubseteqq: '\u2AC5\u0338',
        nsucc: '\u2281',
        nsucceq: '\u2AB0\u0338',
        nsup: '\u2285',
        nsupE: '\u2AC6\u0338',
        nsupe: '\u2289',
        nsupset: '\u2283\u20D2',
        nsupseteq: '\u2289',
        nsupseteqq: '\u2AC6\u0338',
        ntgl: '\u2279',
        Ntilde: '\xD1',
        ntilde: '\xF1',
        ntlg: '\u2278',
        ntriangleleft: '\u22EA',
        ntrianglelefteq: '\u22EC',
        ntriangleright: '\u22EB',
        ntrianglerighteq: '\u22ED',
        Nu: '\u039D',
        nu: '\u03BD',
        num: '#',
        numero: '\u2116',
        numsp: '\u2007',
        nvap: '\u224D\u20D2',
        nvdash: '\u22AC',
        nvDash: '\u22AD',
        nVdash: '\u22AE',
        nVDash: '\u22AF',
        nvge: '\u2265\u20D2',
        nvgt: '>\u20D2',
        nvHarr: '\u2904',
        nvinfin: '\u29DE',
        nvlArr: '\u2902',
        nvle: '\u2264\u20D2',
        nvlt: '<\u20D2',
        nvltrie: '\u22B4\u20D2',
        nvrArr: '\u2903',
        nvrtrie: '\u22B5\u20D2',
        nvsim: '\u223C\u20D2',
        nwarhk: '\u2923',
        nwarr: '\u2196',
        nwArr: '\u21D6',
        nwarrow: '\u2196',
        nwnear: '\u2927',
        Oacute: '\xD3',
        oacute: '\xF3',
        oast: '\u229B',
        Ocirc: '\xD4',
        ocirc: '\xF4',
        ocir: '\u229A',
        Ocy: '\u041E',
        ocy: '\u043E',
        odash: '\u229D',
        Odblac: '\u0150',
        odblac: '\u0151',
        odiv: '\u2A38',
        odot: '\u2299',
        odsold: '\u29BC',
        OElig: '\u0152',
        oelig: '\u0153',
        ofcir: '\u29BF',
        Ofr: '\u{1D512}',
        ofr: '\u{1D52C}',
        ogon: '\u02DB',
        Ograve: '\xD2',
        ograve: '\xF2',
        ogt: '\u29C1',
        ohbar: '\u29B5',
        ohm: '\u03A9',
        oint: '\u222E',
        olarr: '\u21BA',
        olcir: '\u29BE',
        olcross: '\u29BB',
        oline: '\u203E',
        olt: '\u29C0',
        Omacr: '\u014C',
        omacr: '\u014D',
        Omega: '\u03A9',
        omega: '\u03C9',
        Omicron: '\u039F',
        omicron: '\u03BF',
        omid: '\u29B6',
        ominus: '\u2296',
        Oopf: '\u{1D546}',
        oopf: '\u{1D560}',
        opar: '\u29B7',
        OpenCurlyDoubleQuote: '\u201C',
        OpenCurlyQuote: '\u2018',
        operp: '\u29B9',
        oplus: '\u2295',
        orarr: '\u21BB',
        Or: '\u2A54',
        or: '\u2228',
        ord: '\u2A5D',
        order: '\u2134',
        orderof: '\u2134',
        ordf: '\xAA',
        ordm: '\xBA',
        origof: '\u22B6',
        oror: '\u2A56',
        orslope: '\u2A57',
        orv: '\u2A5B',
        oS: '\u24C8',
        Oscr: '\u{1D4AA}',
        oscr: '\u2134',
        Oslash: '\xD8',
        oslash: '\xF8',
        osol: '\u2298',
        Otilde: '\xD5',
        otilde: '\xF5',
        otimesas: '\u2A36',
        Otimes: '\u2A37',
        otimes: '\u2297',
        Ouml: '\xD6',
        ouml: '\xF6',
        ovbar: '\u233D',
        OverBar: '\u203E',
        OverBrace: '\u23DE',
        OverBracket: '\u23B4',
        OverParenthesis: '\u23DC',
        para: '\xB6',
        parallel: '\u2225',
        par: '\u2225',
        parsim: '\u2AF3',
        parsl: '\u2AFD',
        part: '\u2202',
        PartialD: '\u2202',
        Pcy: '\u041F',
        pcy: '\u043F',
        percnt: '%',
        period: '.',
        permil: '\u2030',
        perp: '\u22A5',
        pertenk: '\u2031',
        Pfr: '\u{1D513}',
        pfr: '\u{1D52D}',
        Phi: '\u03A6',
        phi: '\u03C6',
        phiv: '\u03D5',
        phmmat: '\u2133',
        phone: '\u260E',
        Pi: '\u03A0',
        pi: '\u03C0',
        pitchfork: '\u22D4',
        piv: '\u03D6',
        planck: '\u210F',
        planckh: '\u210E',
        plankv: '\u210F',
        plusacir: '\u2A23',
        plusb: '\u229E',
        pluscir: '\u2A22',
        plus: '+',
        plusdo: '\u2214',
        plusdu: '\u2A25',
        pluse: '\u2A72',
        PlusMinus: '\xB1',
        plusmn: '\xB1',
        plussim: '\u2A26',
        plustwo: '\u2A27',
        pm: '\xB1',
        Poincareplane: '\u210C',
        pointint: '\u2A15',
        popf: '\u{1D561}',
        Popf: '\u2119',
        pound: '\xA3',
        prap: '\u2AB7',
        Pr: '\u2ABB',
        pr: '\u227A',
        prcue: '\u227C',
        precapprox: '\u2AB7',
        prec: '\u227A',
        preccurlyeq: '\u227C',
        Precedes: '\u227A',
        PrecedesEqual: '\u2AAF',
        PrecedesSlantEqual: '\u227C',
        PrecedesTilde: '\u227E',
        preceq: '\u2AAF',
        precnapprox: '\u2AB9',
        precneqq: '\u2AB5',
        precnsim: '\u22E8',
        pre: '\u2AAF',
        prE: '\u2AB3',
        precsim: '\u227E',
        prime: '\u2032',
        Prime: '\u2033',
        primes: '\u2119',
        prnap: '\u2AB9',
        prnE: '\u2AB5',
        prnsim: '\u22E8',
        prod: '\u220F',
        Product: '\u220F',
        profalar: '\u232E',
        profline: '\u2312',
        profsurf: '\u2313',
        prop: '\u221D',
        Proportional: '\u221D',
        Proportion: '\u2237',
        propto: '\u221D',
        prsim: '\u227E',
        prurel: '\u22B0',
        Pscr: '\u{1D4AB}',
        pscr: '\u{1D4C5}',
        Psi: '\u03A8',
        psi: '\u03C8',
        puncsp: '\u2008',
        Qfr: '\u{1D514}',
        qfr: '\u{1D52E}',
        qint: '\u2A0C',
        qopf: '\u{1D562}',
        Qopf: '\u211A',
        qprime: '\u2057',
        Qscr: '\u{1D4AC}',
        qscr: '\u{1D4C6}',
        quaternions: '\u210D',
        quatint: '\u2A16',
        quest: '?',
        questeq: '\u225F',
        quot: '"',
        QUOT: '"',
        rAarr: '\u21DB',
        race: '\u223D\u0331',
        Racute: '\u0154',
        racute: '\u0155',
        radic: '\u221A',
        raemptyv: '\u29B3',
        rang: '\u27E9',
        Rang: '\u27EB',
        rangd: '\u2992',
        range: '\u29A5',
        rangle: '\u27E9',
        raquo: '\xBB',
        rarrap: '\u2975',
        rarrb: '\u21E5',
        rarrbfs: '\u2920',
        rarrc: '\u2933',
        rarr: '\u2192',
        Rarr: '\u21A0',
        rArr: '\u21D2',
        rarrfs: '\u291E',
        rarrhk: '\u21AA',
        rarrlp: '\u21AC',
        rarrpl: '\u2945',
        rarrsim: '\u2974',
        Rarrtl: '\u2916',
        rarrtl: '\u21A3',
        rarrw: '\u219D',
        ratail: '\u291A',
        rAtail: '\u291C',
        ratio: '\u2236',
        rationals: '\u211A',
        rbarr: '\u290D',
        rBarr: '\u290F',
        RBarr: '\u2910',
        rbbrk: '\u2773',
        rbrace: '}',
        rbrack: ']',
        rbrke: '\u298C',
        rbrksld: '\u298E',
        rbrkslu: '\u2990',
        Rcaron: '\u0158',
        rcaron: '\u0159',
        Rcedil: '\u0156',
        rcedil: '\u0157',
        rceil: '\u2309',
        rcub: '}',
        Rcy: '\u0420',
        rcy: '\u0440',
        rdca: '\u2937',
        rdldhar: '\u2969',
        rdquo: '\u201D',
        rdquor: '\u201D',
        rdsh: '\u21B3',
        real: '\u211C',
        realine: '\u211B',
        realpart: '\u211C',
        reals: '\u211D',
        Re: '\u211C',
        rect: '\u25AD',
        reg: '\xAE',
        REG: '\xAE',
        ReverseElement: '\u220B',
        ReverseEquilibrium: '\u21CB',
        ReverseUpEquilibrium: '\u296F',
        rfisht: '\u297D',
        rfloor: '\u230B',
        rfr: '\u{1D52F}',
        Rfr: '\u211C',
        rHar: '\u2964',
        rhard: '\u21C1',
        rharu: '\u21C0',
        rharul: '\u296C',
        Rho: '\u03A1',
        rho: '\u03C1',
        rhov: '\u03F1',
        RightAngleBracket: '\u27E9',
        RightArrowBar: '\u21E5',
        rightarrow: '\u2192',
        RightArrow: '\u2192',
        Rightarrow: '\u21D2',
        RightArrowLeftArrow: '\u21C4',
        rightarrowtail: '\u21A3',
        RightCeiling: '\u2309',
        RightDoubleBracket: '\u27E7',
        RightDownTeeVector: '\u295D',
        RightDownVectorBar: '\u2955',
        RightDownVector: '\u21C2',
        RightFloor: '\u230B',
        rightharpoondown: '\u21C1',
        rightharpoonup: '\u21C0',
        rightleftarrows: '\u21C4',
        rightleftharpoons: '\u21CC',
        rightrightarrows: '\u21C9',
        rightsquigarrow: '\u219D',
        RightTeeArrow: '\u21A6',
        RightTee: '\u22A2',
        RightTeeVector: '\u295B',
        rightthreetimes: '\u22CC',
        RightTriangleBar: '\u29D0',
        RightTriangle: '\u22B3',
        RightTriangleEqual: '\u22B5',
        RightUpDownVector: '\u294F',
        RightUpTeeVector: '\u295C',
        RightUpVectorBar: '\u2954',
        RightUpVector: '\u21BE',
        RightVectorBar: '\u2953',
        RightVector: '\u21C0',
        ring: '\u02DA',
        risingdotseq: '\u2253',
        rlarr: '\u21C4',
        rlhar: '\u21CC',
        rlm: '\u200F',
        rmoustache: '\u23B1',
        rmoust: '\u23B1',
        rnmid: '\u2AEE',
        roang: '\u27ED',
        roarr: '\u21FE',
        robrk: '\u27E7',
        ropar: '\u2986',
        ropf: '\u{1D563}',
        Ropf: '\u211D',
        roplus: '\u2A2E',
        rotimes: '\u2A35',
        RoundImplies: '\u2970',
        rpar: ')',
        rpargt: '\u2994',
        rppolint: '\u2A12',
        rrarr: '\u21C9',
        Rrightarrow: '\u21DB',
        rsaquo: '\u203A',
        rscr: '\u{1D4C7}',
        Rscr: '\u211B',
        rsh: '\u21B1',
        Rsh: '\u21B1',
        rsqb: ']',
        rsquo: '\u2019',
        rsquor: '\u2019',
        rthree: '\u22CC',
        rtimes: '\u22CA',
        rtri: '\u25B9',
        rtrie: '\u22B5',
        rtrif: '\u25B8',
        rtriltri: '\u29CE',
        RuleDelayed: '\u29F4',
        ruluhar: '\u2968',
        rx: '\u211E',
        Sacute: '\u015A',
        sacute: '\u015B',
        sbquo: '\u201A',
        scap: '\u2AB8',
        Scaron: '\u0160',
        scaron: '\u0161',
        Sc: '\u2ABC',
        sc: '\u227B',
        sccue: '\u227D',
        sce: '\u2AB0',
        scE: '\u2AB4',
        Scedil: '\u015E',
        scedil: '\u015F',
        Scirc: '\u015C',
        scirc: '\u015D',
        scnap: '\u2ABA',
        scnE: '\u2AB6',
        scnsim: '\u22E9',
        scpolint: '\u2A13',
        scsim: '\u227F',
        Scy: '\u0421',
        scy: '\u0441',
        sdotb: '\u22A1',
        sdot: '\u22C5',
        sdote: '\u2A66',
        searhk: '\u2925',
        searr: '\u2198',
        seArr: '\u21D8',
        searrow: '\u2198',
        sect: '\xA7',
        semi: ';',
        seswar: '\u2929',
        setminus: '\u2216',
        setmn: '\u2216',
        sext: '\u2736',
        Sfr: '\u{1D516}',
        sfr: '\u{1D530}',
        sfrown: '\u2322',
        sharp: '\u266F',
        SHCHcy: '\u0429',
        shchcy: '\u0449',
        SHcy: '\u0428',
        shcy: '\u0448',
        ShortDownArrow: '\u2193',
        ShortLeftArrow: '\u2190',
        shortmid: '\u2223',
        shortparallel: '\u2225',
        ShortRightArrow: '\u2192',
        ShortUpArrow: '\u2191',
        shy: '\xAD',
        Sigma: '\u03A3',
        sigma: '\u03C3',
        sigmaf: '\u03C2',
        sigmav: '\u03C2',
        sim: '\u223C',
        simdot: '\u2A6A',
        sime: '\u2243',
        simeq: '\u2243',
        simg: '\u2A9E',
        simgE: '\u2AA0',
        siml: '\u2A9D',
        simlE: '\u2A9F',
        simne: '\u2246',
        simplus: '\u2A24',
        simrarr: '\u2972',
        slarr: '\u2190',
        SmallCircle: '\u2218',
        smallsetminus: '\u2216',
        smashp: '\u2A33',
        smeparsl: '\u29E4',
        smid: '\u2223',
        smile: '\u2323',
        smt: '\u2AAA',
        smte: '\u2AAC',
        smtes: '\u2AAC\uFE00',
        SOFTcy: '\u042C',
        softcy: '\u044C',
        solbar: '\u233F',
        solb: '\u29C4',
        sol: '/',
        Sopf: '\u{1D54A}',
        sopf: '\u{1D564}',
        spades: '\u2660',
        spadesuit: '\u2660',
        spar: '\u2225',
        sqcap: '\u2293',
        sqcaps: '\u2293\uFE00',
        sqcup: '\u2294',
        sqcups: '\u2294\uFE00',
        Sqrt: '\u221A',
        sqsub: '\u228F',
        sqsube: '\u2291',
        sqsubset: '\u228F',
        sqsubseteq: '\u2291',
        sqsup: '\u2290',
        sqsupe: '\u2292',
        sqsupset: '\u2290',
        sqsupseteq: '\u2292',
        square: '\u25A1',
        Square: '\u25A1',
        SquareIntersection: '\u2293',
        SquareSubset: '\u228F',
        SquareSubsetEqual: '\u2291',
        SquareSuperset: '\u2290',
        SquareSupersetEqual: '\u2292',
        SquareUnion: '\u2294',
        squarf: '\u25AA',
        squ: '\u25A1',
        squf: '\u25AA',
        srarr: '\u2192',
        Sscr: '\u{1D4AE}',
        sscr: '\u{1D4C8}',
        ssetmn: '\u2216',
        ssmile: '\u2323',
        sstarf: '\u22C6',
        Star: '\u22C6',
        star: '\u2606',
        starf: '\u2605',
        straightepsilon: '\u03F5',
        straightphi: '\u03D5',
        strns: '\xAF',
        sub: '\u2282',
        Sub: '\u22D0',
        subdot: '\u2ABD',
        subE: '\u2AC5',
        sube: '\u2286',
        subedot: '\u2AC3',
        submult: '\u2AC1',
        subnE: '\u2ACB',
        subne: '\u228A',
        subplus: '\u2ABF',
        subrarr: '\u2979',
        subset: '\u2282',
        Subset: '\u22D0',
        subseteq: '\u2286',
        subseteqq: '\u2AC5',
        SubsetEqual: '\u2286',
        subsetneq: '\u228A',
        subsetneqq: '\u2ACB',
        subsim: '\u2AC7',
        subsub: '\u2AD5',
        subsup: '\u2AD3',
        succapprox: '\u2AB8',
        succ: '\u227B',
        succcurlyeq: '\u227D',
        Succeeds: '\u227B',
        SucceedsEqual: '\u2AB0',
        SucceedsSlantEqual: '\u227D',
        SucceedsTilde: '\u227F',
        succeq: '\u2AB0',
        succnapprox: '\u2ABA',
        succneqq: '\u2AB6',
        succnsim: '\u22E9',
        succsim: '\u227F',
        SuchThat: '\u220B',
        sum: '\u2211',
        Sum: '\u2211',
        sung: '\u266A',
        sup1: '\xB9',
        sup2: '\xB2',
        sup3: '\xB3',
        sup: '\u2283',
        Sup: '\u22D1',
        supdot: '\u2ABE',
        supdsub: '\u2AD8',
        supE: '\u2AC6',
        supe: '\u2287',
        supedot: '\u2AC4',
        Superset: '\u2283',
        SupersetEqual: '\u2287',
        suphsol: '\u27C9',
        suphsub: '\u2AD7',
        suplarr: '\u297B',
        supmult: '\u2AC2',
        supnE: '\u2ACC',
        supne: '\u228B',
        supplus: '\u2AC0',
        supset: '\u2283',
        Supset: '\u22D1',
        supseteq: '\u2287',
        supseteqq: '\u2AC6',
        supsetneq: '\u228B',
        supsetneqq: '\u2ACC',
        supsim: '\u2AC8',
        supsub: '\u2AD4',
        supsup: '\u2AD6',
        swarhk: '\u2926',
        swarr: '\u2199',
        swArr: '\u21D9',
        swarrow: '\u2199',
        swnwar: '\u292A',
        szlig: '\xDF',
        Tab: '	',
        target: '\u2316',
        Tau: '\u03A4',
        tau: '\u03C4',
        tbrk: '\u23B4',
        Tcaron: '\u0164',
        tcaron: '\u0165',
        Tcedil: '\u0162',
        tcedil: '\u0163',
        Tcy: '\u0422',
        tcy: '\u0442',
        tdot: '\u20DB',
        telrec: '\u2315',
        Tfr: '\u{1D517}',
        tfr: '\u{1D531}',
        there4: '\u2234',
        therefore: '\u2234',
        Therefore: '\u2234',
        Theta: '\u0398',
        theta: '\u03B8',
        thetasym: '\u03D1',
        thetav: '\u03D1',
        thickapprox: '\u2248',
        thicksim: '\u223C',
        ThickSpace: '\u205F\u200A',
        ThinSpace: '\u2009',
        thinsp: '\u2009',
        thkap: '\u2248',
        thksim: '\u223C',
        THORN: '\xDE',
        thorn: '\xFE',
        tilde: '\u02DC',
        Tilde: '\u223C',
        TildeEqual: '\u2243',
        TildeFullEqual: '\u2245',
        TildeTilde: '\u2248',
        timesbar: '\u2A31',
        timesb: '\u22A0',
        times: '\xD7',
        timesd: '\u2A30',
        tint: '\u222D',
        toea: '\u2928',
        topbot: '\u2336',
        topcir: '\u2AF1',
        top: '\u22A4',
        Topf: '\u{1D54B}',
        topf: '\u{1D565}',
        topfork: '\u2ADA',
        tosa: '\u2929',
        tprime: '\u2034',
        trade: '\u2122',
        TRADE: '\u2122',
        triangle: '\u25B5',
        triangledown: '\u25BF',
        triangleleft: '\u25C3',
        trianglelefteq: '\u22B4',
        triangleq: '\u225C',
        triangleright: '\u25B9',
        trianglerighteq: '\u22B5',
        tridot: '\u25EC',
        trie: '\u225C',
        triminus: '\u2A3A',
        TripleDot: '\u20DB',
        triplus: '\u2A39',
        trisb: '\u29CD',
        tritime: '\u2A3B',
        trpezium: '\u23E2',
        Tscr: '\u{1D4AF}',
        tscr: '\u{1D4C9}',
        TScy: '\u0426',
        tscy: '\u0446',
        TSHcy: '\u040B',
        tshcy: '\u045B',
        Tstrok: '\u0166',
        tstrok: '\u0167',
        twixt: '\u226C',
        twoheadleftarrow: '\u219E',
        twoheadrightarrow: '\u21A0',
        Uacute: '\xDA',
        uacute: '\xFA',
        uarr: '\u2191',
        Uarr: '\u219F',
        uArr: '\u21D1',
        Uarrocir: '\u2949',
        Ubrcy: '\u040E',
        ubrcy: '\u045E',
        Ubreve: '\u016C',
        ubreve: '\u016D',
        Ucirc: '\xDB',
        ucirc: '\xFB',
        Ucy: '\u0423',
        ucy: '\u0443',
        udarr: '\u21C5',
        Udblac: '\u0170',
        udblac: '\u0171',
        udhar: '\u296E',
        ufisht: '\u297E',
        Ufr: '\u{1D518}',
        ufr: '\u{1D532}',
        Ugrave: '\xD9',
        ugrave: '\xF9',
        uHar: '\u2963',
        uharl: '\u21BF',
        uharr: '\u21BE',
        uhblk: '\u2580',
        ulcorn: '\u231C',
        ulcorner: '\u231C',
        ulcrop: '\u230F',
        ultri: '\u25F8',
        Umacr: '\u016A',
        umacr: '\u016B',
        uml: '\xA8',
        UnderBar: '_',
        UnderBrace: '\u23DF',
        UnderBracket: '\u23B5',
        UnderParenthesis: '\u23DD',
        Union: '\u22C3',
        UnionPlus: '\u228E',
        Uogon: '\u0172',
        uogon: '\u0173',
        Uopf: '\u{1D54C}',
        uopf: '\u{1D566}',
        UpArrowBar: '\u2912',
        uparrow: '\u2191',
        UpArrow: '\u2191',
        Uparrow: '\u21D1',
        UpArrowDownArrow: '\u21C5',
        updownarrow: '\u2195',
        UpDownArrow: '\u2195',
        Updownarrow: '\u21D5',
        UpEquilibrium: '\u296E',
        upharpoonleft: '\u21BF',
        upharpoonright: '\u21BE',
        uplus: '\u228E',
        UpperLeftArrow: '\u2196',
        UpperRightArrow: '\u2197',
        upsi: '\u03C5',
        Upsi: '\u03D2',
        upsih: '\u03D2',
        Upsilon: '\u03A5',
        upsilon: '\u03C5',
        UpTeeArrow: '\u21A5',
        UpTee: '\u22A5',
        upuparrows: '\u21C8',
        urcorn: '\u231D',
        urcorner: '\u231D',
        urcrop: '\u230E',
        Uring: '\u016E',
        uring: '\u016F',
        urtri: '\u25F9',
        Uscr: '\u{1D4B0}',
        uscr: '\u{1D4CA}',
        utdot: '\u22F0',
        Utilde: '\u0168',
        utilde: '\u0169',
        utri: '\u25B5',
        utrif: '\u25B4',
        uuarr: '\u21C8',
        Uuml: '\xDC',
        uuml: '\xFC',
        uwangle: '\u29A7',
        vangrt: '\u299C',
        varepsilon: '\u03F5',
        varkappa: '\u03F0',
        varnothing: '\u2205',
        varphi: '\u03D5',
        varpi: '\u03D6',
        varpropto: '\u221D',
        varr: '\u2195',
        vArr: '\u21D5',
        varrho: '\u03F1',
        varsigma: '\u03C2',
        varsubsetneq: '\u228A\uFE00',
        varsubsetneqq: '\u2ACB\uFE00',
        varsupsetneq: '\u228B\uFE00',
        varsupsetneqq: '\u2ACC\uFE00',
        vartheta: '\u03D1',
        vartriangleleft: '\u22B2',
        vartriangleright: '\u22B3',
        vBar: '\u2AE8',
        Vbar: '\u2AEB',
        vBarv: '\u2AE9',
        Vcy: '\u0412',
        vcy: '\u0432',
        vdash: '\u22A2',
        vDash: '\u22A8',
        Vdash: '\u22A9',
        VDash: '\u22AB',
        Vdashl: '\u2AE6',
        veebar: '\u22BB',
        vee: '\u2228',
        Vee: '\u22C1',
        veeeq: '\u225A',
        vellip: '\u22EE',
        verbar: '|',
        Verbar: '\u2016',
        vert: '|',
        Vert: '\u2016',
        VerticalBar: '\u2223',
        VerticalLine: '|',
        VerticalSeparator: '\u2758',
        VerticalTilde: '\u2240',
        VeryThinSpace: '\u200A',
        Vfr: '\u{1D519}',
        vfr: '\u{1D533}',
        vltri: '\u22B2',
        vnsub: '\u2282\u20D2',
        vnsup: '\u2283\u20D2',
        Vopf: '\u{1D54D}',
        vopf: '\u{1D567}',
        vprop: '\u221D',
        vrtri: '\u22B3',
        Vscr: '\u{1D4B1}',
        vscr: '\u{1D4CB}',
        vsubnE: '\u2ACB\uFE00',
        vsubne: '\u228A\uFE00',
        vsupnE: '\u2ACC\uFE00',
        vsupne: '\u228B\uFE00',
        Vvdash: '\u22AA',
        vzigzag: '\u299A',
        Wcirc: '\u0174',
        wcirc: '\u0175',
        wedbar: '\u2A5F',
        wedge: '\u2227',
        Wedge: '\u22C0',
        wedgeq: '\u2259',
        weierp: '\u2118',
        Wfr: '\u{1D51A}',
        wfr: '\u{1D534}',
        Wopf: '\u{1D54E}',
        wopf: '\u{1D568}',
        wp: '\u2118',
        wr: '\u2240',
        wreath: '\u2240',
        Wscr: '\u{1D4B2}',
        wscr: '\u{1D4CC}',
        xcap: '\u22C2',
        xcirc: '\u25EF',
        xcup: '\u22C3',
        xdtri: '\u25BD',
        Xfr: '\u{1D51B}',
        xfr: '\u{1D535}',
        xharr: '\u27F7',
        xhArr: '\u27FA',
        Xi: '\u039E',
        xi: '\u03BE',
        xlarr: '\u27F5',
        xlArr: '\u27F8',
        xmap: '\u27FC',
        xnis: '\u22FB',
        xodot: '\u2A00',
        Xopf: '\u{1D54F}',
        xopf: '\u{1D569}',
        xoplus: '\u2A01',
        xotime: '\u2A02',
        xrarr: '\u27F6',
        xrArr: '\u27F9',
        Xscr: '\u{1D4B3}',
        xscr: '\u{1D4CD}',
        xsqcup: '\u2A06',
        xuplus: '\u2A04',
        xutri: '\u25B3',
        xvee: '\u22C1',
        xwedge: '\u22C0',
        Yacute: '\xDD',
        yacute: '\xFD',
        YAcy: '\u042F',
        yacy: '\u044F',
        Ycirc: '\u0176',
        ycirc: '\u0177',
        Ycy: '\u042B',
        ycy: '\u044B',
        yen: '\xA5',
        Yfr: '\u{1D51C}',
        yfr: '\u{1D536}',
        YIcy: '\u0407',
        yicy: '\u0457',
        Yopf: '\u{1D550}',
        yopf: '\u{1D56A}',
        Yscr: '\u{1D4B4}',
        yscr: '\u{1D4CE}',
        YUcy: '\u042E',
        yucy: '\u044E',
        yuml: '\xFF',
        Yuml: '\u0178',
        Zacute: '\u0179',
        zacute: '\u017A',
        Zcaron: '\u017D',
        zcaron: '\u017E',
        Zcy: '\u0417',
        zcy: '\u0437',
        Zdot: '\u017B',
        zdot: '\u017C',
        zeetrf: '\u2128',
        ZeroWidthSpace: '\u200B',
        Zeta: '\u0396',
        zeta: '\u03B6',
        zfr: '\u{1D537}',
        Zfr: '\u2128',
        ZHcy: '\u0416',
        zhcy: '\u0436',
        zigrarr: '\u21DD',
        zopf: '\u{1D56B}',
        Zopf: '\u2124',
        Zscr: '\u{1D4B5}',
        zscr: '\u{1D4CF}',
        zwj: '\u200D',
        zwnj: '\u200C',
      }
    })
    const cC = ge((e, t) => {
      t.exports = {
        Aacute: '\xC1',
        aacute: '\xE1',
        Acirc: '\xC2',
        acirc: '\xE2',
        acute: '\xB4',
        AElig: '\xC6',
        aelig: '\xE6',
        Agrave: '\xC0',
        agrave: '\xE0',
        amp: '&',
        AMP: '&',
        Aring: '\xC5',
        aring: '\xE5',
        Atilde: '\xC3',
        atilde: '\xE3',
        Auml: '\xC4',
        auml: '\xE4',
        brvbar: '\xA6',
        Ccedil: '\xC7',
        ccedil: '\xE7',
        cedil: '\xB8',
        cent: '\xA2',
        copy: '\xA9',
        COPY: '\xA9',
        curren: '\xA4',
        deg: '\xB0',
        divide: '\xF7',
        Eacute: '\xC9',
        eacute: '\xE9',
        Ecirc: '\xCA',
        ecirc: '\xEA',
        Egrave: '\xC8',
        egrave: '\xE8',
        ETH: '\xD0',
        eth: '\xF0',
        Euml: '\xCB',
        euml: '\xEB',
        frac12: '\xBD',
        frac14: '\xBC',
        frac34: '\xBE',
        gt: '>',
        GT: '>',
        Iacute: '\xCD',
        iacute: '\xED',
        Icirc: '\xCE',
        icirc: '\xEE',
        iexcl: '\xA1',
        Igrave: '\xCC',
        igrave: '\xEC',
        iquest: '\xBF',
        Iuml: '\xCF',
        iuml: '\xEF',
        laquo: '\xAB',
        lt: '<',
        LT: '<',
        macr: '\xAF',
        micro: '\xB5',
        middot: '\xB7',
        nbsp: '\xA0',
        not: '\xAC',
        Ntilde: '\xD1',
        ntilde: '\xF1',
        Oacute: '\xD3',
        oacute: '\xF3',
        Ocirc: '\xD4',
        ocirc: '\xF4',
        Ograve: '\xD2',
        ograve: '\xF2',
        ordf: '\xAA',
        ordm: '\xBA',
        Oslash: '\xD8',
        oslash: '\xF8',
        Otilde: '\xD5',
        otilde: '\xF5',
        Ouml: '\xD6',
        ouml: '\xF6',
        para: '\xB6',
        plusmn: '\xB1',
        pound: '\xA3',
        quot: '"',
        QUOT: '"',
        raquo: '\xBB',
        reg: '\xAE',
        REG: '\xAE',
        sect: '\xA7',
        shy: '\xAD',
        sup1: '\xB9',
        sup2: '\xB2',
        sup3: '\xB3',
        szlig: '\xDF',
        THORN: '\xDE',
        thorn: '\xFE',
        times: '\xD7',
        Uacute: '\xDA',
        uacute: '\xFA',
        Ucirc: '\xDB',
        ucirc: '\xFB',
        Ugrave: '\xD9',
        ugrave: '\xF9',
        uml: '\xA8',
        Uuml: '\xDC',
        uuml: '\xFC',
        Yacute: '\xDD',
        yacute: '\xFD',
        yen: '\xA5',
        yuml: '\xFF',
      }
    })
    const My = ge((e, t) => {
      t.exports = { amp: '&', apos: "'", gt: '>', lt: '<', quot: '"' }
    })
    const dC = ge((e, t) => {
      t.exports = {
        0: 65533,
        128: 8364,
        130: 8218,
        131: 402,
        132: 8222,
        133: 8230,
        134: 8224,
        135: 8225,
        136: 710,
        137: 8240,
        138: 352,
        139: 8249,
        140: 338,
        142: 381,
        145: 8216,
        146: 8217,
        147: 8220,
        148: 8221,
        149: 8226,
        150: 8211,
        151: 8212,
        152: 732,
        153: 8482,
        154: 353,
        155: 8250,
        156: 339,
        158: 382,
        159: 376,
      }
    })
    const pC = ge(e => {
      'use strict'
      const t =
        (e && e.__importDefault) ||
        function (a) {
          return a && a.__esModule ? a : { default: a }
        }
      Object.defineProperty(e, '__esModule', { value: !0 })
      const r = t(dC())
      const n =
        String.fromCodePoint ||
        function (a) {
          let i = ''
          return (
            a > 65535 &&
              ((a -= 65536),
              (i += String.fromCharCode(((a >>> 10) & 1023) | 55296)),
              (a = 56320 | (a & 1023))),
            (i += String.fromCharCode(a)),
            i
          )
        }
      function o(a) {
        return (a >= 55296 && a <= 57343) || a > 1114111
          ? '\uFFFD'
          : (a in r.default && (a = r.default[a]), n(a))
      }
      ;(h(o, 'decodeCodePoint'), (e.default = o))
    })
    const t0 = ge(e => {
      'use strict'
      const t =
        (e && e.__importDefault) ||
        function (d) {
          return d && d.__esModule ? d : { default: d }
        }
      ;(Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.decodeHTML = e.decodeHTMLStrict = e.decodeXML = void 0))
      const r = t(jy())
      const n = t(cC())
      const o = t(My())
      const a = t(pC())
      const i = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g
      ;((e.decodeXML = s(o.default)), (e.decodeHTMLStrict = s(r.default)))
      function s(d) {
        const m = u(d)
        return function (p) {
          return String(p).replace(i, m)
        }
      }
      h(s, 'getStrictDecoder')
      const l = h(function (d, m) {
        return d < m ? 1 : -1
      }, 'sorter')
      e.decodeHTML = (function () {
        for (
          var d = Object.keys(n.default).sort(l),
            m = Object.keys(r.default).sort(l),
            p = 0,
            f = 0;
          p < m.length;
          p++
        )
          d[f] === m[p] ? ((m[p] += ';?'), f++) : (m[p] += ';')
        const g = new RegExp(
          '&(?:' + m.join('|') + '|#[xX][\\da-fA-F]+;?|#\\d+;?)',
          'g'
        )
        const y = u(r.default)
        function E(b) {
          return (b.substr(-1) !== ';' && (b += ';'), y(b))
        }
        return (
          h(E, 'replacer'),
          function (b) {
            return String(b).replace(g, E)
          }
        )
      })()
      function u(d) {
        return h(function (m) {
          if (m.charAt(1) === '#') {
            const p = m.charAt(2)
            return p === 'X' || p === 'x'
              ? a.default(parseInt(m.substr(3), 16))
              : a.default(parseInt(m.substr(2), 10))
          }
          return d[m.slice(1, -1)] || m
        }, 'replace')
      }
      h(u, 'getReplacer')
    })
    const r0 = ge(e => {
      'use strict'
      const t =
        (e && e.__importDefault) ||
        function (x) {
          return x && x.__esModule ? x : { default: x }
        }
      ;(Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.escapeUTF8 =
          e.escape =
          e.encodeNonAsciiHTML =
          e.encodeHTML =
          e.encodeXML =
            void 0))
      const r = t(My())
      const n = l(r.default)
      const o = u(n)
      e.encodeXML = b(n)
      const a = t(jy())
      const i = l(a.default)
      const s = u(i)
      ;((e.encodeHTML = f(i, s)), (e.encodeNonAsciiHTML = b(i)))
      function l(x) {
        return Object.keys(x)
          .sort()
          .reduce(function (S, T) {
            return ((S[x[T]] = '&' + T + ';'), S)
          }, {})
      }
      h(l, 'getInverseObj')
      function u(x) {
        for (var S = [], T = [], _ = 0, O = Object.keys(x); _ < O.length; _++) {
          const k = O[_]
          k.length === 1 ? S.push('\\' + k) : T.push(k)
        }
        S.sort()
        for (let B = 0; B < S.length - 1; B++) {
          for (
            var P = B;
            P < S.length - 1 &&
            S[P].charCodeAt(1) + 1 === S[P + 1].charCodeAt(1);

          )
            P += 1
          const L = 1 + P - B
          L < 3 || S.splice(B, L, S[B] + '-' + S[P])
        }
        return (T.unshift('[' + S.join('') + ']'), new RegExp(T.join('|'), 'g'))
      }
      h(u, 'getInverseReplacer')
      const d =
        /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g
      const m =
        String.prototype.codePointAt != null
          ? function (x) {
              return x.codePointAt(0)
            }
          : function (x) {
              return (
                (x.charCodeAt(0) - 55296) * 1024 +
                x.charCodeAt(1) -
                56320 +
                65536
              )
            }
      function p(x) {
        return (
          '&#x' +
          (x.length > 1 ? m(x) : x.charCodeAt(0)).toString(16).toUpperCase() +
          ';'
        )
      }
      h(p, 'singleCharReplacer')
      function f(x, S) {
        return function (T) {
          return T.replace(S, function (_) {
            return x[_]
          }).replace(d, p)
        }
      }
      h(f, 'getInverse')
      const g = new RegExp(o.source + '|' + d.source, 'g')
      function y(x) {
        return x.replace(g, p)
      }
      ;(h(y, 'escape'), (e.escape = y))
      function E(x) {
        return x.replace(o, p)
      }
      ;(h(E, 'escapeUTF8'), (e.escapeUTF8 = E))
      function b(x) {
        return function (S) {
          return S.replace(g, function (T) {
            return x[T] || p(T)
          })
        }
      }
      h(b, 'getASCIIEncoder')
    })
    const mC = ge(e => {
      'use strict'
      ;(Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.decodeXMLStrict =
          e.decodeHTML5Strict =
          e.decodeHTML4Strict =
          e.decodeHTML5 =
          e.decodeHTML4 =
          e.decodeHTMLStrict =
          e.decodeHTML =
          e.decodeXML =
          e.encodeHTML5 =
          e.encodeHTML4 =
          e.escapeUTF8 =
          e.escape =
          e.encodeNonAsciiHTML =
          e.encodeHTML =
          e.encodeXML =
          e.encode =
          e.decodeStrict =
          e.decode =
            void 0))
      const t = t0()
      const r = r0()
      function n(l, u) {
        return (!u || u <= 0 ? t.decodeXML : t.decodeHTML)(l)
      }
      ;(h(n, 'decode'), (e.decode = n))
      function o(l, u) {
        return (!u || u <= 0 ? t.decodeXML : t.decodeHTMLStrict)(l)
      }
      ;(h(o, 'decodeStrict'), (e.decodeStrict = o))
      function a(l, u) {
        return (!u || u <= 0 ? r.encodeXML : r.encodeHTML)(l)
      }
      ;(h(a, 'encode'), (e.encode = a))
      const i = r0()
      ;(Object.defineProperty(e, 'encodeXML', {
        enumerable: !0,
        get: h(function () {
          return i.encodeXML
        }, 'get'),
      }),
        Object.defineProperty(e, 'encodeHTML', {
          enumerable: !0,
          get: h(function () {
            return i.encodeHTML
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeNonAsciiHTML', {
          enumerable: !0,
          get: h(function () {
            return i.encodeNonAsciiHTML
          }, 'get'),
        }),
        Object.defineProperty(e, 'escape', {
          enumerable: !0,
          get: h(function () {
            return i.escape
          }, 'get'),
        }),
        Object.defineProperty(e, 'escapeUTF8', {
          enumerable: !0,
          get: h(function () {
            return i.escapeUTF8
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeHTML4', {
          enumerable: !0,
          get: h(function () {
            return i.encodeHTML
          }, 'get'),
        }),
        Object.defineProperty(e, 'encodeHTML5', {
          enumerable: !0,
          get: h(function () {
            return i.encodeHTML
          }, 'get'),
        }))
      const s = t0()
      ;(Object.defineProperty(e, 'decodeXML', {
        enumerable: !0,
        get: h(function () {
          return s.decodeXML
        }, 'get'),
      }),
        Object.defineProperty(e, 'decodeHTML', {
          enumerable: !0,
          get: h(function () {
            return s.decodeHTML
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTMLStrict', {
          enumerable: !0,
          get: h(function () {
            return s.decodeHTMLStrict
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML4', {
          enumerable: !0,
          get: h(function () {
            return s.decodeHTML
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML5', {
          enumerable: !0,
          get: h(function () {
            return s.decodeHTML
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML4Strict', {
          enumerable: !0,
          get: h(function () {
            return s.decodeHTMLStrict
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeHTML5Strict', {
          enumerable: !0,
          get: h(function () {
            return s.decodeHTMLStrict
          }, 'get'),
        }),
        Object.defineProperty(e, 'decodeXMLStrict', {
          enumerable: !0,
          get: h(function () {
            return s.decodeXML
          }, 'get'),
        }))
    })
    const hC = ge((e, t) => {
      'use strict'
      function r(v, A) {
        if (!(v instanceof A))
          throw new TypeError('Cannot call a class as a function')
      }
      h(r, '_classCallCheck')
      function n(v, A) {
        for (let D = 0; D < A.length; D++) {
          const N = A[D]
          ;((N.enumerable = N.enumerable || !1),
            (N.configurable = !0),
            'value' in N && (N.writable = !0),
            Object.defineProperty(v, N.key, N))
        }
      }
      h(n, '_defineProperties')
      function o(v, A, D) {
        return (A && n(v.prototype, A), D && n(v, D), v)
      }
      h(o, '_createClass')
      function a(v, A) {
        let D = (typeof Symbol < 'u' && v[Symbol.iterator]) || v['@@iterator']
        if (!D) {
          if (
            Array.isArray(v) ||
            (D = i(v)) ||
            (A && v && typeof v.length === 'number')
          ) {
            D && (v = D)
            let N = 0
            const F = h(function () {}, 'F')
            return {
              s: F,
              n: h(function () {
                return N >= v.length
                  ? { done: !0 }
                  : { done: !1, value: v[N++] }
              }, 'n'),
              e: h(function (G) {
                throw G
              }, 'e'),
              f: F,
            }
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }
        let M = !0
        let q = !1
        let V
        return {
          s: h(function () {
            D = D.call(v)
          }, 's'),
          n: h(function () {
            const G = D.next()
            return ((M = G.done), G)
          }, 'n'),
          e: h(function (G) {
            ;((q = !0), (V = G))
          }, 'e'),
          f: h(function () {
            try {
              !M && D.return != null && D.return()
            } finally {
              if (q) throw V
            }
          }, 'f'),
        }
      }
      h(a, '_createForOfIteratorHelper')
      function i(v, A) {
        if (v) {
          if (typeof v === 'string') return s(v, A)
          let D = Object.prototype.toString.call(v).slice(8, -1)
          if (
            (D === 'Object' && v.constructor && (D = v.constructor.name),
            D === 'Map' || D === 'Set')
          )
            return Array.from(v)
          if (
            D === 'Arguments' ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(D)
          )
            return s(v, A)
        }
      }
      h(i, '_unsupportedIterableToArray')
      function s(v, A) {
        ;(A == null || A > v.length) && (A = v.length)
        for (var D = 0, N = new Array(A); D < A; D++) N[D] = v[D]
        return N
      }
      h(s, '_arrayLikeToArray')
      const l = mC()
      const u = {
        fg: '#FFF',
        bg: '#000',
        newline: !1,
        escapeXML: !1,
        stream: !1,
        colors: d(),
      }
      function d() {
        const v = {
          0: '#000',
          1: '#A00',
          2: '#0A0',
          3: '#A50',
          4: '#00A',
          5: '#A0A',
          6: '#0AA',
          7: '#AAA',
          8: '#555',
          9: '#F55',
          10: '#5F5',
          11: '#FF5',
          12: '#55F',
          13: '#F5F',
          14: '#5FF',
          15: '#FFF',
        }
        return (
          x(0, 5).forEach(function (A) {
            x(0, 5).forEach(function (D) {
              x(0, 5).forEach(function (N) {
                return m(A, D, N, v)
              })
            })
          }),
          x(0, 23).forEach(function (A) {
            const D = A + 232
            const N = p(A * 10 + 8)
            v[D] = '#' + N + N + N
          }),
          v
        )
      }
      h(d, 'getDefaultColors')
      function m(v, A, D, N) {
        const F = 16 + v * 36 + A * 6 + D
        const M = v > 0 ? v * 40 + 55 : 0
        const q = A > 0 ? A * 40 + 55 : 0
        const V = D > 0 ? D * 40 + 55 : 0
        N[F] = f([M, q, V])
      }
      h(m, 'setStyleColor')
      function p(v) {
        for (var A = v.toString(16); A.length < 2; ) A = '0' + A
        return A
      }
      h(p, 'toHexString')
      function f(v) {
        const A = []
        const D = a(v)
        let N
        try {
          for (D.s(); !(N = D.n()).done; ) {
            const F = N.value
            A.push(p(F))
          }
        } catch (M) {
          D.e(M)
        } finally {
          D.f()
        }
        return '#' + A.join('')
      }
      h(f, 'toColorHexString')
      function g(v, A, D, N) {
        let F
        return (
          A === 'text'
            ? (F = _(D, N))
            : A === 'display'
              ? (F = E(v, D, N))
              : A === 'xterm256Foreground'
                ? (F = B(v, N.colors[D]))
                : A === 'xterm256Background'
                  ? (F = P(v, N.colors[D]))
                  : A === 'rgb' && (F = y(v, D)),
          F
        )
      }
      h(g, 'generateOutput')
      function y(v, A) {
        A = A.substring(2).slice(0, -1)
        const D = +A.substr(0, 2)
        const N = A.substring(5).split(';')
        const F = N.map(function (M) {
          return ('0' + Number(M).toString(16)).substr(-2)
        }).join('')
        return k(v, (D === 38 ? 'color:#' : 'background-color:#') + F)
      }
      h(y, 'handleRgb')
      function E(v, A, D) {
        A = parseInt(A, 10)
        const N = {
          '-1': h(function () {
            return '<br/>'
          }, '_'),
          0: h(function () {
            return v.length && b(v)
          }, '_'),
          1: h(function () {
            return O(v, 'b')
          }, '_'),
          3: h(function () {
            return O(v, 'i')
          }, '_'),
          4: h(function () {
            return O(v, 'u')
          }, '_'),
          8: h(function () {
            return k(v, 'display:none')
          }, '_'),
          9: h(function () {
            return O(v, 'strike')
          }, '_'),
          22: h(function () {
            return k(
              v,
              'font-weight:normal;text-decoration:none;font-style:normal'
            )
          }, '_'),
          23: h(function () {
            return L(v, 'i')
          }, '_'),
          24: h(function () {
            return L(v, 'u')
          }, '_'),
          39: h(function () {
            return B(v, D.fg)
          }, '_'),
          49: h(function () {
            return P(v, D.bg)
          }, '_'),
          53: h(function () {
            return k(v, 'text-decoration:overline')
          }, '_'),
        }
        let F
        return (
          N[A]
            ? (F = N[A]())
            : A > 4 && A < 7
              ? (F = O(v, 'blink'))
              : A > 29 && A < 38
                ? (F = B(v, D.colors[A - 30]))
                : A > 39 && A < 48
                  ? (F = P(v, D.colors[A - 40]))
                  : A > 89 && A < 98
                    ? (F = B(v, D.colors[8 + (A - 90)]))
                    : A > 99 && A < 108 && (F = P(v, D.colors[8 + (A - 100)])),
          F
        )
      }
      h(E, 'handleDisplay')
      function b(v) {
        const A = v.slice(0)
        return (
          (v.length = 0),
          A.reverse()
            .map(function (D) {
              return '</' + D + '>'
            })
            .join('')
        )
      }
      h(b, 'resetStyles')
      function x(v, A) {
        for (var D = [], N = v; N <= A; N++) D.push(N)
        return D
      }
      h(x, 'range')
      function S(v) {
        return function (A) {
          return (v === null || A.category !== v) && v !== 'all'
        }
      }
      h(S, 'notCategory')
      function T(v) {
        v = parseInt(v, 10)
        let A = null
        return (
          v === 0
            ? (A = 'all')
            : v === 1
              ? (A = 'bold')
              : v > 2 && v < 5
                ? (A = 'underline')
                : v > 4 && v < 7
                  ? (A = 'blink')
                  : v === 8
                    ? (A = 'hide')
                    : v === 9
                      ? (A = 'strike')
                      : (v > 29 && v < 38) || v === 39 || (v > 89 && v < 98)
                        ? (A = 'foreground-color')
                        : ((v > 39 && v < 48) ||
                            v === 49 ||
                            (v > 99 && v < 108)) &&
                          (A = 'background-color'),
          A
        )
      }
      h(T, 'categoryForCode')
      function _(v, A) {
        return A.escapeXML ? l.encodeXML(v) : v
      }
      h(_, 'pushText')
      function O(v, A, D) {
        return (
          D || (D = ''),
          v.push(A),
          '<'.concat(A).concat(D ? ' style="'.concat(D, '"') : '', '>')
        )
      }
      h(O, 'pushTag')
      function k(v, A) {
        return O(v, 'span', A)
      }
      h(k, 'pushStyle')
      function B(v, A) {
        return O(v, 'span', 'color:' + A)
      }
      h(B, 'pushForegroundColor')
      function P(v, A) {
        return O(v, 'span', 'background-color:' + A)
      }
      h(P, 'pushBackgroundColor')
      function L(v, A) {
        let D
        if ((v.slice(-1)[0] === A && (D = v.pop()), D)) return '</' + A + '>'
      }
      h(L, 'closeTag')
      function j(v, A, D) {
        let N = !1
        const F = 3
        function M() {
          return ''
        }
        h(M, 'remove')
        function q(me, ue) {
          return (D('xterm256Foreground', ue), '')
        }
        h(q, 'removeXterm256Foreground')
        function V(me, ue) {
          return (D('xterm256Background', ue), '')
        }
        h(V, 'removeXterm256Background')
        function G(me) {
          return (A.newline ? D('display', -1) : D('text', me), '')
        }
        h(G, 'newline')
        function se(me, ue) {
          ;((N = !0),
            ue.trim().length === 0 && (ue = '0'),
            (ue = ue.trimRight(';').split(';')))
          const ht = a(ue)
          let Sn
          try {
            for (ht.s(); !(Sn = ht.n()).done; ) {
              const Ei = Sn.value
              D('display', Ei)
            }
          } catch (vi) {
            ht.e(vi)
          } finally {
            ht.f()
          }
          return ''
        }
        h(se, 'ansiMess')
        function pe(me) {
          return (D('text', me), '')
        }
        h(pe, 'realText')
        function ae(me) {
          return (D('rgb', me), '')
        }
        h(ae, 'rgb')
        const we = [
          { pattern: /^\x08+/, sub: M },
          { pattern: /^\x1B\[[012]?K/, sub: M },
          { pattern: /^\x1B\[\(B/, sub: M },
          { pattern: /^\x1B\[[34]8;2;\d+;\d+;\d+m/, sub: ae },
          { pattern: /^\x1B\[38;5;(\d+)m/, sub: q },
          { pattern: /^\x1B\[48;5;(\d+)m/, sub: V },
          { pattern: /^\n/, sub: G },
          { pattern: /^\r+\n/, sub: G },
          { pattern: /^\r/, sub: G },
          { pattern: /^\x1B\[((?:\d{1,3};?)+|)m/, sub: se },
          { pattern: /^\x1B\[\d?J/, sub: M },
          { pattern: /^\x1B\[\d{0,3};\d{0,3}f/, sub: M },
          { pattern: /^\x1B\[?[\d;]{0,3}/, sub: M },
          { pattern: /^(([^\x1B\x08\r\n])+)/, sub: pe },
        ]
        function ee(me, ue) {
          ;(ue > F && N) || ((N = !1), (v = v.replace(me.pattern, me.sub)))
        }
        h(ee, 'process')
        const Ce = []
        const Ve = v
        let Fe = Ve.length
        e: for (; Fe > 0; ) {
          for (let lt = 0, Zt = 0, Nr = we.length; Zt < Nr; lt = ++Zt) {
            const W = we[lt]
            if ((ee(W, lt), v.length !== Fe)) {
              Fe = v.length
              continue e
            }
          }
          if (v.length === Fe) break
          ;(Ce.push(0), (Fe = v.length))
        }
        return Ce
      }
      h(j, 'tokenize')
      function U(v, A, D) {
        return (
          A !== 'text' &&
            ((v = v.filter(S(T(D)))),
            v.push({ token: A, data: D, category: T(D) })),
          v
        )
      }
      h(U, 'updateStickyStack')
      const $ = (function () {
        function v(A) {
          ;(r(this, v),
            (A = A || {}),
            A.colors && (A.colors = Object.assign({}, u.colors, A.colors)),
            (this.options = Object.assign({}, u, A)),
            (this.stack = []),
            (this.stickyStack = []))
        }
        return (
          h(v, 'Filter'),
          o(v, [
            {
              key: 'toHtml',
              value: h(function (A) {
                const D = this
                A = typeof A === 'string' ? [A] : A
                const N = this.stack
                const F = this.options
                const M = []
                return (
                  this.stickyStack.forEach(function (q) {
                    const V = g(N, q.token, q.data, F)
                    V && M.push(V)
                  }),
                  j(A.join(''), F, function (q, V) {
                    const G = g(N, q, V, F)
                    ;(G && M.push(G),
                      F.stream && (D.stickyStack = U(D.stickyStack, q, V)))
                  }),
                  N.length && M.push(b(N)),
                  M.join('')
                )
              }, 'toHtml'),
            },
          ]),
          v
        )
      })()
      t.exports = $
    })
    const Yu = ge((e, t) => {
      function r() {
        return (
          (t.exports = r =
            Object.assign ||
            function (n) {
              for (let o = 1; o < arguments.length; o++) {
                const a = arguments[o]
                for (const i in a)
                  Object.prototype.hasOwnProperty.call(a, i) && (n[i] = a[i])
              }
              return n
            }),
          r.apply(this, arguments)
        )
      }
      ;(h(r, '_extends'), (t.exports = r))
    })
    const fC = ge((e, t) => {
      function r(n, o) {
        if (n == null) return {}
        const a = {}
        const i = Object.keys(n)
        let s
        let l
        for (l = 0; l < i.length; l++)
          ((s = i[l]), !o.includes(s) && (a[s] = n[s]))
        return a
      }
      ;(h(r, '_objectWithoutPropertiesLoose'), (t.exports = r))
    })
    const Ku = ge((e, t) => {
      const r = fC()
      function n(o, a) {
        if (o == null) return {}
        const i = r(o, a)
        let s
        let l
        if (Object.getOwnPropertySymbols) {
          const u = Object.getOwnPropertySymbols(o)
          for (l = 0; l < u.length; l++)
            ((s = u[l]),
              !a.includes(s) &&
                Object.prototype.propertyIsEnumerable.call(o, s) &&
                (i[s] = o[s]))
        }
        return i
      }
      ;(h(n, '_objectWithoutProperties'), (t.exports = n))
    })
    const gC = ge((e, t) => {
      function r(n, o, a) {
        return (
          o in n
            ? Object.defineProperty(n, o, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (n[o] = a),
          n
        )
      }
      ;(h(r, '_defineProperty'), (t.exports = r))
    })
    const yC = ge((e, t) => {
      const r = gC()
      function n(a, i) {
        const s = Object.keys(a)
        if (Object.getOwnPropertySymbols) {
          let l = Object.getOwnPropertySymbols(a)
          ;(i &&
            (l = l.filter(function (u) {
              return Object.getOwnPropertyDescriptor(a, u).enumerable
            })),
            s.push.apply(s, l))
        }
        return s
      }
      h(n, 'ownKeys')
      function o(a) {
        for (let i = 1; i < arguments.length; i++) {
          var s = arguments[i] != null ? arguments[i] : {}
          i % 2
            ? n(s, !0).forEach(function (l) {
                r(a, l, s[l])
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(s))
              : n(s).forEach(function (l) {
                  Object.defineProperty(
                    a,
                    l,
                    Object.getOwnPropertyDescriptor(s, l)
                  )
                })
        }
        return a
      }
      ;(h(o, '_objectSpread2'), (t.exports = o))
    })
    const bC = ge((e, t) => {
      function r(n, o) {
        if (n == null) return {}
        const a = {}
        const i = Object.keys(n)
        let s
        let l
        for (l = 0; l < i.length; l++)
          ((s = i[l]), !o.includes(s) && (a[s] = n[s]))
        return a
      }
      ;(h(r, '_objectWithoutPropertiesLoose'), (t.exports = r))
    })
    const EC = ge((e, t) => {
      const r = bC()
      function n(o, a) {
        if (o == null) return {}
        const i = r(o, a)
        let s
        let l
        if (Object.getOwnPropertySymbols) {
          const u = Object.getOwnPropertySymbols(o)
          for (l = 0; l < u.length; l++)
            ((s = u[l]),
              !a.includes(s) &&
                Object.prototype.propertyIsEnumerable.call(o, s) &&
                (i[s] = o[s]))
        }
        return i
      }
      ;(h(n, '_objectWithoutProperties'), (t.exports = n))
    })
    const vC = ge((e, t) => {
      function r(n, o, a) {
        return (
          o in n
            ? Object.defineProperty(n, o, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (n[o] = a),
          n
        )
      }
      ;(h(r, '_defineProperty'), (t.exports = r))
    })
    const AC = ge((e, t) => {
      const r = vC()
      function n(a, i) {
        const s = Object.keys(a)
        if (Object.getOwnPropertySymbols) {
          let l = Object.getOwnPropertySymbols(a)
          ;(i &&
            (l = l.filter(function (u) {
              return Object.getOwnPropertyDescriptor(a, u).enumerable
            })),
            s.push.apply(s, l))
        }
        return s
      }
      h(n, 'ownKeys')
      function o(a) {
        for (let i = 1; i < arguments.length; i++) {
          var s = arguments[i] != null ? arguments[i] : {}
          i % 2
            ? n(s, !0).forEach(function (l) {
                r(a, l, s[l])
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(s))
              : n(s).forEach(function (l) {
                  Object.defineProperty(
                    a,
                    l,
                    Object.getOwnPropertyDescriptor(s, l)
                  )
                })
        }
        return a
      }
      ;(h(o, '_objectSpread2'), (t.exports = o))
    })
    const xC = ge((e, t) => {
      function r() {
        return (
          (t.exports = r =
            Object.assign ||
            function (n) {
              for (let o = 1; o < arguments.length; o++) {
                const a = arguments[o]
                for (const i in a)
                  Object.prototype.hasOwnProperty.call(a, i) && (n[i] = a[i])
              }
              return n
            }),
          r.apply(this, arguments)
        )
      }
      ;(h(r, '_extends'), (t.exports = r))
    })
    const wC = ge((e, t) => {
      function r(n, o) {
        if (n == null) return {}
        const a = {}
        const i = Object.keys(n)
        let s
        let l
        for (l = 0; l < i.length; l++)
          ((s = i[l]), !o.includes(s) && (a[s] = n[s]))
        return a
      }
      ;(h(r, '_objectWithoutPropertiesLoose'), (t.exports = r))
    })
    const SC = ge((e, t) => {
      const r = wC()
      function n(o, a) {
        if (o == null) return {}
        const i = r(o, a)
        let s
        let l
        if (Object.getOwnPropertySymbols) {
          const u = Object.getOwnPropertySymbols(o)
          for (l = 0; l < u.length; l++)
            ((s = u[l]),
              !a.includes(s) &&
                Object.prototype.propertyIsEnumerable.call(o, s) &&
                (i[s] = o[s]))
        }
        return i
      }
      ;(h(n, '_objectWithoutProperties'), (t.exports = n))
    })
    const n0 = Object.prototype.hasOwnProperty
    function bu(e, t, r) {
      for (r of e.keys()) if (fr(r, t)) return r
    }
    h(bu, 'find')
    function fr(e, t) {
      let r, n, o
      if (e === t) return !0
      if (e && t && (r = e.constructor) === t.constructor) {
        if (r === Date) return e.getTime() === t.getTime()
        if (r === RegExp) return e.toString() === t.toString()
        if (r === Array) {
          if ((n = e.length) === t.length) for (; n-- && fr(e[n], t[n]); );
          return n === -1
        }
        if (r === Set) {
          if (e.size !== t.size) return !1
          for (n of e)
            if (
              ((o = n),
              (o && typeof o === 'object' && ((o = bu(t, o)), !o)) || !t.has(o))
            )
              return !1
          return !0
        }
        if (r === Map) {
          if (e.size !== t.size) return !1
          for (n of e)
            if (
              ((o = n[0]),
              (o && typeof o === 'object' && ((o = bu(t, o)), !o)) ||
                !fr(n[1], t.get(o)))
            )
              return !1
          return !0
        }
        if (r === ArrayBuffer)
          ((e = new Uint8Array(e)), (t = new Uint8Array(t)))
        else if (r === DataView) {
          if ((n = e.byteLength) === t.byteLength)
            for (; n-- && e.getInt8(n) === t.getInt8(n); );
          return n === -1
        }
        if (ArrayBuffer.isView(e)) {
          if ((n = e.byteLength) === t.byteLength)
            for (; n-- && e[n] === t[n]; );
          return n === -1
        }
        if (!r || typeof e === 'object') {
          n = 0
          for (r in e)
            if (
              (n0.call(e, r) && ++n && !n0.call(t, r)) ||
              !(r in t) ||
              !fr(e[r], t[r])
            )
              return !1
          return Object.keys(t).length === n
        }
      }
      return e !== e && t !== t
    }
    h(fr, 'dequal')
    pi()
    function Ye() {
      return (
        (Ye = Object.assign
          ? Object.assign.bind()
          : function (e) {
              for (let t = 1; t < arguments.length; t++) {
                const r = arguments[t]
                for (const n in r)
                  ({}).hasOwnProperty.call(r, n) && (e[n] = r[n])
              }
              return e
            }),
        Ye.apply(null, arguments)
      )
    }
    h(Ye, '_extends')
    function $y(e) {
      if (e === void 0)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        )
      return e
    }
    h($y, '_assertThisInitialized')
    function An(e, t) {
      return (
        (An = Object.setPrototypeOf
          ? Object.setPrototypeOf.bind()
          : function (r, n) {
              return ((r.__proto__ = n), r)
            }),
        An(e, t)
      )
    }
    h(An, '_setPrototypeOf')
    function qy(e, t) {
      ;((e.prototype = Object.create(t.prototype)),
        (e.prototype.constructor = e),
        An(e, t))
    }
    h(qy, '_inheritsLoose')
    function ri(e) {
      return (
        (ri = Object.setPrototypeOf
          ? Object.getPrototypeOf.bind()
          : function (t) {
              return t.__proto__ || Object.getPrototypeOf(t)
            }),
        ri(e)
      )
    }
    h(ri, '_getPrototypeOf')
    function Uy(e) {
      try {
        return Function.toString.call(e).includes('[native code]')
      } catch {
        return typeof e === 'function'
      }
    }
    h(Uy, '_isNativeFunction')
    function Xu() {
      try {
        var e = !Boolean.prototype.valueOf.call(
          Reflect.construct(Boolean, [], function () {})
        )
      } catch {}
      return (Xu = h(function () {
        return !!e
      }, '_isNativeReflectConstruct'))()
    }
    h(Xu, '_isNativeReflectConstruct')
    function Hy(e, t, r) {
      if (Xu()) return Reflect.construct.apply(null, arguments)
      const n = [null]
      n.push.apply(n, t)
      const o = new (e.bind.apply(e, n))()
      return (r && An(o, r.prototype), o)
    }
    h(Hy, '_construct')
    function ni(e) {
      const t = typeof Map === 'function' ? new Map() : void 0
      return (
        (ni = h(function (r) {
          if (r === null || !Uy(r)) return r
          if (typeof r !== 'function')
            throw new TypeError(
              'Super expression must either be null or a function'
            )
          if (t !== void 0) {
            if (t.has(r)) return t.get(r)
            t.set(r, n)
          }
          function n() {
            return Hy(r, arguments, ri(this).constructor)
          }
          return (
            h(n, 'Wrapper'),
            (n.prototype = Object.create(r.prototype, {
              constructor: {
                value: n,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            })),
            An(n, r)
          )
        }, '_wrapNativeSuper')),
        ni(e)
      )
    }
    h(ni, '_wrapNativeSuper')
    const CC = {
      1: `Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).

`,
      2: `Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).

`,
      3: `Passed an incorrect argument to a color function, please pass a string representation of a color.

`,
      4: `Couldn't generate valid rgb string from %s, it returned %s.

`,
      5: `Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.

`,
      6: `Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).

`,
      7: `Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).

`,
      8: `Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.

`,
      9: `Please provide a number of steps to the modularScale helper.

`,
      10: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
      11: `Invalid value passed as base to modularScale, expected number or em string but got "%s"

`,
      12: `Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.

`,
      13: `Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.

`,
      14: `Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.

`,
      15: `Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.

`,
      16: `You must provide a template to this method.

`,
      17: `You passed an unsupported selector state to this method.

`,
      18: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
      19: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
      20: `expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
      21: 'expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n',
      22: 'expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n',
      23: `fontFace expects a name of a font-family.

`,
      24: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
      25: `fontFace expects localFonts to be an array.

`,
      26: `fontFace expects fileFormats to be an array.

`,
      27: `radialGradient requries at least 2 color-stops to properly render.

`,
      28: `Please supply a filename to retinaImage() as the first argument.

`,
      29: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
      30: 'Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n',
      31: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation

`,
      32: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])
To pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')

`,
      33: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation

`,
      34: `borderRadius expects a radius value as a string or number as the second argument.

`,
      35: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
      36: `Property must be a string value.

`,
      37: `Syntax Error at %s.

`,
      38: `Formula contains a function that needs parentheses at %s.

`,
      39: `Formula is missing closing parenthesis at %s.

`,
      40: `Formula has too many closing parentheses at %s.

`,
      41: `All values in a formula must have the same unit or be unitless.

`,
      42: `Please provide a number of steps to the modularScale helper.

`,
      43: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
      44: `Invalid value passed as base to modularScale, expected number or em/rem string but got %s.

`,
      45: `Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.

`,
      46: `Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.

`,
      47: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
      48: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
      49: `Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
      50: `Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.

`,
      51: `Expects the first argument object to have the properties prop, fromSize, and toSize.

`,
      52: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
      53: `fontFace expects localFonts to be an array.

`,
      54: `fontFace expects fileFormats to be an array.

`,
      55: `fontFace expects a name of a font-family.

`,
      56: `linearGradient requries at least 2 color-stops to properly render.

`,
      57: `radialGradient requries at least 2 color-stops to properly render.

`,
      58: `Please supply a filename to retinaImage() as the first argument.

`,
      59: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
      60: 'Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n',
      61: `Property must be a string value.

`,
      62: `borderRadius expects a radius value as a string or number as the second argument.

`,
      63: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
      64: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.

`,
      65: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').

`,
      66: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.

`,
      67: `You must provide a template to this method.

`,
      68: `You passed an unsupported selector state to this method.

`,
      69: `Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.

`,
      70: `Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.

`,
      71: `Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.

`,
      72: `Passed invalid base value %s to %s(), please pass a value like "12px" or 12.

`,
      73: `Please provide a valid CSS variable.

`,
      74: `CSS variable not found and no default was provided.

`,
      75: `important requires a valid style object, got a %s instead.

`,
      76: `fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.

`,
      77: `remToPx expects a value in "rem" but you provided it in "%s".

`,
      78: `base must be set in "px" or "%" but you set it in "%s".
`,
    }
    function Vy() {
      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
        t[r] = arguments[r]
      let n = t[0]
      const o = []
      let a
      for (a = 1; a < t.length; a += 1) o.push(t[a])
      return (
        o.forEach(function (i) {
          n = n.replace(/%[a-z]/, i)
        }),
        n
      )
    }
    h(Vy, 'format')
    const at = (function (e) {
      qy(t, e)
      function t(r) {
        for (
          var n, o = arguments.length, a = new Array(o > 1 ? o - 1 : 0), i = 1;
          i < o;
          i++
        )
          a[i - 1] = arguments[i]
        return (
          (n = e.call(this, Vy.apply(void 0, [CC[r]].concat(a))) || this),
          $y(n)
        )
      }
      return (h(t, 'PolishedError'), t)
    })(ni(Error))
    function Eu(e, t) {
      return e.substr(-t.length) === t
    }
    h(Eu, 'endsWith')
    const DC = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/
    function vu(e) {
      if (typeof e !== 'string') return e
      const t = e.match(DC)
      return t ? parseFloat(e) : e
    }
    h(vu, 'stripUnit')
    const TC = h(function (e) {
      return function (t, r) {
        r === void 0 && (r = '16px')
        let n = t
        let o = r
        if (typeof t === 'string') {
          if (!Eu(t, 'px')) throw new at(69, e, t)
          n = vu(t)
        }
        if (typeof r === 'string') {
          if (!Eu(r, 'px')) throw new at(70, e, r)
          o = vu(r)
        }
        if (typeof n === 'string') throw new at(71, t, e)
        if (typeof o === 'string') throw new at(72, r, e)
        return '' + n / o + e
      }
    }, 'pxtoFactory')
    const zy = TC
    const M8 = zy('em')
    const $8 = zy('rem')
    function Ya(e) {
      return Math.round(e * 255)
    }
    h(Ya, 'colorToInt')
    function Gy(e, t, r) {
      return Ya(e) + ',' + Ya(t) + ',' + Ya(r)
    }
    h(Gy, 'convertToInt')
    function xn(e, t, r, n) {
      if ((n === void 0 && (n = Gy), t === 0)) return n(r, r, r)
      const o = (((e % 360) + 360) % 360) / 60
      const a = (1 - Math.abs(2 * r - 1)) * t
      const i = a * (1 - Math.abs((o % 2) - 1))
      let s = 0
      let l = 0
      let u = 0
      o >= 0 && o < 1
        ? ((s = a), (l = i))
        : o >= 1 && o < 2
          ? ((s = i), (l = a))
          : o >= 2 && o < 3
            ? ((l = a), (u = i))
            : o >= 3 && o < 4
              ? ((l = i), (u = a))
              : o >= 4 && o < 5
                ? ((s = i), (u = a))
                : o >= 5 && o < 6 && ((s = a), (u = i))
      const d = r - a / 2
      const m = s + d
      const p = l + d
      const f = u + d
      return n(m, p, f)
    }
    h(xn, 'hslToRgb')
    const o0 = {
      aliceblue: 'f0f8ff',
      antiquewhite: 'faebd7',
      aqua: '00ffff',
      aquamarine: '7fffd4',
      azure: 'f0ffff',
      beige: 'f5f5dc',
      bisque: 'ffe4c4',
      black: '000',
      blanchedalmond: 'ffebcd',
      blue: '0000ff',
      blueviolet: '8a2be2',
      brown: 'a52a2a',
      burlywood: 'deb887',
      cadetblue: '5f9ea0',
      chartreuse: '7fff00',
      chocolate: 'd2691e',
      coral: 'ff7f50',
      cornflowerblue: '6495ed',
      cornsilk: 'fff8dc',
      crimson: 'dc143c',
      cyan: '00ffff',
      darkblue: '00008b',
      darkcyan: '008b8b',
      darkgoldenrod: 'b8860b',
      darkgray: 'a9a9a9',
      darkgreen: '006400',
      darkgrey: 'a9a9a9',
      darkkhaki: 'bdb76b',
      darkmagenta: '8b008b',
      darkolivegreen: '556b2f',
      darkorange: 'ff8c00',
      darkorchid: '9932cc',
      darkred: '8b0000',
      darksalmon: 'e9967a',
      darkseagreen: '8fbc8f',
      darkslateblue: '483d8b',
      darkslategray: '2f4f4f',
      darkslategrey: '2f4f4f',
      darkturquoise: '00ced1',
      darkviolet: '9400d3',
      deeppink: 'ff1493',
      deepskyblue: '00bfff',
      dimgray: '696969',
      dimgrey: '696969',
      dodgerblue: '1e90ff',
      firebrick: 'b22222',
      floralwhite: 'fffaf0',
      forestgreen: '228b22',
      fuchsia: 'ff00ff',
      gainsboro: 'dcdcdc',
      ghostwhite: 'f8f8ff',
      gold: 'ffd700',
      goldenrod: 'daa520',
      gray: '808080',
      green: '008000',
      greenyellow: 'adff2f',
      grey: '808080',
      honeydew: 'f0fff0',
      hotpink: 'ff69b4',
      indianred: 'cd5c5c',
      indigo: '4b0082',
      ivory: 'fffff0',
      khaki: 'f0e68c',
      lavender: 'e6e6fa',
      lavenderblush: 'fff0f5',
      lawngreen: '7cfc00',
      lemonchiffon: 'fffacd',
      lightblue: 'add8e6',
      lightcoral: 'f08080',
      lightcyan: 'e0ffff',
      lightgoldenrodyellow: 'fafad2',
      lightgray: 'd3d3d3',
      lightgreen: '90ee90',
      lightgrey: 'd3d3d3',
      lightpink: 'ffb6c1',
      lightsalmon: 'ffa07a',
      lightseagreen: '20b2aa',
      lightskyblue: '87cefa',
      lightslategray: '789',
      lightslategrey: '789',
      lightsteelblue: 'b0c4de',
      lightyellow: 'ffffe0',
      lime: '0f0',
      limegreen: '32cd32',
      linen: 'faf0e6',
      magenta: 'f0f',
      maroon: '800000',
      mediumaquamarine: '66cdaa',
      mediumblue: '0000cd',
      mediumorchid: 'ba55d3',
      mediumpurple: '9370db',
      mediumseagreen: '3cb371',
      mediumslateblue: '7b68ee',
      mediumspringgreen: '00fa9a',
      mediumturquoise: '48d1cc',
      mediumvioletred: 'c71585',
      midnightblue: '191970',
      mintcream: 'f5fffa',
      mistyrose: 'ffe4e1',
      moccasin: 'ffe4b5',
      navajowhite: 'ffdead',
      navy: '000080',
      oldlace: 'fdf5e6',
      olive: '808000',
      olivedrab: '6b8e23',
      orange: 'ffa500',
      orangered: 'ff4500',
      orchid: 'da70d6',
      palegoldenrod: 'eee8aa',
      palegreen: '98fb98',
      paleturquoise: 'afeeee',
      palevioletred: 'db7093',
      papayawhip: 'ffefd5',
      peachpuff: 'ffdab9',
      peru: 'cd853f',
      pink: 'ffc0cb',
      plum: 'dda0dd',
      powderblue: 'b0e0e6',
      purple: '800080',
      rebeccapurple: '639',
      red: 'f00',
      rosybrown: 'bc8f8f',
      royalblue: '4169e1',
      saddlebrown: '8b4513',
      salmon: 'fa8072',
      sandybrown: 'f4a460',
      seagreen: '2e8b57',
      seashell: 'fff5ee',
      sienna: 'a0522d',
      silver: 'c0c0c0',
      skyblue: '87ceeb',
      slateblue: '6a5acd',
      slategray: '708090',
      slategrey: '708090',
      snow: 'fffafa',
      springgreen: '00ff7f',
      steelblue: '4682b4',
      tan: 'd2b48c',
      teal: '008080',
      thistle: 'd8bfd8',
      tomato: 'ff6347',
      turquoise: '40e0d0',
      violet: 'ee82ee',
      wheat: 'f5deb3',
      white: 'fff',
      whitesmoke: 'f5f5f5',
      yellow: 'ff0',
      yellowgreen: '9acd32',
    }
    function Wy(e) {
      if (typeof e !== 'string') return e
      const t = e.toLowerCase()
      return o0[t] ? '#' + o0[t] : e
    }
    h(Wy, 'nameToHex')
    const kC = /^#[a-fA-F0-9]{6}$/
    const OC = /^#[a-fA-F0-9]{8}$/
    const IC = /^#[a-fA-F0-9]{3}$/
    const RC = /^#[a-fA-F0-9]{4}$/
    const ru =
      /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i
    const BC =
      /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i
    const _C =
      /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i
    const FC =
      /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i
    function Rr(e) {
      if (typeof e !== 'string') throw new at(3)
      const t = Wy(e)
      if (t.match(kC))
        return {
          red: parseInt('' + t[1] + t[2], 16),
          green: parseInt('' + t[3] + t[4], 16),
          blue: parseInt('' + t[5] + t[6], 16),
        }
      if (t.match(OC)) {
        const r = parseFloat((parseInt('' + t[7] + t[8], 16) / 255).toFixed(2))
        return {
          red: parseInt('' + t[1] + t[2], 16),
          green: parseInt('' + t[3] + t[4], 16),
          blue: parseInt('' + t[5] + t[6], 16),
          alpha: r,
        }
      }
      if (t.match(IC))
        return {
          red: parseInt('' + t[1] + t[1], 16),
          green: parseInt('' + t[2] + t[2], 16),
          blue: parseInt('' + t[3] + t[3], 16),
        }
      if (t.match(RC)) {
        const n = parseFloat((parseInt('' + t[4] + t[4], 16) / 255).toFixed(2))
        return {
          red: parseInt('' + t[1] + t[1], 16),
          green: parseInt('' + t[2] + t[2], 16),
          blue: parseInt('' + t[3] + t[3], 16),
          alpha: n,
        }
      }
      const o = ru.exec(t)
      if (o)
        return {
          red: parseInt('' + o[1], 10),
          green: parseInt('' + o[2], 10),
          blue: parseInt('' + o[3], 10),
        }
      const a = BC.exec(t.substring(0, 50))
      if (a)
        return {
          red: parseInt('' + a[1], 10),
          green: parseInt('' + a[2], 10),
          blue: parseInt('' + a[3], 10),
          alpha:
            parseFloat('' + a[4]) > 1
              ? parseFloat('' + a[4]) / 100
              : parseFloat('' + a[4]),
        }
      const i = _C.exec(t)
      if (i) {
        const s = parseInt('' + i[1], 10)
        const l = parseInt('' + i[2], 10) / 100
        const u = parseInt('' + i[3], 10) / 100
        const d = 'rgb(' + xn(s, l, u) + ')'
        const m = ru.exec(d)
        if (!m) throw new at(4, t, d)
        return {
          red: parseInt('' + m[1], 10),
          green: parseInt('' + m[2], 10),
          blue: parseInt('' + m[3], 10),
        }
      }
      const p = FC.exec(t.substring(0, 50))
      if (p) {
        const f = parseInt('' + p[1], 10)
        const g = parseInt('' + p[2], 10) / 100
        const y = parseInt('' + p[3], 10) / 100
        const E = 'rgb(' + xn(f, g, y) + ')'
        const b = ru.exec(E)
        if (!b) throw new at(4, t, E)
        return {
          red: parseInt('' + b[1], 10),
          green: parseInt('' + b[2], 10),
          blue: parseInt('' + b[3], 10),
          alpha:
            parseFloat('' + p[4]) > 1
              ? parseFloat('' + p[4]) / 100
              : parseFloat('' + p[4]),
        }
      }
      throw new at(5)
    }
    h(Rr, 'parseToRgb')
    function Yy(e) {
      const t = e.red / 255
      const r = e.green / 255
      const n = e.blue / 255
      const o = Math.max(t, r, n)
      const a = Math.min(t, r, n)
      const i = (o + a) / 2
      if (o === a)
        return e.alpha !== void 0
          ? { hue: 0, saturation: 0, lightness: i, alpha: e.alpha }
          : { hue: 0, saturation: 0, lightness: i }
      let s
      const l = o - a
      const u = i > 0.5 ? l / (2 - o - a) : l / (o + a)
      switch (o) {
        case t:
          s = (r - n) / l + (r < n ? 6 : 0)
          break
        case r:
          s = (n - t) / l + 2
          break
        default:
          s = (t - r) / l + 4
          break
      }
      return (
        (s *= 60),
        e.alpha !== void 0
          ? { hue: s, saturation: u, lightness: i, alpha: e.alpha }
          : { hue: s, saturation: u, lightness: i }
      )
    }
    h(Yy, 'rgbToHsl')
    function Xt(e) {
      return Yy(Rr(e))
    }
    h(Xt, 'parseToHsl')
    const PC = h(function (e) {
      return e.length === 7 && e[1] === e[2] && e[3] === e[4] && e[5] === e[6]
        ? '#' + e[1] + e[3] + e[5]
        : e
    }, 'reduceHexValue')
    const Au = PC
    function dr(e) {
      const t = e.toString(16)
      return t.length === 1 ? '0' + t : t
    }
    h(dr, 'numberToHex')
    function Ka(e) {
      return dr(Math.round(e * 255))
    }
    h(Ka, 'colorToHex')
    function Ky(e, t, r) {
      return Au('#' + Ka(e) + Ka(t) + Ka(r))
    }
    h(Ky, 'convertToHex')
    function io(e, t, r) {
      return xn(e, t, r, Ky)
    }
    h(io, 'hslToHex')
    function Xy(e, t, r) {
      if (
        typeof e === 'number' &&
        typeof t === 'number' &&
        typeof r === 'number'
      )
        return io(e, t, r)
      if (typeof e === 'object' && t === void 0 && r === void 0)
        return io(e.hue, e.saturation, e.lightness)
      throw new at(1)
    }
    h(Xy, 'hsl')
    function Jy(e, t, r, n) {
      if (
        typeof e === 'number' &&
        typeof t === 'number' &&
        typeof r === 'number' &&
        typeof n === 'number'
      )
        return n >= 1 ? io(e, t, r) : 'rgba(' + xn(e, t, r) + ',' + n + ')'
      if (typeof e === 'object' && t === void 0 && r === void 0 && n === void 0)
        return e.alpha >= 1
          ? io(e.hue, e.saturation, e.lightness)
          : 'rgba(' + xn(e.hue, e.saturation, e.lightness) + ',' + e.alpha + ')'
      throw new at(2)
    }
    h(Jy, 'hsla')
    function oi(e, t, r) {
      if (
        typeof e === 'number' &&
        typeof t === 'number' &&
        typeof r === 'number'
      )
        return Au('#' + dr(e) + dr(t) + dr(r))
      if (typeof e === 'object' && t === void 0 && r === void 0)
        return Au('#' + dr(e.red) + dr(e.green) + dr(e.blue))
      throw new at(6)
    }
    h(oi, 'rgb')
    function Tt(e, t, r, n) {
      if (typeof e === 'string' && typeof t === 'number') {
        const o = Rr(e)
        return 'rgba(' + o.red + ',' + o.green + ',' + o.blue + ',' + t + ')'
      } else {
        if (
          typeof e === 'number' &&
          typeof t === 'number' &&
          typeof r === 'number' &&
          typeof n === 'number'
        )
          return n >= 1
            ? oi(e, t, r)
            : 'rgba(' + e + ',' + t + ',' + r + ',' + n + ')'
        if (
          typeof e === 'object' &&
          t === void 0 &&
          r === void 0 &&
          n === void 0
        )
          return e.alpha >= 1
            ? oi(e.red, e.green, e.blue)
            : 'rgba(' +
                e.red +
                ',' +
                e.green +
                ',' +
                e.blue +
                ',' +
                e.alpha +
                ')'
      }
      throw new at(7)
    }
    h(Tt, 'rgba')
    const NC = h(function (e) {
      return (
        typeof e.red === 'number' &&
        typeof e.green === 'number' &&
        typeof e.blue === 'number' &&
        (typeof e.alpha !== 'number' || typeof e.alpha > 'u')
      )
    }, 'isRgb')
    const LC = h(function (e) {
      return (
        typeof e.red === 'number' &&
        typeof e.green === 'number' &&
        typeof e.blue === 'number' &&
        typeof e.alpha === 'number'
      )
    }, 'isRgba')
    const jC = h(function (e) {
      return (
        typeof e.hue === 'number' &&
        typeof e.saturation === 'number' &&
        typeof e.lightness === 'number' &&
        (typeof e.alpha !== 'number' || typeof e.alpha > 'u')
      )
    }, 'isHsl')
    const MC = h(function (e) {
      return (
        typeof e.hue === 'number' &&
        typeof e.saturation === 'number' &&
        typeof e.lightness === 'number' &&
        typeof e.alpha === 'number'
      )
    }, 'isHsla')
    function Jt(e) {
      if (typeof e !== 'object') throw new at(8)
      if (LC(e)) return Tt(e)
      if (NC(e)) return oi(e)
      if (MC(e)) return Jy(e)
      if (jC(e)) return Xy(e)
      throw new at(8)
    }
    h(Jt, 'toColorString')
    function Ju(e, t, r) {
      return h(function () {
        const n = r.concat(Array.prototype.slice.call(arguments))
        return n.length >= t ? e.apply(this, n) : Ju(e, t, n)
      }, 'fn')
    }
    h(Ju, 'curried')
    function st(e) {
      return Ju(e, e.length, [])
    }
    h(st, 'curry')
    function Zy(e, t) {
      if (t === 'transparent') return t
      const r = Xt(t)
      return Jt(Ye({}, r, { hue: r.hue + parseFloat(e) }))
    }
    h(Zy, 'adjustHue')
    const q8 = st(Zy)
    function Fr(e, t, r) {
      return Math.max(e, Math.min(t, r))
    }
    h(Fr, 'guard')
    function Qy(e, t) {
      if (t === 'transparent') return t
      const r = Xt(t)
      return Jt(Ye({}, r, { lightness: Fr(0, 1, r.lightness - parseFloat(e)) }))
    }
    h(Qy, 'darken')
    const $C = st(Qy)
    const Nt = $C
    function eb(e, t) {
      if (t === 'transparent') return t
      const r = Xt(t)
      return Jt(
        Ye({}, r, { saturation: Fr(0, 1, r.saturation - parseFloat(e)) })
      )
    }
    h(eb, 'desaturate')
    const U8 = st(eb)
    function tb(e, t) {
      if (t === 'transparent') return t
      const r = Xt(t)
      return Jt(Ye({}, r, { lightness: Fr(0, 1, r.lightness + parseFloat(e)) }))
    }
    h(tb, 'lighten')
    const qC = st(tb)
    const Or = qC
    function rb(e, t, r) {
      if (t === 'transparent') return r
      if (r === 'transparent') return t
      if (e === 0) return r
      const n = Rr(t)
      const o = Ye({}, n, { alpha: typeof n.alpha === 'number' ? n.alpha : 1 })
      const a = Rr(r)
      const i = Ye({}, a, { alpha: typeof a.alpha === 'number' ? a.alpha : 1 })
      const s = o.alpha - i.alpha
      const l = parseFloat(e) * 2 - 1
      const u = l * s === -1 ? l : l + s
      const d = 1 + l * s
      const m = (u / d + 1) / 2
      const p = 1 - m
      const f = {
        red: Math.floor(o.red * m + i.red * p),
        green: Math.floor(o.green * m + i.green * p),
        blue: Math.floor(o.blue * m + i.blue * p),
        alpha: o.alpha * parseFloat(e) + i.alpha * (1 - parseFloat(e)),
      }
      return Tt(f)
    }
    h(rb, 'mix')
    const UC = st(rb)
    const nb = UC
    function ob(e, t) {
      if (t === 'transparent') return t
      const r = Rr(t)
      const n = typeof r.alpha === 'number' ? r.alpha : 1
      const o = Ye({}, r, {
        alpha: Fr(0, 1, (n * 100 + parseFloat(e) * 100) / 100),
      })
      return Tt(o)
    }
    h(ob, 'opacify')
    const HC = st(ob)
    const Zn = HC
    function ab(e, t) {
      if (t === 'transparent') return t
      const r = Xt(t)
      return Jt(
        Ye({}, r, { saturation: Fr(0, 1, r.saturation + parseFloat(e)) })
      )
    }
    h(ab, 'saturate')
    const H8 = st(ab)
    function ib(e, t) {
      return t === 'transparent' ? t : Jt(Ye({}, Xt(t), { hue: parseFloat(e) }))
    }
    h(ib, 'setHue')
    const V8 = st(ib)
    function sb(e, t) {
      return t === 'transparent'
        ? t
        : Jt(Ye({}, Xt(t), { lightness: parseFloat(e) }))
    }
    h(sb, 'setLightness')
    const z8 = st(sb)
    function lb(e, t) {
      return t === 'transparent'
        ? t
        : Jt(Ye({}, Xt(t), { saturation: parseFloat(e) }))
    }
    h(lb, 'setSaturation')
    const G8 = st(lb)
    function ub(e, t) {
      return t === 'transparent' ? t : nb(parseFloat(e), 'rgb(0, 0, 0)', t)
    }
    h(ub, 'shade')
    const W8 = st(ub)
    function cb(e, t) {
      return t === 'transparent'
        ? t
        : nb(parseFloat(e), 'rgb(255, 255, 255)', t)
    }
    h(cb, 'tint')
    const Y8 = st(cb)
    function db(e, t) {
      if (t === 'transparent') return t
      const r = Rr(t)
      const n = typeof r.alpha === 'number' ? r.alpha : 1
      const o = Ye({}, r, {
        alpha: Fr(0, 1, +(n * 100 - parseFloat(e) * 100).toFixed(2) / 100),
      })
      return Tt(o)
    }
    h(db, 'transparentize')
    const VC = st(db)
    const de = VC
    const zC = R.div(er, ({ theme: e }) => ({
      backgroundColor:
        e.base === 'light' ? 'rgba(0,0,0,.01)' : 'rgba(255,255,255,.01)',
      borderRadius: e.appBorderRadius,
      border: `1px dashed ${e.appBorderColor}`,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      padding: 20,
      margin: '25px 0 40px',
      color: de(0.3, e.color.defaultText),
      fontSize: e.typography.size.s2,
    }))
    const pb = h(
      e =>
        c.createElement(zC, {
          ...e,
          className: 'docblock-emptyblock sb-unstyled',
        }),
      'EmptyBlock'
    )
    const GC = R(On)(({ theme: e }) => ({
      fontSize: `${e.typography.size.s2 - 1}px`,
      lineHeight: '19px',
      margin: '25px 0 40px',
      borderRadius: e.appBorderRadius,
      boxShadow:
        e.base === 'light'
          ? 'rgba(0, 0, 0, 0.10) 0 1px 3px 0'
          : 'rgba(0, 0, 0, 0.20) 0 2px 5px 0',
      'pre.prismjs': { padding: 20, background: 'inherit' },
    }))
    const WC = R.div(({ theme: e }) => ({
      background: e.background.content,
      borderRadius: e.appBorderRadius,
      border: `1px solid ${e.appBorderColor}`,
      boxShadow:
        e.base === 'light'
          ? 'rgba(0, 0, 0, 0.10) 0 1px 3px 0'
          : 'rgba(0, 0, 0, 0.20) 0 2px 5px 0',
      margin: '25px 0 40px',
      padding: '20px 20px 20px 22px',
    }))
    const Ua = R.div(({ theme: e }) => ({
      animation: `${e.animation.glow} 1.5s ease-in-out infinite`,
      background: e.appBorderColor,
      height: 17,
      marginTop: 1,
      width: '60%',
      [`&:first-child${Qc}`]: { margin: 0 },
    }))
    const YC = h(
      () =>
        c.createElement(
          WC,
          null,
          c.createElement(Ua, null),
          c.createElement(Ua, { style: { width: '80%' } }),
          c.createElement(Ua, { style: { width: '30%' } }),
          c.createElement(Ua, { style: { width: '80%' } })
        ),
      'SourceSkeleton'
    )
    const KC = h(
      ({
        isLoading: e,
        error: t,
        language: r,
        code: n,
        dark: o,
        format: a = !0,
        ...i
      }) => {
        const { typography: s } = Qe()
        if (e) return c.createElement(YC, null)
        if (t) return c.createElement(pb, null, t)
        const l = c.createElement(
          GC,
          {
            bordered: !0,
            copyable: !0,
            format: a,
            language: r ?? 'jsx',
            className: 'docblock-source sb-unstyled',
            ...i,
          },
          n
        )
        if (typeof o > 'u') return l
        const u = o ? Ii.dark : Ii.light
        return c.createElement(
          Jc,
          {
            theme: Zc({ ...u, fontCode: s.fonts.mono, fontBase: s.fonts.base }),
          },
          l
        )
      },
      'Source'
    )
    const Be = h(
      e => `& :where(${e}:not(.sb-anchor, .sb-unstyled, .sb-unstyled ${e}))`,
      'toGlobalSelector'
    )
    const Zu = 600
    const ij = R.h1(er, ({ theme: e }) => ({
      color: e.color.defaultText,
      fontSize: e.typography.size.m3,
      fontWeight: e.typography.weight.bold,
      lineHeight: '32px',
      [`@media (min-width: ${Zu}px)`]: {
        fontSize: e.typography.size.l1,
        lineHeight: '36px',
        marginBottom: '16px',
      },
    }))
    const sj = R.h2(er, ({ theme: e }) => ({
      fontWeight: e.typography.weight.regular,
      fontSize: e.typography.size.s3,
      lineHeight: '20px',
      borderBottom: 'none',
      marginBottom: 15,
      [`@media (min-width: ${Zu}px)`]: {
        fontSize: e.typography.size.m1,
        lineHeight: '28px',
        marginBottom: 24,
      },
      color: de(0.25, e.color.defaultText),
    }))
    const lj = R.div(({ theme: e }) => {
      const t = {
        fontFamily: e.typography.fonts.base,
        fontSize: e.typography.size.s3,
        margin: 0,
        WebkitFontSmoothing: 'antialiased',
        MozOsxFontSmoothing: 'grayscale',
        WebkitTapHighlightColor: 'rgba(0, 0, 0, 0)',
        WebkitOverflowScrolling: 'touch',
      }
      const r = {
        margin: '20px 0 8px',
        padding: 0,
        cursor: 'text',
        position: 'relative',
        color: e.color.defaultText,
        '&:first-of-type': { marginTop: 0, paddingTop: 0 },
        '&:hover a.anchor': { textDecoration: 'none' },
        '& code': { fontSize: 'inherit' },
      }
      const n = {
        lineHeight: 1,
        margin: '0 2px',
        padding: '3px 5px',
        whiteSpace: 'nowrap',
        borderRadius: 3,
        fontSize: e.typography.size.s2 - 1,
        border:
          e.base === 'light'
            ? `1px solid ${e.color.mediumlight}`
            : `1px solid ${e.color.darker}`,
        color:
          e.base === 'light'
            ? de(0.1, e.color.defaultText)
            : de(0.3, e.color.defaultText),
        backgroundColor: e.base === 'light' ? e.color.lighter : e.color.border,
      }
      return {
        maxWidth: 1e3,
        width: '100%',
        minWidth: 0,
        [Be('a')]: {
          ...t,
          fontSize: 'inherit',
          lineHeight: '24px',
          color: e.color.secondary,
          textDecoration: 'none',
          '&.absent': { color: '#cc0000' },
          '&.anchor': {
            display: 'block',
            paddingLeft: 30,
            marginLeft: -30,
            cursor: 'pointer',
            position: 'absolute',
            top: 0,
            left: 0,
            bottom: 0,
          },
        },
        [Be('blockquote')]: {
          ...t,
          margin: '16px 0',
          borderLeft: `4px solid ${e.color.medium}`,
          padding: '0 15px',
          color: e.color.dark,
          '& > :first-of-type': { marginTop: 0 },
          '& > :last-child': { marginBottom: 0 },
        },
        [Be('div')]: t,
        [Be('dl')]: {
          ...t,
          margin: '16px 0',
          padding: 0,
          '& dt': {
            fontSize: '14px',
            fontWeight: 'bold',
            fontStyle: 'italic',
            padding: 0,
            margin: '16px 0 4px',
          },
          '& dt:first-of-type': { padding: 0 },
          '& dt > :first-of-type': { marginTop: 0 },
          '& dt > :last-child': { marginBottom: 0 },
          '& dd': { margin: '0 0 16px', padding: '0 15px' },
          '& dd > :first-of-type': { marginTop: 0 },
          '& dd > :last-child': { marginBottom: 0 },
        },
        [Be('h1')]: {
          ...t,
          ...r,
          fontSize: `${e.typography.size.l1}px`,
          fontWeight: e.typography.weight.bold,
        },
        [Be('h2')]: {
          ...t,
          ...r,
          fontSize: `${e.typography.size.m2}px`,
          paddingBottom: 4,
          borderBottom: `1px solid ${e.appBorderColor}`,
        },
        [Be('h3')]: {
          ...t,
          ...r,
          fontSize: `${e.typography.size.m1}px`,
          fontWeight: e.typography.weight.bold,
        },
        [Be('h4')]: { ...t, ...r, fontSize: `${e.typography.size.s3}px` },
        [Be('h5')]: { ...t, ...r, fontSize: `${e.typography.size.s2}px` },
        [Be('h6')]: {
          ...t,
          ...r,
          fontSize: `${e.typography.size.s2}px`,
          color: e.color.dark,
        },
        [Be('hr')]: {
          border: '0 none',
          borderTop: `1px solid ${e.appBorderColor}`,
          height: 4,
          padding: 0,
        },
        [Be('img')]: { maxWidth: '100%' },
        [Be('li')]: {
          ...t,
          fontSize: e.typography.size.s2,
          color: e.color.defaultText,
          lineHeight: '24px',
          '& + li': { marginTop: '.25em' },
          '& ul, & ol': { marginTop: '.25em', marginBottom: 0 },
          '& code': n,
        },
        [Be('ol')]: {
          ...t,
          margin: '16px 0',
          paddingLeft: 30,
          '& :first-of-type': { marginTop: 0 },
          '& :last-child': { marginBottom: 0 },
        },
        [Be('p')]: {
          ...t,
          margin: '16px 0',
          fontSize: e.typography.size.s2,
          lineHeight: '24px',
          color: e.color.defaultText,
          '& code': n,
        },
        [Be('pre')]: {
          ...t,
          fontFamily: e.typography.fonts.mono,
          WebkitFontSmoothing: 'antialiased',
          MozOsxFontSmoothing: 'grayscale',
          lineHeight: '18px',
          padding: '11px 1rem',
          whiteSpace: 'pre-wrap',
          color: 'inherit',
          borderRadius: 3,
          margin: '1rem 0',
          '&:not(.prismjs)': {
            background: 'transparent',
            border: 'none',
            borderRadius: 0,
            padding: 0,
            margin: 0,
          },
          '& pre, &.prismjs': {
            padding: 15,
            margin: 0,
            whiteSpace: 'pre-wrap',
            color: 'inherit',
            fontSize: '13px',
            lineHeight: '19px',
            code: { color: 'inherit', fontSize: 'inherit' },
          },
          '& code': { whiteSpace: 'pre' },
          '& code, & tt': { border: 'none' },
        },
        [Be('span')]: {
          ...t,
          '&.frame': {
            display: 'block',
            overflow: 'hidden',
            '& > span': {
              border: `1px solid ${e.color.medium}`,
              display: 'block',
              float: 'left',
              overflow: 'hidden',
              margin: '13px 0 0',
              padding: 7,
              width: 'auto',
            },
            '& span img': { display: 'block', float: 'left' },
            '& span span': {
              clear: 'both',
              color: e.color.darkest,
              display: 'block',
              padding: '5px 0 0',
            },
          },
          '&.align-center': {
            display: 'block',
            overflow: 'hidden',
            clear: 'both',
            '& > span': {
              display: 'block',
              overflow: 'hidden',
              margin: '13px auto 0',
              textAlign: 'center',
            },
            '& span img': { margin: '0 auto', textAlign: 'center' },
          },
          '&.align-right': {
            display: 'block',
            overflow: 'hidden',
            clear: 'both',
            '& > span': {
              display: 'block',
              overflow: 'hidden',
              margin: '13px 0 0',
              textAlign: 'right',
            },
            '& span img': { margin: 0, textAlign: 'right' },
          },
          '&.float-left': {
            display: 'block',
            marginRight: 13,
            overflow: 'hidden',
            float: 'left',
            '& span': { margin: '13px 0 0' },
          },
          '&.float-right': {
            display: 'block',
            marginLeft: 13,
            overflow: 'hidden',
            float: 'right',
            '& > span': {
              display: 'block',
              overflow: 'hidden',
              margin: '13px auto 0',
              textAlign: 'right',
            },
          },
        },
        [Be('table')]: {
          ...t,
          margin: '16px 0',
          fontSize: e.typography.size.s2,
          lineHeight: '24px',
          padding: 0,
          borderCollapse: 'collapse',
          '& tr': {
            borderTop: `1px solid ${e.appBorderColor}`,
            backgroundColor: e.appContentBg,
            margin: 0,
            padding: 0,
          },
          '& tr:nth-of-type(2n)': {
            backgroundColor:
              e.base === 'dark' ? e.color.darker : e.color.lighter,
          },
          '& tr th': {
            fontWeight: 'bold',
            color: e.color.defaultText,
            border: `1px solid ${e.appBorderColor}`,
            margin: 0,
            padding: '6px 13px',
          },
          '& tr td': {
            border: `1px solid ${e.appBorderColor}`,
            color: e.color.defaultText,
            margin: 0,
            padding: '6px 13px',
          },
          '& tr th :first-of-type, & tr td :first-of-type': { marginTop: 0 },
          '& tr th :last-child, & tr td :last-child': { marginBottom: 0 },
        },
        [Be('ul')]: {
          ...t,
          margin: '16px 0',
          paddingLeft: 30,
          '& :first-of-type': { marginTop: 0 },
          '& :last-child': { marginBottom: 0 },
          listStyle: 'disc',
        },
      }
    })
    const uj = R.div(({ theme: e }) => ({
      background: e.background.content,
      display: 'flex',
      flexDirection: 'row-reverse',
      justifyContent: 'center',
      padding: '4rem 20px',
      minHeight: '100vh',
      boxSizing: 'border-box',
      gap: '3rem',
      [`@media (min-width: ${Zu}px)`]: {},
    }))
    const mi = h(
      e => ({
        borderRadius: e.appBorderRadius,
        background: e.background.content,
        boxShadow:
          e.base === 'light'
            ? 'rgba(0, 0, 0, 0.10) 0 1px 3px 0'
            : 'rgba(0, 0, 0, 0.20) 0 2px 5px 0',
        border: `1px solid ${e.appBorderColor}`,
      }),
      'getBlockBackgroundStyle'
    )
    const { window: Dj } = globalThis
    const XC = Lr({ scale: 1 })
    const { PREVIEW_URL: kj } = globalThis
    const Oj = R.strong(({ theme: e }) => ({ color: e.color.orange }))
    const JC = R(Ai)({
      position: 'absolute',
      left: 0,
      right: 0,
      top: 0,
      transition: 'transform .2s linear',
    })
    const ZC = R.div({ display: 'flex', alignItems: 'center', gap: 4 })
    const QC = R.div(({ theme: e }) => ({
      width: 14,
      height: 14,
      borderRadius: 2,
      margin: '0 7px',
      backgroundColor: e.appBorderColor,
      animation: `${e.animation.glow} 1.5s ease-in-out infinite`,
    }))
    const e5 = h(
      ({ isLoading: e, storyId: t, baseUrl: r, zoom: n, resetZoom: o, ...a }) =>
        c.createElement(
          JC,
          { ...a },
          c.createElement(
            ZC,
            { key: 'left' },
            e
              ? [1, 2, 3].map(i => c.createElement(QC, { key: i }))
              : c.createElement(
                  c.Fragment,
                  null,
                  c.createElement(
                    ce,
                    {
                      key: 'zoomin',
                      onClick: i => {
                        ;(i.preventDefault(), n(0.8))
                      },
                      title: 'Zoom in',
                    },
                    c.createElement(Wc, null)
                  ),
                  c.createElement(
                    ce,
                    {
                      key: 'zoomout',
                      onClick: i => {
                        ;(i.preventDefault(), n(1.25))
                      },
                      title: 'Zoom out',
                    },
                    c.createElement(Yc, null)
                  ),
                  c.createElement(
                    ce,
                    {
                      key: 'zoomreset',
                      onClick: i => {
                        ;(i.preventDefault(), o())
                      },
                      title: 'Reset zoom',
                    },
                    c.createElement(Kc, null)
                  )
                )
          )
        ),
      'Toolbar'
    )
    const t5 = R.div(
      ({ isColumn: e, columns: t, layout: r }) => ({
        display: e || !t ? 'block' : 'flex',
        position: 'relative',
        flexWrap: 'wrap',
        overflow: 'auto',
        flexDirection: e ? 'column' : 'row',
        '& .innerZoomElementWrapper > *': e
          ? {
              width: r !== 'fullscreen' ? 'calc(100% - 20px)' : '100%',
              display: 'block',
            }
          : {
              maxWidth: r !== 'fullscreen' ? 'calc(100% - 20px)' : '100%',
              display: 'inline-block',
            },
      }),
      ({ layout: e = 'padded', inline: t }) =>
        e === 'centered' || e === 'padded'
          ? {
              padding: t ? '32px 22px' : '0px',
              '& .innerZoomElementWrapper > *': {
                width: 'auto',
                border: '8px solid transparent!important',
              },
            }
          : {},
      ({ layout: e = 'padded', inline: t }) =>
        e === 'centered' && t
          ? {
              display: 'flex',
              justifyContent: 'center',
              justifyItems: 'center',
              alignContent: 'center',
              alignItems: 'center',
            }
          : {},
      ({ columns: e }) =>
        e && e > 1
          ? {
              '.innerZoomElementWrapper > *': {
                minWidth: `calc(100% / ${e} - 20px)`,
              },
            }
          : {}
    )
    const a0 = R(KC)(({ theme: e }) => ({
      margin: 0,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0,
      borderBottomLeftRadius: e.appBorderRadius,
      borderBottomRightRadius: e.appBorderRadius,
      border: 'none',
      background:
        e.base === 'light'
          ? 'rgba(0, 0, 0, 0.85)'
          : Nt(0.05, e.background.content),
      color: e.color.lightest,
      button: {
        background:
          e.base === 'light'
            ? 'rgba(0, 0, 0, 0.85)'
            : Nt(0.05, e.background.content),
      },
    }))
    const r5 = R.div(
      ({ theme: e, withSource: t, isExpanded: r }) => ({
        position: 'relative',
        overflow: 'hidden',
        margin: '25px 0 40px',
        ...mi(e),
        borderBottomLeftRadius: t && r && 0,
        borderBottomRightRadius: t && r && 0,
        borderBottomWidth: r && 0,
        'h3 + &': { marginTop: '16px' },
      }),
      ({ withToolbar: e }) => e && { paddingTop: 40 }
    )
    const n5 = h((e, t, r) => {
      switch (!0) {
        case !!(e && e.error):
          return {
            source: null,
            actionItem: {
              title: 'No code available',
              className: 'docblock-code-toggle docblock-code-toggle--disabled',
              disabled: !0,
              onClick: h(() => r(!1), 'onClick'),
            },
          }
        case t:
          return {
            source: c.createElement(a0, { ...e, dark: !0 }),
            actionItem: {
              title: 'Hide code',
              className: 'docblock-code-toggle docblock-code-toggle--expanded',
              onClick: h(() => r(!1), 'onClick'),
            },
          }
        default:
          return {
            source: c.createElement(a0, { ...e, dark: !0 }),
            actionItem: {
              title: 'Show code',
              className: 'docblock-code-toggle',
              onClick: h(() => r(!0), 'onClick'),
            },
          }
      }
    }, 'getSource')
    function mb(e) {
      if (po.count(e) === 1) {
        const t = e
        if (t.props) return t.props.id
      }
      return null
    }
    h(mb, 'getStoryId')
    const o5 = R(e5)({
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      height: 40,
    })
    const a5 = R.div({ overflow: 'hidden', position: 'relative' })
    const i5 = h(
      ({
        isLoading: e,
        isColumn: t,
        columns: r,
        children: n,
        withSource: o,
        withToolbar: a = !1,
        isExpanded: i = !1,
        additionalActions: s,
        className: l,
        layout: u = 'padded',
        inline: d = !1,
        ...m
      }) => {
        const [p, f] = z(i)
        const { source: g, actionItem: y } = n5(o, p, f)
        const [E, b] = z(1)
        const x = [l].concat(['sbdocs', 'sbdocs-preview', 'sb-unstyled'])
        const S = o ? [y] : []
        const [T, _] = z(s ? [...s] : [])
        const O = [...S, ...T]
        const { window: k } = globalThis
        const B = Q(async L => {
          const { createCopyToClipboardFunction: j } =
            await Promise.resolve().then(() => (J(), xc))
          j()
        }, [])
        const P = h(L => {
          const j = k.getSelection()
          ;(j && j.type === 'Range') ||
            (L.preventDefault(),
            T.filter(U => U.title === 'Copied').length === 0 &&
              B(g?.props.code ?? '').then(() => {
                ;(_([
                  ...T,
                  { title: 'Copied', onClick: h(() => {}, 'onClick') },
                ]),
                  k.setTimeout(
                    () => _(T.filter(U => U.title !== 'Copied')),
                    1500
                  ))
              }))
        }, 'onCopyCapture')
        return c.createElement(
          r5,
          { withSource: o, withToolbar: a, ...m, className: x.join(' ') },
          a &&
            c.createElement(o5, {
              isLoading: e,
              border: !0,
              zoom: L => b(E * L),
              resetZoom: () => b(1),
              storyId: mb(n),
              baseUrl: './iframe.html',
            }),
          c.createElement(
            XC.Provider,
            { value: { scale: E } },
            c.createElement(
              a5,
              { className: 'docs-story', onCopyCapture: o && P },
              c.createElement(
                t5,
                {
                  isColumn: t || !Array.isArray(n),
                  columns: r,
                  layout: u,
                  inline: d,
                },
                c.createElement(
                  Ti.Element,
                  { centered: u === 'centered', scale: d ? E : 1 },
                  Array.isArray(n)
                    ? n.map((L, j) => c.createElement('div', { key: j }, L))
                    : c.createElement('div', null, n)
                )
              ),
              c.createElement(Cn, { actionItems: O })
            )
          ),
          o && p && g
        )
      },
      'Preview'
    )
    const Fj = R(i5)(() => ({
      '.docs-story': { paddingTop: 32, paddingBottom: 40 },
    }))
    const Hj = R.div(({ theme: e }) => ({
      marginRight: 30,
      fontSize: `${e.typography.size.s1}px`,
      color:
        e.base === 'light'
          ? de(0.4, e.color.defaultText)
          : de(0.6, e.color.defaultText),
    }))
    const Vj = R.div({
      overflow: 'hidden',
      whiteSpace: 'nowrap',
      textOverflow: 'ellipsis',
    })
    const zj = R.div({
      display: 'flex',
      flexDirection: 'row',
      alignItems: 'baseline',
      '&:not(:last-child)': { marginBottom: '1rem' },
    })
    const Gj = R.div(er, ({ theme: e }) => ({
      ...mi(e),
      margin: '25px 0 40px',
      padding: '30px 20px',
    }))
    const Zj = R.div(({ theme: e }) => ({
      fontWeight: e.typography.weight.bold,
      color: e.color.defaultText,
    }))
    const Qj = R.div(({ theme: e }) => ({
      color:
        e.base === 'light'
          ? de(0.2, e.color.defaultText)
          : de(0.6, e.color.defaultText),
    }))
    const eM = R.div({ flex: '0 0 30%', lineHeight: '20px', marginTop: 5 })
    const tM = R.div(({ theme: e }) => ({
      flex: 1,
      textAlign: 'center',
      fontFamily: e.typography.fonts.mono,
      fontSize: e.typography.size.s1,
      lineHeight: 1,
      overflow: 'hidden',
      color:
        e.base === 'light'
          ? de(0.4, e.color.defaultText)
          : de(0.6, e.color.defaultText),
      '> div': {
        display: 'inline-block',
        overflow: 'hidden',
        maxWidth: '100%',
        textOverflow: 'ellipsis',
      },
      span: { display: 'block', marginTop: 2 },
    }))
    const rM = R.div({ display: 'flex', flexDirection: 'row' })
    const nM = R.div(({ background: e }) => ({
      position: 'relative',
      flex: 1,
      '&::before': {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        background: e,
        content: '""',
      },
    }))
    const oM = R.div(({ theme: e }) => ({
      ...mi(e),
      display: 'flex',
      flexDirection: 'row',
      height: 50,
      marginBottom: 5,
      overflow: 'hidden',
      backgroundColor: 'white',
      backgroundImage:
        'repeating-linear-gradient(-45deg, #ccc, #ccc 1px, #fff 1px, #fff 16px)',
      backgroundClip: 'padding-box',
    }))
    const aM = R.div({
      display: 'flex',
      flexDirection: 'column',
      flex: 1,
      position: 'relative',
      marginBottom: 30,
    })
    const iM = R.div({ flex: 1, display: 'flex', flexDirection: 'row' })
    const sM = R.div({ display: 'flex', alignItems: 'flex-start' })
    const lM = R.div({ flex: '0 0 30%' })
    const uM = R.div({ flex: 1 })
    const cM = R.div(({ theme: e }) => ({
      display: 'flex',
      flexDirection: 'row',
      alignItems: 'center',
      paddingBottom: 20,
      fontWeight: e.typography.weight.bold,
      color:
        e.base === 'light'
          ? de(0.4, e.color.defaultText)
          : de(0.6, e.color.defaultText),
    }))
    const dM = R.div(({ theme: e }) => ({
      fontSize: e.typography.size.s2,
      lineHeight: '20px',
      display: 'flex',
      flexDirection: 'column',
    }))
    const yM = R.div(({ theme: e }) => ({
      fontFamily: e.typography.fonts.base,
      fontSize: e.typography.size.s1,
      color: e.color.defaultText,
      marginLeft: 10,
      lineHeight: 1.2,
      display: '-webkit-box',
      overflow: 'hidden',
      wordBreak: 'break-word',
      textOverflow: 'ellipsis',
      WebkitLineClamp: 2,
      WebkitBoxOrient: 'vertical',
    }))
    const bM = R.div(({ theme: e }) => ({
      ...mi(e),
      overflow: 'hidden',
      height: 40,
      width: 40,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      flex: 'none',
      '> img, > svg': { width: 20, height: 20 },
    }))
    const EM = R.div({
      display: 'inline-flex',
      flexDirection: 'row',
      alignItems: 'center',
      width: '100%',
    })
    const vM = R.div({
      display: 'grid',
      gridTemplateColumns: 'repeat(auto-fill, minmax(140px, 1fr))',
      gridGap: '8px 16px',
      gridAutoFlow: 'row dense',
      gridAutoRows: 50,
    })
    const kM = R.aside(() => ({
      width: '10rem',
      '@media (max-width: 768px)': { display: 'none' },
    }))
    const OM = R.nav(({ theme: e }) => ({
      position: 'fixed',
      bottom: 0,
      top: 0,
      width: '10rem',
      paddingTop: '4rem',
      paddingBottom: '2rem',
      overflowY: 'auto',
      fontFamily: e.typography.fonts.base,
      fontSize: e.typography.size.s2,
      WebkitFontSmoothing: 'antialiased',
      MozOsxFontSmoothing: 'grayscale',
      WebkitTapHighlightColor: 'rgba(0, 0, 0, 0)',
      WebkitOverflowScrolling: 'touch',
      '& *': { boxSizing: 'border-box' },
      '& > .toc-wrapper > .toc-list': {
        paddingLeft: 0,
        borderLeft: `solid 2px ${e.color.mediumlight}`,
        '.toc-list': {
          paddingLeft: 0,
          borderLeft: `solid 2px ${e.color.mediumlight}`,
          '.toc-list': {
            paddingLeft: 0,
            borderLeft: `solid 2px ${e.color.mediumlight}`,
          },
        },
      },
      '& .toc-list-item': {
        position: 'relative',
        listStyleType: 'none',
        marginLeft: 20,
        paddingTop: 3,
        paddingBottom: 3,
      },
      '& .toc-list-item::before': {
        content: '""',
        position: 'absolute',
        height: '100%',
        top: 0,
        left: 0,
        transform: 'translateX(calc(-2px - 20px))',
        borderLeft: `solid 2px ${e.color.mediumdark}`,
        opacity: 0,
        transition: 'opacity 0.2s',
      },
      '& .toc-list-item.is-active-li::before': { opacity: 1 },
      '& .toc-list-item > a': {
        color: e.color.defaultText,
        textDecoration: 'none',
      },
      '& .toc-list-item.is-active-li > a': {
        fontWeight: 600,
        color: e.color.secondary,
        textDecoration: 'none',
      },
    }))
    const IM = R.p(({ theme: e }) => ({
      fontWeight: 600,
      fontSize: '0.875em',
      color: e.textColor,
      textTransform: 'uppercase',
      marginBottom: 10,
    }))
    function mr() {
      return (
        (mr = Object.assign
          ? Object.assign.bind()
          : function (e) {
              for (let t = 1; t < arguments.length; t++) {
                const r = arguments[t]
                for (const n in r)
                  Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
              }
              return e
            }),
        mr.apply(this, arguments)
      )
    }
    h(mr, 't')
    const s5 = ['children', 'options']
    const K = {
      blockQuote: '0',
      breakLine: '1',
      breakThematic: '2',
      codeBlock: '3',
      codeFenced: '4',
      codeInline: '5',
      footnote: '6',
      footnoteReference: '7',
      gfmTask: '8',
      heading: '9',
      headingSetext: '10',
      htmlBlock: '11',
      htmlComment: '12',
      htmlSelfClosing: '13',
      image: '14',
      link: '15',
      linkAngleBraceStyleDetector: '16',
      linkBareUrlDetector: '17',
      linkMailtoDetector: '18',
      newlineCoalescer: '19',
      orderedList: '20',
      paragraph: '21',
      ref: '22',
      refImage: '23',
      refLink: '24',
      table: '25',
      tableSeparator: '26',
      text: '27',
      textBolded: '28',
      textEmphasized: '29',
      textEscaped: '30',
      textMarked: '31',
      textStrikethroughed: '32',
      unorderedList: '33',
    }
    let i0
    ;(function (e) {
      ;((e[(e.MAX = 0)] = 'MAX'),
        (e[(e.HIGH = 1)] = 'HIGH'),
        (e[(e.MED = 2)] = 'MED'),
        (e[(e.LOW = 3)] = 'LOW'),
        (e[(e.MIN = 4)] = 'MIN'))
    })(i0 || (i0 = {}))
    const s0 = [
      'allowFullScreen',
      'allowTransparency',
      'autoComplete',
      'autoFocus',
      'autoPlay',
      'cellPadding',
      'cellSpacing',
      'charSet',
      'classId',
      'colSpan',
      'contentEditable',
      'contextMenu',
      'crossOrigin',
      'encType',
      'formAction',
      'formEncType',
      'formMethod',
      'formNoValidate',
      'formTarget',
      'frameBorder',
      'hrefLang',
      'inputMode',
      'keyParams',
      'keyType',
      'marginHeight',
      'marginWidth',
      'maxLength',
      'mediaGroup',
      'minLength',
      'noValidate',
      'radioGroup',
      'readOnly',
      'rowSpan',
      'spellCheck',
      'srcDoc',
      'srcLang',
      'srcSet',
      'tabIndex',
      'useMap',
    ].reduce((e, t) => ((e[t.toLowerCase()] = t), e), {
      class: 'className',
      for: 'htmlFor',
    })
    const l0 = {
      amp: '&',
      apos: "'",
      gt: '>',
      lt: '<',
      nbsp: '\xA0',
      quot: '\u201C',
    }
    const l5 = ['style', 'script']
    const u5 = ['src', 'href', 'data', 'formAction', 'srcDoc', 'action']
    const c5 =
      /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi
    const d5 = /mailto:/i
    const p5 = /\n{2,}$/
    const hb = /^(\s*>[\s\S]*?)(?=\n\n|$)/
    const m5 = /^ *> ?/gm
    const h5 = /^(?:\[!([^\]]*)\]\n)?([\s\S]*)/
    const f5 = /^ {2,}\n/
    const g5 = /^(?:( *[-*_])){3,} *(?:\n *)+\n/
    const fb =
      /^(?: {1,3})?(`{3,}|~{3,}) *(\S+)? *([^\n]*?)?\n([\s\S]*?)(?:\1\n?|$)/
    const gb = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/
    const y5 = /^(`+)((?:\\`|(?!\1)`|[^`])+)\1/
    const b5 = /^(?:\n *)*\n/
    const E5 = /\r\n?/g
    const v5 = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/
    const A5 = /^\[\^([^\]]+)]/
    const x5 = /\f/g
    const w5 = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/
    const S5 = /^\s*?\[(x|\s)\]/
    const yb = /^ *(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/
    const bb = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/
    const Eb = /^([^\n]+)\n *(=|-){3,} *(?:\n *)+\n/
    const xu =
      /^ *(?!<[a-z][^ >/]* ?\/>)<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>\n?(\s*(?:<\1[^>]*?>[\s\S]*?<\/\1>|(?!<\1\b)[\s\S])*?)<\/\1>(?!<\/\1>)\n*/i
    const C5 = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi
    const vb = /^<!--[\s\S]*?(?:-->)/
    const D5 = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/
    const wu =
      /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i
    const T5 = /^\{.*\}$/
    const k5 = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/
    const O5 = /^<([^ >]+@[^ >]+)>/
    const I5 = /^<([^ >]+:\/[^ >]+)>/
    const R5 = /-([a-z])?/gi
    const Ab = /^(\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/
    const B5 = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/
    const _5 = /^!\[([^\]]*)\] ?\[([^\]]*)\]/
    const F5 = /^\[([^\]]*)\] ?\[([^\]]*)\]/
    const P5 = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/
    const N5 = /\t/g
    const L5 = /(^ *\||\| *$)/g
    const j5 = /^ *:-+: *$/
    const M5 = /^ *:-+ *$/
    const $5 = /^ *-+: *$/
    const hi =
      '((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|\\\\\\1|[\\s\\S])+?)'
    const q5 = new RegExp(`^([*_])\\1${hi}\\1\\1(?!\\1)`)
    const U5 = new RegExp(`^([*_])${hi}\\1(?!\\1)`)
    const H5 = new RegExp(`^(==)${hi}\\1`)
    const V5 = new RegExp(`^(~~)${hi}\\1`)
    const z5 = /^\\([^0-9A-Za-z\s])/
    const u0 = /\\([^0-9A-Za-z\s])/g
    const G5 = /^([\s\S](?:(?! {2}|[0-9]\.)[^=*_~\-\n<`\\\[!])*)/
    const W5 = /^\n+/
    const Y5 = /^([ \t]*)/
    const K5 = /\\([^\\])/g
    const X5 = /(?:^|\n)( *)$/
    const Qu = '(?:\\d+\\.)'
    const ec = '(?:[*+-])'
    function tc(e) {
      return '( *)(' + (e === 1 ? Qu : ec) + ') +'
    }
    h(tc, 'de')
    const xb = tc(1)
    const wb = tc(2)
    function rc(e) {
      return new RegExp('^' + (e === 1 ? xb : wb))
    }
    h(rc, 'fe')
    const J5 = rc(1)
    const Z5 = rc(2)
    function nc(e) {
      return new RegExp(
        '^' +
          (e === 1 ? xb : wb) +
          '[^\\n]*(?:\\n(?!\\1' +
          (e === 1 ? Qu : ec) +
          ' )[^\\n]*)*(\\n|$)',
        'gm'
      )
    }
    h(nc, 'ge')
    const Q5 = nc(1)
    const eD = nc(2)
    function oc(e) {
      const t = e === 1 ? Qu : ec
      return new RegExp(
        '^( *)(' +
          t +
          ') [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1' +
          t +
          ' (?!' +
          t +
          ' ))\\n*|\\s*\\n*$)'
      )
    }
    h(oc, 'xe')
    const Sb = oc(1)
    const Cb = oc(2)
    function Su(e, t) {
      const r = t === 1
      const n = r ? Sb : Cb
      const o = r ? Q5 : eD
      const a = r ? J5 : Z5
      return {
        match: Br(function (i, s) {
          const l = X5.exec(s.prevCapture)
          return l && (s.list || (!s.inline && !s.simple))
            ? n.exec((i = l[1] + i))
            : null
        }),
        order: 1,
        parse(i, s, l) {
          const u = r ? +i[2] : void 0
          const d = i[0]
            .replace(
              p5,
              `
`
            )
            .match(o)
          let m = !1
          return {
            items: d.map(function (p, f) {
              const g = a.exec(p)[0].length
              const y = new RegExp('^ {1,' + g + '}', 'gm')
              const E = p.replace(y, '').replace(a, '')
              const b = f === d.length - 1
              const x =
                E.includes(`

`) ||
                (b && m)
              m = x
              const S = l.inline
              const T = l.list
              let _
              ;((l.list = !0),
                x
                  ? ((l.inline = !1),
                    (_ =
                      wn(E) +
                      `

`))
                  : ((l.inline = !0), (_ = wn(E))))
              const O = s(_, l)
              return ((l.inline = S), (l.list = T), O)
            }),
            ordered: r,
            start: u,
          }
        },
        render: h(
          (i, s, l) =>
            e(
              i.ordered ? 'ol' : 'ul',
              {
                key: l.key,
                start: i.type === K.orderedList ? i.start : void 0,
              },
              i.items.map(function (u, d) {
                return e('li', { key: d }, s(u, l))
              })
            ),
          'render'
        ),
      }
    }
    h(Su, 'Ce')
    const tD = new RegExp(
      `^\\[((?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`
    )
    const rD = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/
    const Db = [hb, fb, gb, yb, Eb, bb, Ab, Sb, Cb]
    const nD = [...Db, /^[^\n]+(?: {2}\n|\n{2,})/, xu, vb, wu]
    function wn(e) {
      let t = e.length
      for (; t > 0 && e[t - 1] <= ' '; ) t--
      return e.slice(0, t)
    }
    h(wn, 'ze')
    function yn(e) {
      return e
        .replace(/[Ã€ÃÃ‚ÃƒÃ„Ã…Ã Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã†]/g, 'a')
        .replace(/[Ã§Ã‡]/g, 'c')
        .replace(/[Ã°Ã]/g, 'd')
        .replace(/[ÃˆÃ‰ÃŠÃ‹Ã©Ã¨ÃªÃ«]/g, 'e')
        .replace(/[ÃÃ¯ÃŽÃ®ÃÃ­ÃŒÃ¬]/g, 'i')
        .replace(/[Ã‘Ã±]/g, 'n')
        .replace(/[Ã¸Ã˜Å“Å’Ã•ÃµÃ”Ã´Ã“Ã³Ã’Ã²]/g, 'o')
        .replace(/[ÃœÃ¼Ã›Ã»ÃšÃºÃ™Ã¹]/g, 'u')
        .replace(/[Å¸Ã¿ÃÃ½]/g, 'y')
        .replace(/[^a-z0-9- ]/gi, '')
        .replace(/ /gi, '-')
        .toLowerCase()
    }
    h(yn, 'Le')
    function Tb(e) {
      return $5.test(e)
        ? 'right'
        : j5.test(e)
          ? 'center'
          : M5.test(e)
            ? 'left'
            : null
    }
    h(Tb, 'Ae')
    function Cu(e, t, r, n) {
      const o = r.inTable
      r.inTable = !0
      const a = [[]]
      let i = ''
      function s() {
        if (!i) return
        const l = a[a.length - 1]
        ;(l.push.apply(l, t(i, r)), (i = ''))
      }
      return (
        h(s, 'a'),
        e
          .trim()
          .split(/(`[^`]*`|\\\||\|)/)
          .filter(Boolean)
          .forEach((l, u, d) => {
            l.trim() === '|' && (s(), n)
              ? u !== 0 && u !== d.length - 1 && a.push([])
              : (i += l)
          }),
        s(),
        (r.inTable = o),
        a
      )
    }
    h(Cu, 'Oe')
    function kb(e, t, r) {
      r.inline = !0
      const n = e[2] ? e[2].replace(L5, '').split('|').map(Tb) : []
      const o = e[3]
        ? (function (i, s, l) {
            return i
              .trim()
              .split(
                `
`
              )
              .map(function (u) {
                return Cu(u, s, l, !0)
              })
          })(e[3], t, r)
        : []
      const a = Cu(e[1], t, r, !!o.length)
      return (
        (r.inline = !1),
        o.length
          ? { align: n, cells: o, header: a, type: K.table }
          : { children: a, type: K.paragraph }
      )
    }
    h(kb, 'Te')
    function Du(e, t) {
      return e.align[t] == null ? {} : { textAlign: e.align[t] }
    }
    h(Du, 'Be')
    function Br(e) {
      return ((e.inline = 1), e)
    }
    h(Br, 'Me')
    function Yt(e) {
      return Br(function (t, r) {
        return r.inline ? e.exec(t) : null
      })
    }
    h(Yt, 'Re')
    function Kt(e) {
      return Br(function (t, r) {
        return r.inline || r.simple ? e.exec(t) : null
      })
    }
    h(Kt, 'Ie')
    function Ft(e) {
      return function (t, r) {
        return r.inline || r.simple ? null : e.exec(t)
      }
    }
    h(Ft, 'De')
    function bn(e) {
      return Br(function (t) {
        return e.exec(t)
      })
    }
    h(bn, 'Ue')
    function Ob(e, t) {
      if (t.inline || t.simple) return null
      let r = ''
      e.split(
        `
`
      ).every(
        o => (
          (o += `
`),
          !Db.some(a => a.test(o)) && ((r += o), !!o.trim())
        )
      )
      const n = wn(r)
      return n == '' ? null : [r, , n]
    }
    h(Ob, 'Ne')
    const oD = /(javascript|vbscript|data(?!:image)):/i
    function Ib(e) {
      try {
        const t = decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g, '')
        if (oD.test(t)) return null
      } catch {
        return null
      }
      return e
    }
    h(Ib, 'He')
    function Tu(e) {
      return e.replace(K5, '$1')
    }
    h(Tu, 'Pe')
    function eo(e, t, r) {
      const n = r.inline || !1
      const o = r.simple || !1
      ;((r.inline = !0), (r.simple = !0))
      const a = e(t, r)
      return ((r.inline = n), (r.simple = o), a)
    }
    h(eo, '_e')
    function Rb(e, t, r) {
      const n = r.inline || !1
      const o = r.simple || !1
      ;((r.inline = !1), (r.simple = !0))
      const a = e(t, r)
      return ((r.inline = n), (r.simple = o), a)
    }
    h(Rb, 'Fe')
    function Bb(e, t, r) {
      const n = r.inline || !1
      r.inline = !1
      const o = e(t, r)
      return ((r.inline = n), o)
    }
    h(Bb, 'We')
    const nu = h((e, t, r) => ({ children: eo(t, e[2], r) }), 'Ge')
    function Xa() {
      return {}
    }
    h(Xa, 'Ze')
    function Ja() {
      return null
    }
    h(Ja, 'qe')
    function _b(...e) {
      return e.filter(Boolean).join(' ')
    }
    h(_b, 'Qe')
    function Za(e, t, r) {
      let n = e
      const o = t.split('.')
      for (; o.length && ((n = n[o[0]]), n !== void 0); ) o.shift()
      return n || r
    }
    h(Za, 'Ve')
    function Fb(e = '', t = {}) {
      function r(p, f, ...g) {
        const y = Za(t.overrides, `${p}.props`, {})
        return t.createElement(
          (function (E, b) {
            const x = Za(b, E)
            return x
              ? typeof x === 'function' ||
                (typeof x === 'object' && 'render' in x)
                ? x
                : Za(b, `${E}.component`, E)
              : E
          })(p, t.overrides),
          mr({}, f, y, { className: _b(f?.className, y.className) || void 0 }),
          ...g
        )
      }
      h(r, 'u')
      function n(p) {
        p = p.replace(w5, '')
        let f = !1
        t.forceInline ? (f = !0) : t.forceBlock || (f = P5.test(p) === !1)
        const g = u(
          l(
            f
              ? p
              : `${wn(p).replace(W5, '')}

`,
            { inline: f }
          )
        )
        for (; typeof g[g.length - 1] === 'string' && !g[g.length - 1].trim(); )
          g.pop()
        if (t.wrapper === null) return g
        const y = t.wrapper || (f ? 'span' : 'div')
        let E
        if (g.length > 1 || t.forceWrapper) E = g
        else {
          if (g.length === 1)
            return (
              (E = g[0]),
              typeof E === 'string' ? r('span', { key: 'outer' }, E) : E
            )
          E = null
        }
        return t.createElement(y, { key: 'outer' }, E)
      }
      h(n, 'Z')
      function o(p, f) {
        const g = f.match(c5)
        return g
          ? g.reduce(function (y, E) {
              const b = E.indexOf('=')
              if (b !== -1) {
                const x = (function (O) {
                  return (
                    O.includes('-') &&
                      O.match(D5) === null &&
                      (O = O.replace(R5, function (k, B) {
                        return B.toUpperCase()
                      })),
                    O
                  )
                })(E.slice(0, b)).trim()
                const S = (function (O) {
                  const k = O[0]
                  return (k === '"' || k === "'") &&
                    O.length >= 2 &&
                    O[O.length - 1] === k
                    ? O.slice(1, -1)
                    : O
                })(E.slice(b + 1).trim())
                const T = s0[x] || x
                if (T === 'ref') return y
                const _ = (y[T] = (function (O, k, B, P) {
                  return k === 'style'
                    ? (function (L) {
                        const j = []
                        let U = ''
                        let $ = !1
                        let v = !1
                        let A = ''
                        if (!L) return j
                        for (let N = 0; N < L.length; N++) {
                          const F = L[N]
                          if (
                            ((F !== '"' && F !== "'") ||
                              $ ||
                              (v
                                ? F === A && ((v = !1), (A = ''))
                                : ((v = !0), (A = F))),
                            F === '(' && U.endsWith('url')
                              ? ($ = !0)
                              : F === ')' && $ && ($ = !1),
                            F !== ';' || v || $)
                          )
                            U += F
                          else {
                            const M = U.trim()
                            if (M) {
                              const q = M.indexOf(':')
                              if (q > 0) {
                                const V = M.slice(0, q).trim()
                                const G = M.slice(q + 1).trim()
                                j.push([V, G])
                              }
                            }
                            U = ''
                          }
                        }
                        const D = U.trim()
                        if (D) {
                          const N = D.indexOf(':')
                          if (N > 0) {
                            const F = D.slice(0, N).trim()
                            const M = D.slice(N + 1).trim()
                            j.push([F, M])
                          }
                        }
                        return j
                      })(B).reduce(function (L, [j, U]) {
                        return (
                          (L[j.replace(/(-[a-z])/g, $ => $[1].toUpperCase())] =
                            P(U, O, j)),
                          L
                        )
                      }, {})
                    : u5.includes(k)
                      ? P(B, O, k)
                      : (B.match(T5) && (B = B.slice(1, B.length - 1)),
                        B === 'true' || (B !== 'false' && B))
                })(p, x, S, t.sanitizer))
                typeof _ === 'string' &&
                  (xu.test(_) || wu.test(_)) &&
                  (y[T] = n(_.trim()))
              } else E !== 'style' && (y[s0[E] || E] = !0)
              return y
            }, {})
          : null
      }
      ;(h(o, 'q'),
        (t.overrides = t.overrides || {}),
        (t.sanitizer = t.sanitizer || Ib),
        (t.slugify = t.slugify || yn),
        (t.namedCodesToUnicode = t.namedCodesToUnicode
          ? mr({}, l0, t.namedCodesToUnicode)
          : l0),
        (t.createElement = t.createElement || Y))
      const a = []
      const i = {}
      const s = {
        [K.blockQuote]: {
          match: Ft(hb),
          order: 1,
          parse(p, f, g) {
            const [, y, E] = p[0].replace(m5, '').match(h5)
            return { alert: y, children: f(E, g) }
          },
          render(p, f, g) {
            const y = { key: g.key }
            return (
              p.alert &&
                ((y.className =
                  'markdown-alert-' + t.slugify(p.alert.toLowerCase(), yn)),
                p.children.unshift({
                  attrs: {},
                  children: [{ type: K.text, text: p.alert }],
                  noInnerParse: !0,
                  type: K.htmlBlock,
                  tag: 'header',
                })),
              r('blockquote', y, f(p.children, g))
            )
          },
        },
        [K.breakLine]: {
          match: bn(f5),
          order: 1,
          parse: Xa,
          render: h((p, f, g) => r('br', { key: g.key }), 'render'),
        },
        [K.breakThematic]: {
          match: Ft(g5),
          order: 1,
          parse: Xa,
          render: h((p, f, g) => r('hr', { key: g.key }), 'render'),
        },
        [K.codeBlock]: {
          match: Ft(gb),
          order: 0,
          parse: h(
            p => ({
              lang: void 0,
              text: wn(p[0].replace(/^ {4}/gm, '')).replace(u0, '$1'),
            }),
            'parse'
          ),
          render: h(
            (p, f, g) =>
              r(
                'pre',
                { key: g.key },
                r(
                  'code',
                  mr({}, p.attrs, {
                    className: p.lang ? `lang-${p.lang}` : '',
                  }),
                  p.text
                )
              ),
            'render'
          ),
        },
        [K.codeFenced]: {
          match: Ft(fb),
          order: 0,
          parse: h(
            p => ({
              attrs: o('code', p[3] || ''),
              lang: p[2] || void 0,
              text: p[4],
              type: K.codeBlock,
            }),
            'parse'
          ),
        },
        [K.codeInline]: {
          match: Kt(y5),
          order: 3,
          parse: h(p => ({ text: p[2].replace(u0, '$1') }), 'parse'),
          render: h((p, f, g) => r('code', { key: g.key }, p.text), 'render'),
        },
        [K.footnote]: {
          match: Ft(v5),
          order: 0,
          parse: h(
            p => (a.push({ footnote: p[2], identifier: p[1] }), {}),
            'parse'
          ),
          render: Ja,
        },
        [K.footnoteReference]: {
          match: Yt(A5),
          order: 1,
          parse: h(
            p => ({ target: `#${t.slugify(p[1], yn)}`, text: p[1] }),
            'parse'
          ),
          render: h(
            (p, f, g) =>
              r(
                'a',
                { key: g.key, href: t.sanitizer(p.target, 'a', 'href') },
                r('sup', { key: g.key }, p.text)
              ),
            'render'
          ),
        },
        [K.gfmTask]: {
          match: Yt(S5),
          order: 1,
          parse: h(p => ({ completed: p[1].toLowerCase() === 'x' }), 'parse'),
          render: h(
            (p, f, g) =>
              r('input', {
                checked: p.completed,
                key: g.key,
                readOnly: !0,
                type: 'checkbox',
              }),
            'render'
          ),
        },
        [K.heading]: {
          match: Ft(t.enforceAtxHeadings ? bb : yb),
          order: 1,
          parse: h(
            (p, f, g) => ({
              children: eo(f, p[2], g),
              id: t.slugify(p[2], yn),
              level: p[1].length,
            }),
            'parse'
          ),
          render: h(
            (p, f, g) =>
              r(`h${p.level}`, { id: p.id, key: g.key }, f(p.children, g)),
            'render'
          ),
        },
        [K.headingSetext]: {
          match: Ft(Eb),
          order: 0,
          parse: h(
            (p, f, g) => ({
              children: eo(f, p[1], g),
              level: p[2] === '=' ? 1 : 2,
              type: K.heading,
            }),
            'parse'
          ),
        },
        [K.htmlBlock]: {
          match: bn(xu),
          order: 1,
          parse(p, f, g) {
            const [, y] = p[3].match(Y5)
            const E = new RegExp(`^${y}`, 'gm')
            const b = p[3].replace(E, '')
            const x = ((S = b), nD.some(B => B.test(S)) ? Bb : eo)
            let S
            const T = p[1].toLowerCase()
            const _ = l5.includes(T)
            const O = (_ ? T : p[1]).trim()
            const k = { attrs: o(O, p[2]), noInnerParse: _, tag: O }
            return (
              (g.inAnchor = g.inAnchor || T === 'a'),
              _ ? (k.text = p[3]) : (k.children = x(f, b, g)),
              (g.inAnchor = !1),
              k
            )
          },
          render: h(
            (p, f, g) =>
              r(
                p.tag,
                mr({ key: g.key }, p.attrs),
                p.text || (p.children ? f(p.children, g) : '')
              ),
            'render'
          ),
        },
        [K.htmlSelfClosing]: {
          match: bn(wu),
          order: 1,
          parse(p) {
            const f = p[1].trim()
            return { attrs: o(f, p[2] || ''), tag: f }
          },
          render: h(
            (p, f, g) => r(p.tag, mr({}, p.attrs, { key: g.key })),
            'render'
          ),
        },
        [K.htmlComment]: {
          match: bn(vb),
          order: 1,
          parse: h(() => ({}), 'parse'),
          render: Ja,
        },
        [K.image]: {
          match: Kt(rD),
          order: 1,
          parse: h(
            p => ({ alt: p[1], target: Tu(p[2]), title: p[3] }),
            'parse'
          ),
          render: h(
            (p, f, g) =>
              r('img', {
                key: g.key,
                alt: p.alt || void 0,
                title: p.title || void 0,
                src: t.sanitizer(p.target, 'img', 'src'),
              }),
            'render'
          ),
        },
        [K.link]: {
          match: Yt(tD),
          order: 3,
          parse: h(
            (p, f, g) => ({
              children: Rb(f, p[1], g),
              target: Tu(p[2]),
              title: p[3],
            }),
            'parse'
          ),
          render: h(
            (p, f, g) =>
              r(
                'a',
                {
                  key: g.key,
                  href: t.sanitizer(p.target, 'a', 'href'),
                  title: p.title,
                },
                f(p.children, g)
              ),
            'render'
          ),
        },
        [K.linkAngleBraceStyleDetector]: {
          match: Yt(I5),
          order: 0,
          parse: h(
            p => ({
              children: [{ text: p[1], type: K.text }],
              target: p[1],
              type: K.link,
            }),
            'parse'
          ),
        },
        [K.linkBareUrlDetector]: {
          match: Br((p, f) =>
            f.inAnchor || t.disableAutoLink ? null : Yt(k5)(p, f)
          ),
          order: 0,
          parse: h(
            p => ({
              children: [{ text: p[1], type: K.text }],
              target: p[1],
              title: void 0,
              type: K.link,
            }),
            'parse'
          ),
        },
        [K.linkMailtoDetector]: {
          match: Yt(O5),
          order: 0,
          parse(p) {
            const f = p[1]
            let g = p[1]
            return (
              d5.test(g) || (g = 'mailto:' + g),
              {
                children: [{ text: f.replace('mailto:', ''), type: K.text }],
                target: g,
                type: K.link,
              }
            )
          },
        },
        [K.orderedList]: Su(r, 1),
        [K.unorderedList]: Su(r, 2),
        [K.newlineCoalescer]: {
          match: Ft(b5),
          order: 3,
          parse: Xa,
          render: h(
            () => `
`,
            'render'
          ),
        },
        [K.paragraph]: {
          match: Br(Ob),
          order: 3,
          parse: nu,
          render: h(
            (p, f, g) => r('p', { key: g.key }, f(p.children, g)),
            'render'
          ),
        },
        [K.ref]: {
          match: Yt(B5),
          order: 0,
          parse: h(
            p => ((i[p[1]] = { target: p[2], title: p[4] }), {}),
            'parse'
          ),
          render: Ja,
        },
        [K.refImage]: {
          match: Kt(_5),
          order: 0,
          parse: h(p => ({ alt: p[1] || void 0, ref: p[2] }), 'parse'),
          render: h(
            (p, f, g) =>
              i[p.ref]
                ? r('img', {
                    key: g.key,
                    alt: p.alt,
                    src: t.sanitizer(i[p.ref].target, 'img', 'src'),
                    title: i[p.ref].title,
                  })
                : null,
            'render'
          ),
        },
        [K.refLink]: {
          match: Yt(F5),
          order: 0,
          parse: h(
            (p, f, g) => ({
              children: f(p[1], g),
              fallbackChildren: p[0],
              ref: p[2],
            }),
            'parse'
          ),
          render: h(
            (p, f, g) =>
              i[p.ref]
                ? r(
                    'a',
                    {
                      key: g.key,
                      href: t.sanitizer(i[p.ref].target, 'a', 'href'),
                      title: i[p.ref].title,
                    },
                    f(p.children, g)
                  )
                : r('span', { key: g.key }, p.fallbackChildren),
            'render'
          ),
        },
        [K.table]: {
          match: Ft(Ab),
          order: 1,
          parse: kb,
          render(p, f, g) {
            const y = p
            return r(
              'table',
              { key: g.key },
              r(
                'thead',
                null,
                r(
                  'tr',
                  null,
                  y.header.map(function (E, b) {
                    return r('th', { key: b, style: Du(y, b) }, f(E, g))
                  })
                )
              ),
              r(
                'tbody',
                null,
                y.cells.map(function (E, b) {
                  return r(
                    'tr',
                    { key: b },
                    E.map(function (x, S) {
                      return r('td', { key: S, style: Du(y, S) }, f(x, g))
                    })
                  )
                })
              )
            )
          },
        },
        [K.text]: {
          match: bn(G5),
          order: 4,
          parse: h(
            p => ({
              text: p[0].replace(C5, (f, g) =>
                t.namedCodesToUnicode[g] ? t.namedCodesToUnicode[g] : f
              ),
            }),
            'parse'
          ),
          render: h(p => p.text, 'render'),
        },
        [K.textBolded]: {
          match: Kt(q5),
          order: 2,
          parse: h((p, f, g) => ({ children: f(p[2], g) }), 'parse'),
          render: h(
            (p, f, g) => r('strong', { key: g.key }, f(p.children, g)),
            'render'
          ),
        },
        [K.textEmphasized]: {
          match: Kt(U5),
          order: 3,
          parse: h((p, f, g) => ({ children: f(p[2], g) }), 'parse'),
          render: h(
            (p, f, g) => r('em', { key: g.key }, f(p.children, g)),
            'render'
          ),
        },
        [K.textEscaped]: {
          match: Kt(z5),
          order: 1,
          parse: h(p => ({ text: p[1], type: K.text }), 'parse'),
        },
        [K.textMarked]: {
          match: Kt(H5),
          order: 3,
          parse: nu,
          render: h(
            (p, f, g) => r('mark', { key: g.key }, f(p.children, g)),
            'render'
          ),
        },
        [K.textStrikethroughed]: {
          match: Kt(V5),
          order: 3,
          parse: nu,
          render: h(
            (p, f, g) => r('del', { key: g.key }, f(p.children, g)),
            'render'
          ),
        },
      }
      t.disableParsingRawHTML === !0 &&
        (delete s[K.htmlBlock], delete s[K.htmlSelfClosing])
      const l = (function (p) {
        const f = Object.keys(p)
        function g(y, E) {
          let b
          let x
          const S = []
          let T = ''
          let _ = ''
          for (E.prevCapture = E.prevCapture || ''; y; ) {
            let O = 0
            for (; O < f.length; ) {
              if (((T = f[O]), (b = p[T]), E.inline && !b.match.inline)) {
                O++
                continue
              }
              const k = b.match(y, E)
              if (k) {
                ;((_ = k[0]),
                  (E.prevCapture += _),
                  (y = y.substring(_.length)),
                  (x = b.parse(k, g, E)),
                  x.type == null && (x.type = T),
                  S.push(x))
                break
              }
              O++
            }
          }
          return ((E.prevCapture = ''), S)
        }
        return (
          h(g, 'n'),
          f.sort(function (y, E) {
            const b = p[y].order
            const x = p[E].order
            return b !== x ? b - x : y < E ? -1 : 1
          }),
          function (y, E) {
            return g(
              (function (b) {
                return b
                  .replace(
                    E5,
                    `
`
                  )
                  .replace(x5, '')
                  .replace(N5, '    ')
              })(y),
              E
            )
          }
        )
      })(s)
      const u =
        ((d = (function (p, f) {
          return function (g, y, E) {
            const b = p[g.type].render
            return f ? f(() => b(g, y, E), g, y, E) : b(g, y, E)
          }
        })(s, t.renderRule)),
        h(function p(f, g = {}) {
          if (Array.isArray(f)) {
            const y = g.key
            const E = []
            let b = !1
            for (let x = 0; x < f.length; x++) {
              g.key = x
              const S = p(f[x], g)
              const T = typeof S === 'string'
              ;(T && b ? (E[E.length - 1] += S) : S !== null && E.push(S),
                (b = T))
            }
            return ((g.key = y), E)
          }
          return d(f, p, g)
        }, 'e'))
      let d
      const m = n(e)
      return a.length
        ? r(
            'div',
            null,
            m,
            r(
              'footer',
              { key: 'footer' },
              a.map(function (p) {
                return r(
                  'div',
                  { id: t.slugify(p.identifier, yn), key: p.identifier },
                  p.identifier,
                  u(l(p.footnote, { inline: !0 }))
                )
              })
            )
          )
        : m
    }
    h(Fb, 'Xe')
    const aD = h(e => {
      const { children: t = '', options: r } = e
      const n = (function (o, a) {
        if (o == null) return {}
        let i
        let s
        const l = {}
        const u = Object.keys(o)
        for (s = 0; s < u.length; s++) a.includes((i = u[s])) || (l[i] = o[i])
        return l
      })(e, s5)
      return Pe(Fb(t, r), n)
    }, 'default')
    Ot()
    const iD = R.label(({ theme: e }) => ({
      lineHeight: '18px',
      alignItems: 'center',
      marginBottom: 8,
      display: 'inline-block',
      position: 'relative',
      whiteSpace: 'nowrap',
      background: e.boolean.background,
      borderRadius: '3em',
      padding: 1,
      '&[aria-disabled="true"]': {
        opacity: 0.5,
        input: { cursor: 'not-allowed' },
      },
      input: {
        appearance: 'none',
        width: '100%',
        height: '100%',
        position: 'absolute',
        left: 0,
        top: 0,
        margin: 0,
        padding: 0,
        border: 'none',
        background: 'transparent',
        cursor: 'pointer',
        borderRadius: '3em',
        '&:focus': {
          outline: 'none',
          boxShadow: `${e.color.secondary} 0 0 0 1px inset !important`,
        },
        '@media (forced-colors: active)': {
          '&:focus': { outline: '1px solid highlight' },
        },
      },
      span: {
        textAlign: 'center',
        fontSize: e.typography.size.s1,
        fontWeight: e.typography.weight.bold,
        lineHeight: '1',
        cursor: 'pointer',
        display: 'inline-block',
        padding: '7px 15px',
        transition: 'all 100ms ease-out',
        userSelect: 'none',
        borderRadius: '3em',
        color: de(0.5, e.color.defaultText),
        background: 'transparent',
        '&:hover': {
          boxShadow: `${Zn(0.3, e.appBorderColor)} 0 0 0 1px inset`,
        },
        '&:active': {
          boxShadow: `${Zn(0.05, e.appBorderColor)} 0 0 0 2px inset`,
          color: Zn(1, e.appBorderColor),
        },
        '&:first-of-type': { paddingRight: 8 },
        '&:last-of-type': { paddingLeft: 8 },
      },
      'input:checked ~ span:last-of-type, input:not(:checked) ~ span:first-of-type':
        {
          background: e.boolean.selectedBackground,
          boxShadow:
            e.base === 'light'
              ? `${Zn(0.1, e.appBorderColor)} 0 0 2px`
              : `${e.appBorderColor} 0 0 0 1px`,
          color: e.color.defaultText,
          padding: '7px 15px',
          '@media (forced-colors: active)': { textDecoration: 'underline' },
        },
    }))
    const sD = h(e => e === 'true', 'parse')
    const lD = h(
      ({
        name: e,
        value: t,
        onChange: r,
        onBlur: n,
        onFocus: o,
        argType: a,
      }) => {
        const i = Q(() => r(!1), [r])
        const s = !!a?.table?.readonly
        if (t === void 0)
          return c.createElement(
            Je,
            {
              variant: 'outline',
              size: 'medium',
              id: so(e),
              onClick: i,
              disabled: s,
            },
            'Set boolean'
          )
        const l = mt(e)
        const u = typeof t === 'string' ? sD(t) : t
        return c.createElement(
          iD,
          { 'aria-disabled': s, htmlFor: l, 'aria-label': e },
          c.createElement('input', {
            id: l,
            type: 'checkbox',
            onChange: d => r(d.target.checked),
            checked: u,
            role: 'switch',
            disabled: s,
            name: e,
            onBlur: n,
            onFocus: o,
          }),
          c.createElement('span', { 'aria-hidden': 'true' }, 'False'),
          c.createElement('span', { 'aria-hidden': 'true' }, 'True')
        )
      },
      'BooleanControl'
    )
    Ot()
    const uD = h(e => {
      const [t, r, n] = e.split('-')
      const o = new Date()
      return (
        o.setFullYear(parseInt(t, 10), parseInt(r, 10) - 1, parseInt(n, 10)),
        o
      )
    }, 'parseDate')
    const cD = h(e => {
      const [t, r] = e.split(':')
      const n = new Date()
      return (n.setHours(parseInt(t, 10)), n.setMinutes(parseInt(r, 10)), n)
    }, 'parseTime')
    const dD = h(e => {
      const t = new Date(e)
      const r = `000${t.getFullYear()}`.slice(-4)
      const n = `0${t.getMonth() + 1}`.slice(-2)
      const o = `0${t.getDate()}`.slice(-2)
      return `${r}-${n}-${o}`
    }, 'formatDate')
    const pD = h(e => {
      const t = new Date(e)
      const r = `0${t.getHours()}`.slice(-2)
      const n = `0${t.getMinutes()}`.slice(-2)
      return `${r}:${n}`
    }, 'formatTime')
    const c0 = R($e.Input)(({ readOnly: e }) => ({ opacity: e ? 0.5 : 1 }))
    const mD = R.div(({ theme: e }) => ({
      flex: 1,
      display: 'flex',
      input: {
        marginLeft: 10,
        flex: 1,
        height: 32,
        '&::-webkit-calendar-picker-indicator': {
          opacity: 0.5,
          height: 12,
          filter: e.base === 'light' ? void 0 : 'invert(1)',
        },
      },
      'input:first-of-type': { marginLeft: 0, flexGrow: 4 },
      'input:last-of-type': { flexGrow: 3 },
    }))
    const hD = h(
      ({
        name: e,
        value: t,
        onChange: r,
        onFocus: n,
        onBlur: o,
        argType: a,
      }) => {
        const [i, s] = z(!0)
        const l = ye()
        const u = ye()
        const d = !!a?.table?.readonly
        X(() => {
          i !== !1 &&
            (l && l.current && (l.current.value = t ? dD(t) : ''),
            u && u.current && (u.current.value = t ? pD(t) : ''))
        }, [t])
        const m = h(g => {
          if (!g.target.value) return r()
          const y = uD(g.target.value)
          const E = new Date(t ?? '')
          E.setFullYear(y.getFullYear(), y.getMonth(), y.getDate())
          const b = E.getTime()
          ;(b && r(b), s(!!b))
        }, 'onDateChange')
        const p = h(g => {
          if (!g.target.value) return r()
          const y = cD(g.target.value)
          const E = new Date(t ?? '')
          ;(E.setHours(y.getHours()), E.setMinutes(y.getMinutes()))
          const b = E.getTime()
          ;(b && r(b), s(!!b))
        }, 'onTimeChange')
        const f = mt(e)
        return c.createElement(
          mD,
          null,
          c.createElement(c0, {
            type: 'date',
            max: '9999-12-31',
            ref: l,
            id: `${f}-date`,
            name: `${f}-date`,
            readOnly: d,
            onChange: m,
            onFocus: n,
            onBlur: o,
          }),
          c.createElement(c0, {
            type: 'time',
            id: `${f}-time`,
            name: `${f}-time`,
            ref: u,
            onChange: p,
            readOnly: d,
            onFocus: n,
            onBlur: o,
          }),
          i ? null : c.createElement('div', null, 'invalid')
        )
      },
      'DateControl'
    )
    Ot()
    const fD = R.label({ display: 'flex' })
    const gD = h(e => {
      const t = parseFloat(e)
      return Number.isNaN(t) ? void 0 : t
    }, 'parse')
    const yD = R($e.Input)(({ readOnly: e }) => ({ opacity: e ? 0.5 : 1 }))
    const bD = h(
      ({
        name: e,
        value: t,
        onChange: r,
        min: n,
        max: o,
        step: a,
        onBlur: i,
        onFocus: s,
        argType: l,
      }) => {
        const [u, d] = z(typeof t === 'number' ? t : '')
        const [m, p] = z(!1)
        const [f, g] = z(null)
        const y = !!l?.table?.readonly
        const E = Q(
          S => {
            d(S.target.value)
            const T = parseFloat(S.target.value)
            Number.isNaN(T)
              ? g(new Error(`'${S.target.value}' is not a number`))
              : (r(T), g(null))
          },
          [r, g]
        )
        const b = Q(() => {
          ;(d('0'), r(0), p(!0))
        }, [p])
        const x = ye(null)
        return (
          X(() => {
            m && x.current && x.current.select()
          }, [m]),
          X(() => {
            const S = typeof t === 'number' ? t : ''
            u !== S && d(S)
          }, [t]),
          t === void 0
            ? c.createElement(
                Je,
                {
                  variant: 'outline',
                  size: 'medium',
                  id: so(e),
                  onClick: b,
                  disabled: y,
                },
                'Set number'
              )
            : c.createElement(
                fD,
                null,
                c.createElement(yD, {
                  ref: x,
                  id: mt(e),
                  type: 'number',
                  onChange: E,
                  size: 'flex',
                  placeholder: 'Edit number...',
                  value: u,
                  valid: f ? 'error' : void 0,
                  autoFocus: m,
                  readOnly: y,
                  name: e,
                  min: n,
                  max: o,
                  step: a,
                  onFocus: s,
                  onBlur: i,
                })
              )
        )
      },
      'NumberControl'
    )
    Ot()
    const Pb = h((e, t) => {
      const r = t && Object.entries(t).find(([n, o]) => o === e)
      return r ? r[0] : void 0
    }, 'selectedKey')
    const ku = h(
      (e, t) =>
        e && t
          ? Object.entries(t)
              .filter(r => e.includes(r[1]))
              .map(r => r[0])
          : [],
      'selectedKeys'
    )
    const Nb = h((e, t) => e && t && e.map(r => t[r]), 'selectedValues')
    const ED = R.div(
      ({ isInline: e }) =>
        e
          ? {
              display: 'flex',
              flexWrap: 'wrap',
              alignItems: 'flex-start',
              label: { display: 'inline-flex', marginRight: 15 },
            }
          : { label: { display: 'flex' } },
      e => {
        if (e['aria-readonly'] === 'true')
          return { input: { cursor: 'not-allowed' } }
      }
    )
    const vD = R.span({ '[aria-readonly=true] &': { opacity: 0.5 } })
    const AD = R.label({
      lineHeight: '20px',
      alignItems: 'center',
      marginBottom: 8,
      '&:last-child': { marginBottom: 0 },
      input: { margin: 0, marginRight: 6 },
    })
    const d0 = h(
      ({
        name: e,
        options: t,
        value: r,
        onChange: n,
        isInline: o,
        argType: a,
      }) => {
        if (!t)
          return (
            Z.warn(`Checkbox with no options: ${e}`),
            c.createElement(c.Fragment, null, '-')
          )
        const i = ku(r || [], t)
        const [s, l] = z(i)
        const u = !!a?.table?.readonly
        const d = h(p => {
          const f = p.target.value
          const g = [...s]
          ;(g.includes(f) ? g.splice(g.indexOf(f), 1) : g.push(f),
            n(Nb(g, t)),
            l(g))
        }, 'handleChange')
        X(() => {
          l(ku(r || [], t))
        }, [r])
        const m = mt(e)
        return c.createElement(
          ED,
          { 'aria-readonly': u, isInline: o },
          Object.keys(t).map((p, f) => {
            const g = `${m}-${f}`
            return c.createElement(
              AD,
              { key: g, htmlFor: g },
              c.createElement('input', {
                type: 'checkbox',
                disabled: u,
                id: g,
                name: g,
                value: p,
                onChange: d,
                checked: s?.includes(p),
              }),
              c.createElement(vD, null, p)
            )
          })
        )
      },
      'CheckboxControl'
    )
    Ot()
    const xD = R.div(
      ({ isInline: e }) =>
        e
          ? {
              display: 'flex',
              flexWrap: 'wrap',
              alignItems: 'flex-start',
              label: { display: 'inline-flex', marginRight: 15 },
            }
          : { label: { display: 'flex' } },
      e => {
        if (e['aria-readonly'] === 'true')
          return { input: { cursor: 'not-allowed' } }
      }
    )
    const wD = R.span({ '[aria-readonly=true] &': { opacity: 0.5 } })
    const SD = R.label({
      lineHeight: '20px',
      alignItems: 'center',
      marginBottom: 8,
      '&:last-child': { marginBottom: 0 },
      input: { margin: 0, marginRight: 6 },
    })
    const p0 = h(
      ({
        name: e,
        options: t,
        value: r,
        onChange: n,
        isInline: o,
        argType: a,
      }) => {
        if (!t)
          return (
            Z.warn(`Radio with no options: ${e}`),
            c.createElement(c.Fragment, null, '-')
          )
        const i = Pb(r, t)
        const s = mt(e)
        const l = !!a?.table?.readonly
        return c.createElement(
          xD,
          { 'aria-readonly': l, isInline: o },
          Object.keys(t).map((u, d) => {
            const m = `${s}-${d}`
            return c.createElement(
              SD,
              { key: m, htmlFor: m },
              c.createElement('input', {
                type: 'radio',
                id: m,
                name: s,
                disabled: l,
                value: u,
                onChange: p => n(t[p.currentTarget.value]),
                checked: u === i,
              }),
              c.createElement(wD, null, u)
            )
          })
        )
      },
      'RadioControl'
    )
    Ot()
    const CD = {
      appearance: 'none',
      border: '0 none',
      boxSizing: 'inherit',
      display: ' block',
      margin: ' 0',
      background: 'transparent',
      padding: 0,
      fontSize: 'inherit',
      position: 'relative',
    }
    const Lb = R.select(CD, ({ theme: e }) => ({
      boxSizing: 'border-box',
      position: 'relative',
      padding: '6px 10px',
      width: '100%',
      color: e.input.color || 'inherit',
      background: e.input.background,
      borderRadius: e.input.borderRadius,
      boxShadow: `${e.input.border} 0 0 0 1px inset`,
      fontSize: e.typography.size.s2 - 1,
      lineHeight: '20px',
      '&:focus': {
        boxShadow: `${e.color.secondary} 0 0 0 1px inset`,
        outline: 'none',
      },
      '&[disabled]': { cursor: 'not-allowed', opacity: 0.5 },
      '::placeholder': { color: e.textMutedColor },
      '&[multiple]': {
        overflow: 'auto',
        padding: 0,
        option: {
          display: 'block',
          padding: '6px 10px',
          marginLeft: 1,
          marginRight: 1,
        },
      },
    }))
    const jb = R.span(({ theme: e }) => ({
      display: 'inline-block',
      lineHeight: 'normal',
      overflow: 'hidden',
      position: 'relative',
      verticalAlign: 'top',
      width: '100%',
      svg: {
        position: 'absolute',
        zIndex: 1,
        pointerEvents: 'none',
        height: '12px',
        marginTop: '-6px',
        right: '12px',
        top: '50%',
        fill: e.textMutedColor,
        path: { fill: e.textMutedColor },
      },
    }))
    const m0 = 'Choose option...'
    const DD = h(
      ({ name: e, value: t, options: r, onChange: n, argType: o }) => {
        const a = h(u => {
          n(r[u.currentTarget.value])
        }, 'handleChange')
        const i = Pb(t, r) || m0
        const s = mt(e)
        const l = !!o?.table?.readonly
        return c.createElement(
          jb,
          null,
          c.createElement(Eo, null),
          c.createElement(
            Lb,
            { disabled: l, id: s, value: i, onChange: a },
            c.createElement(
              'option',
              { key: 'no-selection', disabled: !0 },
              m0
            ),
            Object.keys(r).map(u =>
              c.createElement('option', { key: u, value: u }, u)
            )
          )
        )
      },
      'SingleSelect'
    )
    const TD = h(
      ({ name: e, value: t, options: r, onChange: n, argType: o }) => {
        const a = h(u => {
          const d = Array.from(u.currentTarget.options)
            .filter(m => m.selected)
            .map(m => m.value)
          n(Nb(d, r))
        }, 'handleChange')
        const i = ku(t, r)
        const s = mt(e)
        const l = !!o?.table?.readonly
        return c.createElement(
          jb,
          null,
          c.createElement(
            Lb,
            { disabled: l, id: s, multiple: !0, value: i, onChange: a },
            Object.keys(r).map(u =>
              c.createElement('option', { key: u, value: u }, u)
            )
          )
        )
      },
      'MultiSelect'
    )
    const h0 = h(e => {
      const { name: t, options: r } = e
      return r
        ? e.isMulti
          ? c.createElement(TD, { ...e })
          : c.createElement(DD, { ...e })
        : (Z.warn(`Select with no options: ${t}`),
          c.createElement(c.Fragment, null, '-'))
    }, 'SelectControl')
    const kD = h(
      (e, t) =>
        Array.isArray(e)
          ? e.reduce((r, n) => ((r[t?.[n] || String(n)] = n), r), {})
          : e,
      'normalizeOptions'
    )
    const OD = {
      check: d0,
      'inline-check': d0,
      radio: p0,
      'inline-radio': p0,
      select: h0,
      'multi-select': h0,
    }
    const fn = h(e => {
      const { type: t = 'select', labels: r, argType: n } = e
      const o = {
        ...e,
        argType: n,
        options: n ? kD(n.options, r) : {},
        isInline: t.includes('inline'),
        isMulti: t.includes('multi'),
      }
      const a = OD[t]
      if (a) return c.createElement(a, { ...o })
      throw new Error(`Unknown options type: ${t}`)
    }, 'OptionsControl')
    pi()
    Ot()
    const ID = R.div(({ theme: e }) => ({
      position: 'relative',
      ':hover': {
        '& > .rejt-accordion-button::after': { background: e.color.secondary },
        '& > .rejt-accordion-region > :is(.rejt-plus-menu, .rejt-minus-menu)': {
          opacity: 1,
        },
      },
    }))
    const RD = R.button(({ theme: e }) => ({
      padding: 0,
      background: 'transparent',
      border: 'none',
      marginRight: '3px',
      lineHeight: '22px',
      color: e.color.secondary,
      '::after': {
        content: '""',
        position: 'absolute',
        top: 0,
        display: 'block',
        width: '100%',
        marginLeft: '-1rem',
        height: '22px',
        background: 'transparent',
        borderRadius: 4,
        transition: 'background 0.2s',
        opacity: 0.1,
        paddingRight: '20px',
      },
      '::before': { content: '""', position: 'absolute' },
      '&[aria-expanded="true"]::before': {
        left: -10,
        top: 10,
        borderTop: '3px solid rgba(153,153,153,0.6)',
        borderLeft: '3px solid transparent',
        borderRight: '3px solid transparent',
      },
      '&[aria-expanded="false"]::before': {
        left: -8,
        top: 8,
        borderTop: '3px solid transparent',
        borderBottom: '3px solid transparent',
        borderLeft: '3px solid rgba(153,153,153,0.6)',
      },
    }))
    const BD = R.div({ display: 'inline' })
    function ac({
      children: e,
      name: t,
      collapsed: r,
      keyPath: n,
      deep: o,
      ...a
    }) {
      const i = `${n.at(-1) ?? 'root'}-${t}-${o}`
      const s = { trigger: `${i}-trigger`, region: `${i}-region` }
      const l = n.length > 0 ? 'li' : 'div'
      return c.createElement(
        ID,
        { as: l },
        c.createElement(
          RD,
          {
            type: 'button',
            'aria-expanded': !r,
            id: s.trigger,
            'aria-controls': s.region,
            className: 'rejt-accordion-button',
            ...a,
          },
          t,
          ' :'
        ),
        c.createElement(
          BD,
          {
            role: 'region',
            id: s.region,
            'aria-labelledby': s.trigger,
            className: 'rejt-accordion-region',
          },
          e
        )
      )
    }
    h(ac, 'JsonNodeAccordion')
    const _D = 'Error'
    const FD = 'Object'
    const PD = 'Array'
    const ND = 'String'
    const LD = 'Number'
    const jD = 'Boolean'
    const MD = 'Date'
    const $D = 'Null'
    const qD = 'Undefined'
    const UD = 'Function'
    const HD = 'Symbol'
    const Mb = 'ADD_DELTA_TYPE'
    const $b = 'REMOVE_DELTA_TYPE'
    const qb = 'UPDATE_DELTA_TYPE'
    const ic = 'value'
    const VD = 'key'
    function hr(e) {
      return e !== null &&
        typeof e === 'object' &&
        !Array.isArray(e) &&
        typeof e[Symbol.iterator] === 'function'
        ? 'Iterable'
        : Object.prototype.toString.call(e).slice(8, -1)
    }
    h(hr, 'getObjectType')
    function sc(e, t) {
      const r = hr(e)
      const n = hr(t)
      return (r === 'Function' || n === 'Function') && n !== r
    }
    h(sc, 'isComponentWillChange')
    const Ub = class extends Et {
      constructor(t) {
        ;(super(t),
          (this.state = { inputRefKey: null, inputRefValue: null }),
          (this.refInputValue = this.refInputValue.bind(this)),
          (this.refInputKey = this.refInputKey.bind(this)),
          (this.onKeydown = this.onKeydown.bind(this)),
          (this.onSubmit = this.onSubmit.bind(this)))
      }
      componentDidMount() {
        const { inputRefKey: t, inputRefValue: r } = this.state
        const { onlyValue: n } = this.props
        ;(t && typeof t.focus === 'function' && t.focus(),
          n && r && typeof r.focus === 'function' && r.focus())
      }
      onKeydown(t) {
        if (t.altKey || t.ctrlKey || t.metaKey || t.shiftKey || t.repeat) return
        const { inputRefKey: r, inputRefValue: n } = this.state
        const { addButtonElement: o, handleCancel: a } = this.props
        ;[r, n, o].includes(t.target) &&
          ((t.code === 'Enter' || t.key === 'Enter') &&
            (t.preventDefault(), this.onSubmit()),
          (t.code === 'Escape' || t.key === 'Escape') &&
            (t.preventDefault(), a()))
      }
      onSubmit() {
        const {
          handleAdd: t,
          onlyValue: r,
          onSubmitValueParser: n,
          keyPath: o,
          deep: a,
        } = this.props
        const { inputRefKey: i, inputRefValue: s } = this.state
        const l = {}
        if (!r) {
          if (!i.value) return
          l.key = i.value
        }
        ;((l.newValue = n(!1, o, a, l.key, s.value)), t(l))
      }
      refInputKey(t) {
        this.state.inputRefKey = t
      }
      refInputValue(t) {
        this.state.inputRefValue = t
      }
      render() {
        const {
          handleCancel: t,
          onlyValue: r,
          addButtonElement: n,
          cancelButtonElement: o,
          inputElementGenerator: a,
          keyPath: i,
          deep: s,
        } = this.props
        const l = n && Pe(n, { onClick: this.onSubmit })
        const u = o && Pe(o, { onClick: t })
        const d = a(ic, i, s)
        const m = Pe(d, {
          placeholder: 'Value',
          ref: this.refInputValue,
          onKeyDown: this.onKeydown,
        })
        let p = null
        if (!r) {
          const f = a(VD, i, s)
          p = Pe(f, {
            placeholder: 'Key',
            ref: this.refInputKey,
            onKeyDown: this.onKeydown,
          })
        }
        return c.createElement(
          'span',
          { className: 'rejt-add-value-node' },
          p,
          m,
          l,
          u
        )
      }
    }
    h(Ub, 'JsonAddValue')
    const lc = Ub
    lc.defaultProps = {
      onlyValue: !1,
      addButtonElement: c.createElement('button', null, '+'),
      cancelButtonElement: c.createElement('button', null, 'c'),
    }
    const Hb = class extends Et {
      constructor(t) {
        super(t)
        const r = [...(t.keyPath || []), t.name]
        ;((this.state = {
          data: t.data,
          name: t.name,
          keyPath: r ?? [],
          deep: t.deep ?? 0,
          nextDeep: (t.deep ?? 0) + 1,
          collapsed: t.isCollapsed(r, t.deep ?? 0, t.data),
          addFormVisible: !1,
        }),
          (this.handleCollapseMode = this.handleCollapseMode.bind(this)),
          (this.handleRemoveItem = this.handleRemoveItem.bind(this)),
          (this.handleAddMode = this.handleAddMode.bind(this)),
          (this.handleAddValueAdd = this.handleAddValueAdd.bind(this)),
          (this.handleAddValueCancel = this.handleAddValueCancel.bind(this)),
          (this.handleEditValue = this.handleEditValue.bind(this)),
          (this.onChildUpdate = this.onChildUpdate.bind(this)),
          (this.renderCollapsed = this.renderCollapsed.bind(this)),
          (this.renderNotCollapsed = this.renderNotCollapsed.bind(this)))
      }
      static getDerivedStateFromProps(t, r) {
        return t.data !== r.data ? { data: t.data } : null
      }
      onChildUpdate(t, r) {
        const { data: n, keyPath: o = [] } = this.state
        ;((n[t] = r), this.setState({ data: n }))
        const { onUpdate: a } = this.props
        const i = o.length
        a(o[i - 1], n)
      }
      handleAddMode() {
        this.setState({ addFormVisible: !0 })
      }
      handleCollapseMode() {
        this.setState(t => ({ collapsed: !t.collapsed }))
      }
      handleRemoveItem(t) {
        return () => {
          const { beforeRemoveAction: r, logger: n } = this.props
          const { data: o, keyPath: a, nextDeep: i } = this.state
          const s = o[t]
          ;(r || Promise.resolve.bind(Promise))(t, a, i, s)
            .then(() => {
              const l = { keyPath: a, deep: i, key: t, oldValue: s, type: $b }
              ;(o.splice(t, 1), this.setState({ data: o }))
              const { onUpdate: u, onDeltaUpdate: d } = this.props
              ;(u(a[a.length - 1], o), d(l))
            })
            .catch(n.error)
        }
      }
      handleAddValueAdd({ key: t, newValue: r }) {
        const { data: n, keyPath: o = [], nextDeep: a } = this.state
        const { beforeAddAction: i, logger: s } = this.props
        ;(i || Promise.resolve.bind(Promise))(t, o, a, r)
          .then(() => {
            ;((n[t] = r),
              this.setState({ data: n }),
              this.handleAddValueCancel())
            const { onUpdate: l, onDeltaUpdate: u } = this.props
            ;(l(o[o.length - 1], n),
              u({ type: Mb, keyPath: o, deep: a, key: t, newValue: r }))
          })
          .catch(s.error)
      }
      handleAddValueCancel() {
        this.setState({ addFormVisible: !1 })
      }
      handleEditValue({ key: t, value: r }) {
        return new Promise((n, o) => {
          const { beforeUpdateAction: a } = this.props
          const { data: i, keyPath: s, nextDeep: l } = this.state
          const u = i[t]
          ;(a || Promise.resolve.bind(Promise))(t, s, l, u, r)
            .then(() => {
              ;((i[t] = r), this.setState({ data: i }))
              const { onUpdate: d, onDeltaUpdate: m } = this.props
              ;(d(s[s.length - 1], i),
                m({
                  type: qb,
                  keyPath: s,
                  deep: l,
                  key: t,
                  newValue: r,
                  oldValue: u,
                }),
                n(void 0))
            })
            .catch(o)
        })
      }
      renderCollapsed() {
        const { name: t, data: r, keyPath: n, deep: o } = this.state
        const {
          handleRemove: a,
          readOnly: i,
          getStyle: s,
          dataType: l,
          minusMenuElement: u,
        } = this.props
        const { minus: d, collapsed: m } = s(t, r, n, o, l)
        const p = i(t, r, n, o, l)
        const f =
          u &&
          Pe(u, {
            onClick: a,
            className: 'rejt-minus-menu',
            style: d,
            'aria-label': `remove the array '${t}'`,
          })
        return c.createElement(
          c.Fragment,
          null,
          c.createElement(
            'span',
            { style: m },
            '[...] ',
            r.length,
            ' ',
            r.length === 1 ? 'item' : 'items'
          ),
          !p && f
        )
      }
      renderNotCollapsed() {
        const {
          name: t,
          data: r,
          keyPath: n,
          deep: o,
          addFormVisible: a,
          nextDeep: i,
        } = this.state
        const {
          isCollapsed: s,
          handleRemove: l,
          onDeltaUpdate: u,
          readOnly: d,
          getStyle: m,
          dataType: p,
          addButtonElement: f,
          cancelButtonElement: g,
          inputElementGenerator: y,
          textareaElementGenerator: E,
          minusMenuElement: b,
          plusMenuElement: x,
          beforeRemoveAction: S,
          beforeAddAction: T,
          beforeUpdateAction: _,
          logger: O,
          onSubmitValueParser: k,
        } = this.props
        const {
          minus: B,
          plus: P,
          delimiter: L,
          ul: j,
          addForm: U,
        } = m(t, r, n, o, p)
        const $ = d(t, r, n, o, p)
        const v =
          x &&
          Pe(x, {
            onClick: this.handleAddMode,
            className: 'rejt-plus-menu',
            style: P,
            'aria-label': `add a new item to the '${t}' array`,
          })
        const A =
          b &&
          Pe(b, {
            onClick: l,
            className: 'rejt-minus-menu',
            style: B,
            'aria-label': `remove the array '${t}'`,
          })
        return c.createElement(
          c.Fragment,
          null,
          c.createElement(
            'span',
            { className: 'rejt-not-collapsed-delimiter', style: L },
            '['
          ),
          !a && v,
          c.createElement(
            'ul',
            { className: 'rejt-not-collapsed-list', style: j },
            r.map((D, N) =>
              c.createElement(fi, {
                key: N,
                name: N.toString(),
                data: D,
                keyPath: n,
                deep: i,
                isCollapsed: s,
                handleRemove: this.handleRemoveItem(N),
                handleUpdateValue: this.handleEditValue,
                onUpdate: this.onChildUpdate,
                onDeltaUpdate: u,
                readOnly: d,
                getStyle: m,
                addButtonElement: f,
                cancelButtonElement: g,
                inputElementGenerator: y,
                textareaElementGenerator: E,
                minusMenuElement: b,
                plusMenuElement: x,
                beforeRemoveAction: S,
                beforeAddAction: T,
                beforeUpdateAction: _,
                logger: O,
                onSubmitValueParser: k,
              })
            )
          ),
          !$ &&
            a &&
            c.createElement(
              'div',
              { className: 'rejt-add-form', style: U },
              c.createElement(lc, {
                handleAdd: this.handleAddValueAdd,
                handleCancel: this.handleAddValueCancel,
                onlyValue: !0,
                addButtonElement: f,
                cancelButtonElement: g,
                inputElementGenerator: y,
                keyPath: n,
                deep: o,
                onSubmitValueParser: k,
              })
            ),
          c.createElement(
            'span',
            { className: 'rejt-not-collapsed-delimiter', style: L },
            ']'
          ),
          !$ && A
        )
      }
      render() {
        const { name: t, collapsed: r, keyPath: n, deep: o } = this.state
        const a = r ? this.renderCollapsed() : this.renderNotCollapsed()
        return c.createElement(
          ac,
          {
            name: t,
            collapsed: r,
            deep: o,
            keyPath: n,
            onClick: this.handleCollapseMode,
          },
          a
        )
      }
    }
    h(Hb, 'JsonArray')
    const Vb = Hb
    Vb.defaultProps = {
      keyPath: [],
      deep: 0,
      minusMenuElement: c.createElement('span', null, ' - '),
      plusMenuElement: c.createElement('span', null, ' + '),
    }
    const zb = class extends Et {
      constructor(t) {
        super(t)
        const r = [...(t.keyPath || []), t.name]
        ;((this.state = {
          value: t.value,
          name: t.name,
          keyPath: r ?? [],
          deep: t.deep ?? 0,
          editEnabled: !1,
          inputRef: null,
        }),
          (this.handleEditMode = this.handleEditMode.bind(this)),
          (this.refInput = this.refInput.bind(this)),
          (this.handleCancelEdit = this.handleCancelEdit.bind(this)),
          (this.handleEdit = this.handleEdit.bind(this)),
          (this.onKeydown = this.onKeydown.bind(this)))
      }
      static getDerivedStateFromProps(t, r) {
        return t.value !== r.value ? { value: t.value } : null
      }
      componentDidUpdate() {
        const {
          editEnabled: t,
          inputRef: r,
          name: n,
          value: o,
          keyPath: a,
          deep: i,
        } = this.state
        const { readOnly: s, dataType: l } = this.props
        const u = s(n, o, a, i, l)
        t && !u && typeof r.focus === 'function' && r.focus()
      }
      onKeydown(t) {
        const { inputRef: r } = this.state
        t.altKey ||
          t.ctrlKey ||
          t.metaKey ||
          t.shiftKey ||
          t.repeat ||
          r !== t.target ||
          ((t.code === 'Enter' || t.key === 'Enter') &&
            (t.preventDefault(), this.handleEdit()),
          (t.code === 'Escape' || t.key === 'Escape') &&
            (t.preventDefault(), this.handleCancelEdit()))
      }
      handleEdit() {
        const {
          handleUpdateValue: t,
          originalValue: r,
          logger: n,
          onSubmitValueParser: o,
          keyPath: a,
        } = this.props
        const { inputRef: i, name: s, deep: l } = this.state
        if (!i) return
        const u = o(!0, a, l, s, i.value)
        const d = { value: u, key: s }
        ;(t || Promise.resolve.bind(Promise))(d)
          .then(() => {
            sc(r, u) || this.handleCancelEdit()
          })
          .catch(n.error)
      }
      handleEditMode() {
        this.setState({ editEnabled: !0 })
      }
      refInput(t) {
        this.state.inputRef = t
      }
      handleCancelEdit() {
        this.setState({ editEnabled: !1 })
      }
      render() {
        const {
          name: t,
          value: r,
          editEnabled: n,
          keyPath: o,
          deep: a,
        } = this.state
        const {
          handleRemove: i,
          originalValue: s,
          readOnly: l,
          dataType: u,
          getStyle: d,
          textareaElementGenerator: m,
          minusMenuElement: p,
          keyPath: f = [],
        } = this.props
        const g = d(t, s, o, a, u)
        let y = null
        let E = null
        const b = l(t, s, o, a, u)
        if (n && !b) {
          const x = m(ic, f, a, t, s, u)
          const S = Pe(x, {
            ref: this.refInput,
            defaultValue: r,
            onKeyDown: this.onKeydown,
          })
          ;((y = c.createElement(
            'span',
            { className: 'rejt-edit-form', style: g.editForm },
            S
          )),
            (E = null))
        } else {
          y = c.createElement(
            'span',
            {
              className: 'rejt-value',
              style: g.value,
              onClick: b ? void 0 : this.handleEditMode,
            },
            r
          )
          const x = f.at(-1)
          const S =
            p &&
            Pe(p, {
              onClick: i,
              className: 'rejt-minus-menu',
              style: g.minus,
              'aria-label': `remove the function '${t}'${x ? ` from '${x}'` : ''}`,
            })
          E = b ? null : S
        }
        return c.createElement(
          'li',
          { className: 'rejt-value-node', style: g.li },
          c.createElement(
            'span',
            { className: 'rejt-name', style: g.name },
            t,
            ' :',
            ' '
          ),
          y,
          E
        )
      }
    }
    h(zb, 'JsonFunctionValue')
    const Gb = zb
    Gb.defaultProps = {
      keyPath: [],
      deep: 0,
      handleUpdateValue: h(() => {}, 'handleUpdateValue'),
      cancelButtonElement: c.createElement('button', null, 'c'),
      minusMenuElement: c.createElement('span', null, ' - '),
    }
    const Wb = class extends Et {
      constructor(t) {
        ;(super(t),
          (this.state = {
            data: t.data,
            name: t.name,
            keyPath: t.keyPath ?? [],
            deep: t.deep ?? 0,
          }))
      }
      static getDerivedStateFromProps(t, r) {
        return t.data !== r.data ? { data: t.data } : null
      }
      render() {
        const { data: t, name: r, keyPath: n, deep: o } = this.state
        const {
          isCollapsed: a,
          handleRemove: i,
          handleUpdateValue: s,
          onUpdate: l,
          onDeltaUpdate: u,
          readOnly: d,
          getStyle: m,
          addButtonElement: p,
          cancelButtonElement: f,
          inputElementGenerator: g,
          textareaElementGenerator: y,
          minusMenuElement: E,
          plusMenuElement: b,
          beforeRemoveAction: x,
          beforeAddAction: S,
          beforeUpdateAction: T,
          logger: _,
          onSubmitValueParser: O,
        } = this.props
        const k = h(() => !0, 'readOnlyTrue')
        const B = hr(t)
        switch (B) {
          case _D:
            return c.createElement(Ou, {
              data: t,
              name: r,
              isCollapsed: a,
              keyPath: n,
              deep: o,
              handleRemove: i,
              onUpdate: l,
              onDeltaUpdate: u,
              readOnly: k,
              dataType: B,
              getStyle: m,
              addButtonElement: p,
              cancelButtonElement: f,
              inputElementGenerator: g,
              textareaElementGenerator: y,
              minusMenuElement: E,
              plusMenuElement: b,
              beforeRemoveAction: x,
              beforeAddAction: S,
              beforeUpdateAction: T,
              logger: _,
              onSubmitValueParser: O,
            })
          case FD:
            return c.createElement(Ou, {
              data: t,
              name: r,
              isCollapsed: a,
              keyPath: n,
              deep: o,
              handleRemove: i,
              onUpdate: l,
              onDeltaUpdate: u,
              readOnly: d,
              dataType: B,
              getStyle: m,
              addButtonElement: p,
              cancelButtonElement: f,
              inputElementGenerator: g,
              textareaElementGenerator: y,
              minusMenuElement: E,
              plusMenuElement: b,
              beforeRemoveAction: x,
              beforeAddAction: S,
              beforeUpdateAction: T,
              logger: _,
              onSubmitValueParser: O,
            })
          case PD:
            return c.createElement(Vb, {
              data: t,
              name: r,
              isCollapsed: a,
              keyPath: n,
              deep: o,
              handleRemove: i,
              onUpdate: l,
              onDeltaUpdate: u,
              readOnly: d,
              dataType: B,
              getStyle: m,
              addButtonElement: p,
              cancelButtonElement: f,
              inputElementGenerator: g,
              textareaElementGenerator: y,
              minusMenuElement: E,
              plusMenuElement: b,
              beforeRemoveAction: x,
              beforeAddAction: S,
              beforeUpdateAction: T,
              logger: _,
              onSubmitValueParser: O,
            })
          case ND:
            return c.createElement(cr, {
              name: r,
              value: `"${t}"`,
              originalValue: t,
              keyPath: n,
              deep: o,
              handleRemove: i,
              handleUpdateValue: s,
              readOnly: d,
              dataType: B,
              getStyle: m,
              cancelButtonElement: f,
              inputElementGenerator: g,
              minusMenuElement: E,
              logger: _,
              onSubmitValueParser: O,
            })
          case LD:
            return c.createElement(cr, {
              name: r,
              value: t,
              originalValue: t,
              keyPath: n,
              deep: o,
              handleRemove: i,
              handleUpdateValue: s,
              readOnly: d,
              dataType: B,
              getStyle: m,
              cancelButtonElement: f,
              inputElementGenerator: g,
              minusMenuElement: E,
              logger: _,
              onSubmitValueParser: O,
            })
          case jD:
            return c.createElement(cr, {
              name: r,
              value: t ? 'true' : 'false',
              originalValue: t,
              keyPath: n,
              deep: o,
              handleRemove: i,
              handleUpdateValue: s,
              readOnly: d,
              dataType: B,
              getStyle: m,
              cancelButtonElement: f,
              inputElementGenerator: g,
              minusMenuElement: E,
              logger: _,
              onSubmitValueParser: O,
            })
          case MD:
            return c.createElement(cr, {
              name: r,
              value: t.toISOString(),
              originalValue: t,
              keyPath: n,
              deep: o,
              handleRemove: i,
              handleUpdateValue: s,
              readOnly: k,
              dataType: B,
              getStyle: m,
              cancelButtonElement: f,
              inputElementGenerator: g,
              minusMenuElement: E,
              logger: _,
              onSubmitValueParser: O,
            })
          case $D:
            return c.createElement(cr, {
              name: r,
              value: 'null',
              originalValue: 'null',
              keyPath: n,
              deep: o,
              handleRemove: i,
              handleUpdateValue: s,
              readOnly: d,
              dataType: B,
              getStyle: m,
              cancelButtonElement: f,
              inputElementGenerator: g,
              minusMenuElement: E,
              logger: _,
              onSubmitValueParser: O,
            })
          case qD:
            return c.createElement(cr, {
              name: r,
              value: 'undefined',
              originalValue: 'undefined',
              keyPath: n,
              deep: o,
              handleRemove: i,
              handleUpdateValue: s,
              readOnly: d,
              dataType: B,
              getStyle: m,
              cancelButtonElement: f,
              inputElementGenerator: g,
              minusMenuElement: E,
              logger: _,
              onSubmitValueParser: O,
            })
          case UD:
            return c.createElement(Gb, {
              name: r,
              value: t.toString(),
              originalValue: t,
              keyPath: n,
              deep: o,
              handleRemove: i,
              handleUpdateValue: s,
              readOnly: d,
              dataType: B,
              getStyle: m,
              cancelButtonElement: f,
              textareaElementGenerator: y,
              minusMenuElement: E,
              logger: _,
              onSubmitValueParser: O,
            })
          case HD:
            return c.createElement(cr, {
              name: r,
              value: t.toString(),
              originalValue: t,
              keyPath: n,
              deep: o,
              handleRemove: i,
              handleUpdateValue: s,
              readOnly: k,
              dataType: B,
              getStyle: m,
              cancelButtonElement: f,
              inputElementGenerator: g,
              minusMenuElement: E,
              logger: _,
              onSubmitValueParser: O,
            })
          default:
            return null
        }
      }
    }
    h(Wb, 'JsonNode')
    var fi = Wb
    fi.defaultProps = { keyPath: [], deep: 0 }
    const Yb = class extends Et {
      constructor(t) {
        super(t)
        const r = t.deep === -1 ? [] : [...(t.keyPath || []), t.name]
        ;((this.state = {
          name: t.name,
          data: t.data,
          keyPath: r ?? [],
          deep: t.deep ?? 0,
          nextDeep: (t.deep ?? 0) + 1,
          collapsed: t.isCollapsed(r, t.deep ?? 0, t.data),
          addFormVisible: !1,
        }),
          (this.handleCollapseMode = this.handleCollapseMode.bind(this)),
          (this.handleRemoveValue = this.handleRemoveValue.bind(this)),
          (this.handleAddMode = this.handleAddMode.bind(this)),
          (this.handleAddValueAdd = this.handleAddValueAdd.bind(this)),
          (this.handleAddValueCancel = this.handleAddValueCancel.bind(this)),
          (this.handleEditValue = this.handleEditValue.bind(this)),
          (this.onChildUpdate = this.onChildUpdate.bind(this)),
          (this.renderCollapsed = this.renderCollapsed.bind(this)),
          (this.renderNotCollapsed = this.renderNotCollapsed.bind(this)))
      }
      static getDerivedStateFromProps(t, r) {
        return t.data !== r.data ? { data: t.data } : null
      }
      onChildUpdate(t, r) {
        const { data: n, keyPath: o = [] } = this.state
        ;((n[t] = r), this.setState({ data: n }))
        const { onUpdate: a } = this.props
        const i = o.length
        a(o[i - 1], n)
      }
      handleAddMode() {
        this.setState({ addFormVisible: !0 })
      }
      handleAddValueCancel() {
        this.setState({ addFormVisible: !1 })
      }
      handleAddValueAdd({ key: t, newValue: r }) {
        const { data: n, keyPath: o = [], nextDeep: a } = this.state
        const { beforeAddAction: i, logger: s } = this.props
        ;(i || Promise.resolve.bind(Promise))(t, o, a, r)
          .then(() => {
            ;((n[t] = r),
              this.setState({ data: n }),
              this.handleAddValueCancel())
            const { onUpdate: l, onDeltaUpdate: u } = this.props
            ;(l(o[o.length - 1], n),
              u({ type: Mb, keyPath: o, deep: a, key: t, newValue: r }))
          })
          .catch(s.error)
      }
      handleRemoveValue(t) {
        return () => {
          const { beforeRemoveAction: r, logger: n } = this.props
          const { data: o, keyPath: a = [], nextDeep: i } = this.state
          const s = o[t]
          ;(r || Promise.resolve.bind(Promise))(t, a, i, s)
            .then(() => {
              const l = { keyPath: a, deep: i, key: t, oldValue: s, type: $b }
              ;(delete o[t], this.setState({ data: o }))
              const { onUpdate: u, onDeltaUpdate: d } = this.props
              ;(u(a[a.length - 1], o), d(l))
            })
            .catch(n.error)
        }
      }
      handleCollapseMode() {
        this.setState(t => ({ collapsed: !t.collapsed }))
      }
      handleEditValue({ key: t, value: r }) {
        return new Promise((n, o) => {
          const { beforeUpdateAction: a } = this.props
          const { data: i, keyPath: s = [], nextDeep: l } = this.state
          const u = i[t]
          ;(a || Promise.resolve.bind(Promise))(t, s, l, u, r)
            .then(() => {
              ;((i[t] = r), this.setState({ data: i }))
              const { onUpdate: d, onDeltaUpdate: m } = this.props
              ;(d(s[s.length - 1], i),
                m({
                  type: qb,
                  keyPath: s,
                  deep: l,
                  key: t,
                  newValue: r,
                  oldValue: u,
                }),
                n())
            })
            .catch(o)
        })
      }
      renderCollapsed() {
        const { name: t, keyPath: r, deep: n, data: o } = this.state
        const {
          handleRemove: a,
          readOnly: i,
          dataType: s,
          getStyle: l,
          minusMenuElement: u,
        } = this.props
        const { minus: d, collapsed: m } = l(t, o, r, n, s)
        const p = Object.getOwnPropertyNames(o)
        const f = i(t, o, r, n, s)
        const g =
          u &&
          Pe(u, {
            onClick: a,
            className: 'rejt-minus-menu',
            style: d,
            'aria-label': `remove the object '${t}'`,
          })
        return c.createElement(
          c.Fragment,
          null,
          c.createElement(
            'span',
            { style: m },
            '{...}',
            ' ',
            p.length,
            ' ',
            p.length === 1 ? 'key' : 'keys'
          ),
          !f && g
        )
      }
      renderNotCollapsed() {
        const {
          name: t,
          data: r,
          keyPath: n,
          deep: o,
          nextDeep: a,
          addFormVisible: i,
        } = this.state
        const {
          isCollapsed: s,
          handleRemove: l,
          onDeltaUpdate: u,
          readOnly: d,
          getStyle: m,
          dataType: p,
          addButtonElement: f,
          cancelButtonElement: g,
          inputElementGenerator: y,
          textareaElementGenerator: E,
          minusMenuElement: b,
          plusMenuElement: x,
          beforeRemoveAction: S,
          beforeAddAction: T,
          beforeUpdateAction: _,
          logger: O,
          onSubmitValueParser: k,
        } = this.props
        const {
          minus: B,
          plus: P,
          addForm: L,
          ul: j,
          delimiter: U,
        } = m(t, r, n, o, p)
        const $ = Object.getOwnPropertyNames(r)
        const v = d(t, r, n, o, p)
        const A =
          x &&
          Pe(x, {
            onClick: this.handleAddMode,
            className: 'rejt-plus-menu',
            style: P,
            'aria-label': `add a new property to the object '${t}'`,
          })
        const D =
          b &&
          Pe(b, {
            onClick: l,
            className: 'rejt-minus-menu',
            style: B,
            'aria-label': `remove the object '${t}'`,
          })
        const N = $.map(F =>
          c.createElement(fi, {
            key: F,
            name: F,
            data: r[F],
            keyPath: n,
            deep: a,
            isCollapsed: s,
            handleRemove: this.handleRemoveValue(F),
            handleUpdateValue: this.handleEditValue,
            onUpdate: this.onChildUpdate,
            onDeltaUpdate: u,
            readOnly: d,
            getStyle: m,
            addButtonElement: f,
            cancelButtonElement: g,
            inputElementGenerator: y,
            textareaElementGenerator: E,
            minusMenuElement: b,
            plusMenuElement: x,
            beforeRemoveAction: S,
            beforeAddAction: T,
            beforeUpdateAction: _,
            logger: O,
            onSubmitValueParser: k,
          })
        )
        return c.createElement(
          c.Fragment,
          null,
          c.createElement(
            'span',
            { className: 'rejt-not-collapsed-delimiter', style: U },
            '{'
          ),
          !v && A,
          c.createElement(
            'ul',
            { className: 'rejt-not-collapsed-list', style: j },
            N
          ),
          !v &&
            i &&
            c.createElement(
              'div',
              { className: 'rejt-add-form', style: L },
              c.createElement(lc, {
                handleAdd: this.handleAddValueAdd,
                handleCancel: this.handleAddValueCancel,
                addButtonElement: f,
                cancelButtonElement: g,
                inputElementGenerator: y,
                keyPath: n,
                deep: o,
                onSubmitValueParser: k,
              })
            ),
          c.createElement(
            'span',
            { className: 'rejt-not-collapsed-delimiter', style: U },
            '}'
          ),
          !v && D
        )
      }
      render() {
        const { name: t, collapsed: r, keyPath: n, deep: o = 0 } = this.state
        const a = r ? this.renderCollapsed() : this.renderNotCollapsed()
        return c.createElement(
          ac,
          {
            name: t,
            collapsed: r,
            deep: o,
            keyPath: n,
            onClick: this.handleCollapseMode,
          },
          a
        )
      }
    }
    h(Yb, 'JsonObject')
    var Ou = Yb
    Ou.defaultProps = {
      keyPath: [],
      deep: 0,
      minusMenuElement: c.createElement('span', null, ' - '),
      plusMenuElement: c.createElement('span', null, ' + '),
    }
    const Kb = class extends Et {
      constructor(t) {
        super(t)
        const r = [...(t.keyPath || []), t.name]
        ;((this.state = {
          value: t.value,
          name: t.name,
          keyPath: r ?? [],
          deep: t.deep ?? 0,
          editEnabled: !1,
          inputRef: null,
        }),
          (this.handleEditMode = this.handleEditMode.bind(this)),
          (this.refInput = this.refInput.bind(this)),
          (this.handleCancelEdit = this.handleCancelEdit.bind(this)),
          (this.handleEdit = this.handleEdit.bind(this)),
          (this.onKeydown = this.onKeydown.bind(this)))
      }
      static getDerivedStateFromProps(t, r) {
        return t.value !== r.value ? { value: t.value } : null
      }
      componentDidUpdate() {
        const {
          editEnabled: t,
          inputRef: r,
          name: n,
          value: o,
          keyPath: a,
          deep: i,
        } = this.state
        const { readOnly: s, dataType: l } = this.props
        const u = s(n, o, a, i, l)
        t && !u && typeof r.focus === 'function' && r.focus()
      }
      onKeydown(t) {
        const { inputRef: r } = this.state
        t.altKey ||
          t.ctrlKey ||
          t.metaKey ||
          t.shiftKey ||
          t.repeat ||
          r !== t.target ||
          ((t.code === 'Enter' || t.key === 'Enter') &&
            (t.preventDefault(), this.handleEdit()),
          (t.code === 'Escape' || t.key === 'Escape') &&
            (t.preventDefault(), this.handleCancelEdit()))
      }
      handleEdit() {
        const {
          handleUpdateValue: t,
          originalValue: r,
          logger: n,
          onSubmitValueParser: o,
          keyPath: a,
        } = this.props
        const { inputRef: i, name: s, deep: l } = this.state
        if (!i) return
        const u = o(!0, a, l, s, i.value)
        const d = { value: u, key: s }
        ;(t || Promise.resolve.bind(Promise))(d)
          .then(() => {
            sc(r, u) || this.handleCancelEdit()
          })
          .catch(n.error)
      }
      handleEditMode() {
        this.setState({ editEnabled: !0 })
      }
      refInput(t) {
        this.state.inputRef = t
      }
      handleCancelEdit() {
        this.setState({ editEnabled: !1 })
      }
      render() {
        const {
          name: t,
          value: r,
          editEnabled: n,
          keyPath: o,
          deep: a,
        } = this.state
        const {
          handleRemove: i,
          originalValue: s,
          readOnly: l,
          dataType: u,
          getStyle: d,
          inputElementGenerator: m,
          minusMenuElement: p,
          keyPath: f,
        } = this.props
        const g = d(t, s, o, a, u)
        const y = l(t, s, o, a, u)
        const E = n && !y
        const b = m(ic, f, a, t, s, u)
        const x = Pe(b, {
          ref: this.refInput,
          defaultValue: JSON.stringify(s),
          onKeyDown: this.onKeydown,
        })
        const S = o.at(-2)
        const T =
          p &&
          Pe(p, {
            onClick: i,
            className: 'rejt-minus-menu',
            style: g.minus,
            'aria-label': `remove the property '${t}' with value '${s}'${S ? ` from '${S}'` : ''}`,
          })
        return c.createElement(
          'li',
          { className: 'rejt-value-node', style: g.li },
          c.createElement(
            'span',
            { className: 'rejt-name', style: g.name },
            t,
            ' : '
          ),
          E
            ? c.createElement(
                'span',
                { className: 'rejt-edit-form', style: g.editForm },
                x
              )
            : c.createElement(
                'span',
                {
                  className: 'rejt-value',
                  style: g.value,
                  onClick: y ? void 0 : this.handleEditMode,
                },
                String(r)
              ),
          !y && !E && T
        )
      }
    }
    h(Kb, 'JsonValue')
    var cr = Kb
    cr.defaultProps = {
      keyPath: [],
      deep: 0,
      handleUpdateValue: h(() => Promise.resolve(), 'handleUpdateValue'),
      cancelButtonElement: c.createElement('button', null, 'c'),
      minusMenuElement: c.createElement('span', null, ' - '),
    }
    function Xb(e) {
      let t = e
      if (t.indexOf('function') === 0) return (0, eval)(`(${t})`)
      try {
        t = JSON.parse(e)
      } catch {}
      return t
    }
    h(Xb, 'parse')
    const zD = {
      minus: { color: 'red' },
      plus: { color: 'green' },
      collapsed: { color: 'grey' },
      delimiter: {},
      ul: { padding: '0px', margin: '0 0 0 25px', listStyle: 'none' },
      name: { color: '#2287CD' },
      addForm: {},
    }
    const GD = {
      minus: { color: 'red' },
      plus: { color: 'green' },
      collapsed: { color: 'grey' },
      delimiter: {},
      ul: { padding: '0px', margin: '0 0 0 25px', listStyle: 'none' },
      name: { color: '#2287CD' },
      addForm: {},
    }
    const WD = {
      minus: { color: 'red' },
      editForm: {},
      value: { color: '#7bba3d' },
      li: { minHeight: '22px', lineHeight: '22px', outline: '0px' },
      name: { color: '#2287CD' },
    }
    const Jb = class extends Et {
      constructor(t) {
        ;(super(t),
          (this.state = { data: t.data, rootName: t.rootName }),
          (this.onUpdate = this.onUpdate.bind(this)),
          (this.removeRoot = this.removeRoot.bind(this)))
      }
      static getDerivedStateFromProps(t, r) {
        return t.data !== r.data || t.rootName !== r.rootName
          ? { data: t.data, rootName: t.rootName }
          : null
      }
      onUpdate(t, r) {
        ;(this.setState({ data: r }), this.props.onFullyUpdate?.(r))
      }
      removeRoot() {
        this.onUpdate(null, null)
      }
      render() {
        const { data: t, rootName: r } = this.state
        const {
          isCollapsed: n,
          onDeltaUpdate: o,
          readOnly: a,
          getStyle: i,
          addButtonElement: s,
          cancelButtonElement: l,
          inputElement: u,
          textareaElement: d,
          minusMenuElement: m,
          plusMenuElement: p,
          beforeRemoveAction: f,
          beforeAddAction: g,
          beforeUpdateAction: y,
          logger: E,
          onSubmitValueParser: b,
          fallback: x = null,
        } = this.props
        const S = hr(t)
        let T = a
        hr(a) === 'Boolean' && (T = h(() => a, 'readOnlyFunction'))
        let _ = u
        u && hr(u) !== 'Function' && (_ = h(() => u, 'inputElementFunction'))
        let O = d
        return (
          d &&
            hr(d) !== 'Function' &&
            (O = h(() => d, 'textareaElementFunction')),
          S === 'Object' || S === 'Array'
            ? c.createElement(
                'div',
                { className: 'rejt-tree' },
                c.createElement(fi, {
                  data: t,
                  name: r || 'root',
                  deep: -1,
                  isCollapsed: n ?? (() => !1),
                  onUpdate: this.onUpdate,
                  onDeltaUpdate: o ?? (() => {}),
                  readOnly: T,
                  getStyle: i ?? (() => ({})),
                  addButtonElement: s,
                  cancelButtonElement: l,
                  inputElementGenerator: _,
                  textareaElementGenerator: O,
                  minusMenuElement: m,
                  plusMenuElement: p,
                  handleRemove: this.removeRoot,
                  beforeRemoveAction: f,
                  beforeAddAction: g,
                  beforeUpdateAction: y,
                  logger: E ?? {},
                  onSubmitValueParser: b ?? (k => k),
                })
              )
            : x
        )
      }
    }
    h(Jb, 'JsonTree')
    const Zb = Jb
    Zb.defaultProps = {
      rootName: 'root',
      isCollapsed: h((e, t) => t !== -1, 'isCollapsed'),
      getStyle: h((e, t, r, n, o) => {
        switch (o) {
          case 'Object':
          case 'Error':
            return zD
          case 'Array':
            return GD
          default:
            return WD
        }
      }, 'getStyle'),
      readOnly: h(() => !1, 'readOnly'),
      onFullyUpdate: h(() => {}, 'onFullyUpdate'),
      onDeltaUpdate: h(() => {}, 'onDeltaUpdate'),
      beforeRemoveAction: h(() => Promise.resolve(), 'beforeRemoveAction'),
      beforeAddAction: h(() => Promise.resolve(), 'beforeAddAction'),
      beforeUpdateAction: h(() => Promise.resolve(), 'beforeUpdateAction'),
      logger: { error: h(() => {}, 'error') },
      onSubmitValueParser: h((e, t, r, n, o) => Xb(o), 'onSubmitValueParser'),
      inputElement: h(() => c.createElement('input', null), 'inputElement'),
      textareaElement: h(
        () => c.createElement('textarea', null),
        'textareaElement'
      ),
      fallback: null,
    }
    const { window: YD } = globalThis
    const KD = R.div(({ theme: e }) => ({
      position: 'relative',
      display: 'flex',
      '&[aria-readonly="true"]': { opacity: 0.5 },
      '.rejt-tree': {
        marginLeft: '1rem',
        fontSize: '13px',
        listStyleType: 'none',
      },
      '.rejt-value-node:hover': { '& > button': { opacity: 1 } },
      '.rejt-add-form': { marginLeft: 10 },
      '.rejt-add-value-node': { display: 'inline-flex', alignItems: 'center' },
      '.rejt-name': { lineHeight: '22px' },
      '.rejt-not-collapsed-delimiter': { lineHeight: '22px' },
      '.rejt-value': {
        display: 'inline-block',
        border: '1px solid transparent',
        borderRadius: 4,
        margin: '1px 0',
        padding: '0 4px',
        cursor: 'text',
        color: e.color.defaultText,
      },
      '.rejt-value-node:hover > .rejt-value': {
        background: e.color.lighter,
        borderColor: e.appBorderColor,
      },
    }))
    const f0 = R.button(({ theme: e, primary: t }) => ({
      border: 0,
      height: 20,
      margin: 1,
      borderRadius: 4,
      background: t ? e.color.secondary : 'transparent',
      color: t ? e.color.lightest : e.color.dark,
      fontWeight: t ? 'bold' : 'normal',
      cursor: 'pointer',
    }))
    const g0 = R.button(({ theme: e }) => ({
      background: 'none',
      border: 0,
      display: 'inline-flex',
      verticalAlign: 'middle',
      padding: 3,
      marginLeft: 5,
      color: e.textMutedColor,
      opacity: 0,
      transition: 'opacity 0.2s',
      cursor: 'pointer',
      position: 'relative',
      svg: { width: 9, height: 9 },
      ':disabled': { cursor: 'not-allowed' },
      ':hover, :focus-visible': { opacity: 1 },
      '&:hover:not(:disabled), &:focus-visible:not(:disabled)': {
        '&.rejt-plus-menu': { color: e.color.ancillary },
        '&.rejt-minus-menu': { color: e.color.negative },
      },
    }))
    const y0 = R.input(({ theme: e, placeholder: t }) => ({
      outline: 0,
      margin: t ? 1 : '1px 0',
      padding: '3px 4px',
      color: e.color.defaultText,
      background: e.background.app,
      border: `1px solid ${e.appBorderColor}`,
      borderRadius: 4,
      lineHeight: '14px',
      width: t === 'Key' ? 80 : 120,
      '&:focus': { border: `1px solid ${e.color.secondary}` },
    }))
    const XD = R(ce)(({ theme: e }) => ({
      position: 'absolute',
      zIndex: 2,
      top: 2,
      right: 2,
      height: 21,
      padding: '0 3px',
      background: e.background.bar,
      border: `1px solid ${e.appBorderColor}`,
      borderRadius: 3,
      color: e.textMutedColor,
      fontSize: '9px',
      fontWeight: 'bold',
      textDecoration: 'none',
      span: { marginLeft: 3, marginTop: 1 },
    }))
    const JD = R($e.Textarea)(({ theme: e }) => ({
      flex: 1,
      padding: '7px 6px',
      fontFamily: e.typography.fonts.mono,
      fontSize: '12px',
      lineHeight: '18px',
      '&::placeholder': {
        fontFamily: e.typography.fonts.base,
        fontSize: '13px',
      },
      '&:placeholder-shown': { padding: '7px 10px' },
    }))
    const ZD = {
      bubbles: !0,
      cancelable: !0,
      key: 'Enter',
      code: 'Enter',
      keyCode: 13,
    }
    const QD = h(e => {
      e.currentTarget.dispatchEvent(new YD.KeyboardEvent('keydown', ZD))
    }, 'dispatchEnterKey')
    const e3 = h(e => {
      e.currentTarget.select()
    }, 'selectValue')
    const t3 = h(
      e => () => ({
        name: { color: e.color.secondary },
        collapsed: { color: e.color.dark },
        ul: { listStyle: 'none', margin: '0 0 0 1rem', padding: 0 },
        li: { outline: 0 },
      }),
      'getCustomStyleFunction'
    )
    const b0 = h(({ name: e, value: t, onChange: r, argType: n }) => {
      const o = Qe()
      const a = Me(() => t && by(t), [t])
      const i = a != null
      const [s, l] = z(!i)
      const [u, d] = z(null)
      const m = !!n?.table?.readonly
      const p = Q(
        S => {
          try {
            ;(S && r(JSON.parse(S)), d(null))
          } catch (T) {
            d(T)
          }
        },
        [r]
      )
      const [f, g] = z(!1)
      const y = Q(() => {
        ;(r({}), g(!0))
      }, [g])
      const E = ye(null)
      if (
        (X(() => {
          f && E.current && E.current.select()
        }, [f]),
        !i)
      )
        return c.createElement(
          Je,
          { disabled: m, id: so(e), onClick: y },
          'Set object'
        )
      const b = c.createElement(JD, {
        ref: E,
        id: mt(e),
        name: e,
        defaultValue: t === null ? '' : JSON.stringify(t, null, 2),
        onBlur: S => p(S.target.value),
        placeholder: 'Edit JSON string...',
        autoFocus: f,
        valid: u ? 'error' : void 0,
        readOnly: m,
      })
      const x =
        Array.isArray(t) || (typeof t === 'object' && t?.constructor === Object)
      return c.createElement(
        KD,
        { 'aria-readonly': m },
        x &&
          c.createElement(
            XD,
            {
              role: 'switch',
              'aria-checked': s,
              'aria-label': `Edit the ${e} properties in text format`,
              onClick: S => {
                ;(S.preventDefault(), l(T => !T))
              },
            },
            s ? c.createElement(Tc, null) : c.createElement(kc, null),
            c.createElement('span', null, 'RAW')
          ),
        s
          ? b
          : c.createElement(Zb, {
              readOnly: m || !x,
              isCollapsed: x ? void 0 : () => !0,
              data: a,
              rootName: e,
              onFullyUpdate: r,
              getStyle: t3(o),
              cancelButtonElement: c.createElement(
                f0,
                { type: 'button' },
                'Cancel'
              ),
              addButtonElement: c.createElement(
                f0,
                { type: 'submit', primary: !0 },
                'Save'
              ),
              plusMenuElement: c.createElement(
                g0,
                { type: 'button' },
                c.createElement(go, null)
              ),
              minusMenuElement: c.createElement(
                g0,
                { type: 'button' },
                c.createElement(Hc, null)
              ),
              inputElement: (S, T, _, O) =>
                O
                  ? c.createElement(y0, { onFocus: e3, onBlur: QD })
                  : c.createElement(y0, null),
              fallback: b,
            })
      )
    }, 'ObjectControl')
    Ot()
    const r3 = R.input(
      ({ theme: e, min: t, max: r, value: n, disabled: o }) => ({
        '&': {
          width: '100%',
          backgroundColor: 'transparent',
          appearance: 'none',
        },
        '&::-webkit-slider-runnable-track': {
          background:
            e.base === 'light'
              ? `linear-gradient(to right, 
            ${e.color.green} 0%, ${e.color.green} ${((n - t) / (r - t)) * 100}%, 
            ${Nt(0.02, e.input.background)} ${((n - t) / (r - t)) * 100}%, 
            ${Nt(0.02, e.input.background)} 100%)`
              : `linear-gradient(to right, 
            ${e.color.green} 0%, ${e.color.green} ${((n - t) / (r - t)) * 100}%, 
            ${Or(0.02, e.input.background)} ${((n - t) / (r - t)) * 100}%, 
            ${Or(0.02, e.input.background)} 100%)`,
          boxShadow: `${e.appBorderColor} 0 0 0 1px inset`,
          borderRadius: 6,
          width: '100%',
          height: 6,
          cursor: o ? 'not-allowed' : 'pointer',
        },
        '&::-webkit-slider-thumb': {
          marginTop: '-6px',
          width: 16,
          height: 16,
          border: `1px solid ${Tt(e.appBorderColor, 0.2)}`,
          borderRadius: '50px',
          boxShadow: `0 1px 3px 0px ${Tt(e.appBorderColor, 0.2)}`,
          cursor: o ? 'not-allowed' : 'grab',
          appearance: 'none',
          background: `${e.input.background}`,
          transition: 'all 150ms ease-out',
          '&:hover': {
            background: `${Nt(0.05, e.input.background)}`,
            transform: 'scale3d(1.1, 1.1, 1.1) translateY(-1px)',
            transition: 'all 50ms ease-out',
          },
          '&:active': {
            background: `${e.input.background}`,
            transform: 'scale3d(1, 1, 1) translateY(0px)',
            cursor: o ? 'not-allowed' : 'grab',
          },
        },
        '&:focus': {
          outline: 'none',
          '&::-webkit-slider-runnable-track': {
            borderColor: Tt(e.color.secondary, 0.4),
          },
          '&::-webkit-slider-thumb': {
            borderColor: e.color.secondary,
            boxShadow: `0 0px 5px 0px ${e.color.secondary}`,
          },
        },
        '&::-moz-range-track': {
          background:
            e.base === 'light'
              ? `linear-gradient(to right, 
            ${e.color.green} 0%, ${e.color.green} ${((n - t) / (r - t)) * 100}%, 
            ${Nt(0.02, e.input.background)} ${((n - t) / (r - t)) * 100}%, 
            ${Nt(0.02, e.input.background)} 100%)`
              : `linear-gradient(to right, 
            ${e.color.green} 0%, ${e.color.green} ${((n - t) / (r - t)) * 100}%, 
            ${Or(0.02, e.input.background)} ${((n - t) / (r - t)) * 100}%, 
            ${Or(0.02, e.input.background)} 100%)`,
          boxShadow: `${e.appBorderColor} 0 0 0 1px inset`,
          borderRadius: 6,
          width: '100%',
          height: 6,
          cursor: o ? 'not-allowed' : 'pointer',
          outline: 'none',
        },
        '&::-moz-range-thumb': {
          width: 16,
          height: 16,
          border: `1px solid ${Tt(e.appBorderColor, 0.2)}`,
          borderRadius: '50px',
          boxShadow: `0 1px 3px 0px ${Tt(e.appBorderColor, 0.2)}`,
          cursor: o ? 'not-allowed' : 'grap',
          background: `${e.input.background}`,
          transition: 'all 150ms ease-out',
          '&:hover': {
            background: `${Nt(0.05, e.input.background)}`,
            transform: 'scale3d(1.1, 1.1, 1.1) translateY(-1px)',
            transition: 'all 50ms ease-out',
          },
          '&:active': {
            background: `${e.input.background}`,
            transform: 'scale3d(1, 1, 1) translateY(0px)',
            cursor: 'grabbing',
          },
        },
        '&::-ms-track': {
          background:
            e.base === 'light'
              ? `linear-gradient(to right, 
            ${e.color.green} 0%, ${e.color.green} ${((n - t) / (r - t)) * 100}%, 
            ${Nt(0.02, e.input.background)} ${((n - t) / (r - t)) * 100}%, 
            ${Nt(0.02, e.input.background)} 100%)`
              : `linear-gradient(to right, 
            ${e.color.green} 0%, ${e.color.green} ${((n - t) / (r - t)) * 100}%, 
            ${Or(0.02, e.input.background)} ${((n - t) / (r - t)) * 100}%, 
            ${Or(0.02, e.input.background)} 100%)`,
          boxShadow: `${e.appBorderColor} 0 0 0 1px inset`,
          color: 'transparent',
          width: '100%',
          height: '6px',
          cursor: 'pointer',
        },
        '&::-ms-fill-lower': { borderRadius: 6 },
        '&::-ms-fill-upper': { borderRadius: 6 },
        '&::-ms-thumb': {
          width: 16,
          height: 16,
          background: `${e.input.background}`,
          border: `1px solid ${Tt(e.appBorderColor, 0.2)}`,
          borderRadius: 50,
          cursor: 'grab',
          marginTop: 0,
        },
        '@supports (-ms-ime-align:auto)': {
          'input[type=range]': { margin: '0' },
        },
      })
    )
    const Qb = R.span({
      paddingLeft: 5,
      paddingRight: 5,
      fontSize: 12,
      whiteSpace: 'nowrap',
      fontFeatureSettings: 'tnum',
      fontVariantNumeric: 'tabular-nums',
      '[aria-readonly=true] &': { opacity: 0.5 },
    })
    const n3 = R(Qb)(({ numberOFDecimalsPlaces: e, max: t }) => ({
      width: `${e + t.toString().length * 2 + 3}ch`,
      textAlign: 'right',
      flexShrink: 0,
    }))
    const o3 = R.div({ display: 'flex', alignItems: 'center', width: '100%' })
    function e1(e) {
      const t = e.toString().match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/)
      return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0
    }
    h(e1, 'getNumberOfDecimalPlaces')
    const a3 = h(
      ({
        name: e,
        value: t,
        onChange: r,
        min: n = 0,
        max: o = 100,
        step: a = 1,
        onBlur: i,
        onFocus: s,
        argType: l,
      }) => {
        const u = h(f => {
          r(gD(f.target.value))
        }, 'handleChange')
        const d = t !== void 0
        const m = Me(() => e1(a), [a])
        const p = !!l?.table?.readonly
        return c.createElement(
          o3,
          { 'aria-readonly': p },
          c.createElement(Qb, null, n),
          c.createElement(r3, {
            id: mt(e),
            type: 'range',
            disabled: p,
            onChange: u,
            name: e,
            min: n,
            max: o,
            step: a,
            onFocus: s,
            onBlur: i,
            value: t ?? n,
          }),
          c.createElement(
            n3,
            { numberOFDecimalsPlaces: m, max: o },
            d ? t.toFixed(m) : '--',
            ' / ',
            o
          )
        )
      },
      'RangeControl'
    )
    Ot()
    const i3 = R.label({ display: 'flex' })
    const s3 = R.div(({ isMaxed: e }) => ({
      marginLeft: '0.75rem',
      paddingTop: '0.35rem',
      color: e ? 'red' : void 0,
    }))
    const l3 = h(
      ({
        name: e,
        value: t,
        onChange: r,
        onFocus: n,
        onBlur: o,
        maxLength: a,
        argType: i,
      }) => {
        const s = h(f => {
          r(f.target.value)
        }, 'handleChange')
        const l = !!i?.table?.readonly
        const [u, d] = z(!1)
        const m = Q(() => {
          ;(r(''), d(!0))
        }, [d])
        if (t === void 0)
          return c.createElement(
            Je,
            {
              variant: 'outline',
              size: 'medium',
              disabled: l,
              id: so(e),
              onClick: m,
            },
            'Set string'
          )
        const p = typeof t === 'string'
        return c.createElement(
          i3,
          null,
          c.createElement($e.Textarea, {
            id: mt(e),
            maxLength: a,
            onChange: s,
            disabled: l,
            size: 'flex',
            placeholder: 'Edit string...',
            autoFocus: u,
            valid: p ? void 0 : 'error',
            name: e,
            value: p ? t : '',
            onFocus: n,
            onBlur: o,
          }),
          a &&
            c.createElement(
              s3,
              { isMaxed: t?.length === a },
              t?.length ?? 0,
              ' / ',
              a
            )
        )
      },
      'TextControl'
    )
    Ot()
    const u3 = R($e.Input)({ padding: 10 })
    function t1(e) {
      e.forEach(t => {
        t.startsWith('blob:') && URL.revokeObjectURL(t)
      })
    }
    h(t1, 'revokeOldUrls')
    const c3 = h(
      ({
        onChange: e,
        name: t,
        accept: r = 'image/*',
        value: n,
        argType: o,
      }) => {
        const a = ye(null)
        const i = o?.control?.readOnly
        function s(l) {
          if (!l.target.files) return
          const u = Array.from(l.target.files).map(d => URL.createObjectURL(d))
          ;(e(u), t1(n || []))
        }
        return (
          h(s, 'handleFileChange'),
          X(() => {
            n == null && a.current && (a.current.value = '')
          }, [n, t]),
          c.createElement(u3, {
            ref: a,
            id: mt(t),
            type: 'file',
            name: t,
            multiple: !0,
            disabled: i,
            onChange: s,
            accept: r,
            size: 'flex',
          })
        )
      },
      'FilesControl'
    )
    const d3 = Ac(() => Promise.resolve().then(() => (lC(), Ny)))
    const p3 = h(
      e =>
        c.createElement(
          Ec,
          { fallback: c.createElement('div', null) },
          c.createElement(d3, { ...e })
        ),
      'ColorControl'
    )
    const m3 = {
      array: b0,
      object: b0,
      boolean: lD,
      color: p3,
      date: hD,
      number: bD,
      check: fn,
      'inline-check': fn,
      radio: fn,
      'inline-radio': fn,
      select: fn,
      'multi-select': fn,
      range: a3,
      text: l3,
      file: c3,
    }
    const E0 = h(() => c.createElement(c.Fragment, null, '-'), 'NoControl')
    const h3 = h(({ row: e, arg: t, updateArgs: r, isHovered: n }) => {
      const { key: o, control: a } = e
      const [i, s] = z(!1)
      const [l, u] = z({ value: t })
      X(() => {
        i || u({ value: t })
      }, [i, t])
      const d = Q(y => (u({ value: y }), r({ [o]: y }), y), [r, o])
      const m = Q(() => s(!1), [])
      const p = Q(() => s(!0), [])
      if (!a || a.disable) {
        const y = a?.disable !== !0 && e?.type?.name !== 'function'
        return n && y
          ? c.createElement(
              Ze,
              {
                href: 'https://storybook.js.org/docs/essentials/controls',
                target: '_blank',
                withArrow: !0,
              },
              'Setup controls'
            )
          : c.createElement(E0, null)
      }
      const f = {
        name: o,
        argType: e,
        value: l.value,
        onChange: d,
        onBlur: m,
        onFocus: p,
      }
      const g = m3[a.type] || E0
      return c.createElement(g, { ...f, ...a, controlType: a.type })
    }, 'ArgControl')
    const f3 = R.table(({ theme: e }) => ({
      '&&': {
        borderCollapse: 'collapse',
        borderSpacing: 0,
        border: 'none',
        tr: { border: 'none !important', background: 'none' },
        'td, th': { padding: 0, border: 'none', width: 'auto!important' },
        marginTop: 0,
        marginBottom: 0,
        'th:first-of-type, td:first-of-type': { paddingLeft: 0 },
        'th:last-of-type, td:last-of-type': { paddingRight: 0 },
        td: {
          paddingTop: 0,
          paddingBottom: 4,
          '&:not(:first-of-type)': { paddingLeft: 10, paddingRight: 0 },
        },
        tbody: { boxShadow: 'none', border: 'none' },
        code: Qt({ theme: e }),
        div: { span: { fontWeight: 'bold' } },
        '& code': {
          margin: 0,
          display: 'inline-block',
          fontSize: e.typography.size.s1,
        },
      },
    }))
    const g3 = h(({ tags: e }) => {
      const t = (e.params || []).filter(a => a.description)
      const r = t.length !== 0
      const n = e.deprecated != null
      const o = e.returns != null && e.returns.description != null
      return !r && !o && !n
        ? null
        : c.createElement(
            c.Fragment,
            null,
            c.createElement(
              f3,
              null,
              c.createElement(
                'tbody',
                null,
                n &&
                  c.createElement(
                    'tr',
                    { key: 'deprecated' },
                    c.createElement(
                      'td',
                      { colSpan: 2 },
                      c.createElement('strong', null, 'Deprecated'),
                      ': ',
                      e.deprecated?.toString()
                    )
                  ),
                r &&
                  t.map(a =>
                    c.createElement(
                      'tr',
                      { key: a.name },
                      c.createElement(
                        'td',
                        null,
                        c.createElement('code', null, a.name)
                      ),
                      c.createElement('td', null, a.description)
                    )
                  ),
                o &&
                  c.createElement(
                    'tr',
                    { key: 'returns' },
                    c.createElement(
                      'td',
                      null,
                      c.createElement('code', null, 'Returns')
                    ),
                    c.createElement('td', null, e.returns?.description)
                  )
              )
            )
          )
    }, 'ArgJsDoc')
    pi()
    const y3 = it(uC())
    const Iu = 8
    const v0 = R.div(({ isExpanded: e }) => ({
      display: 'flex',
      flexDirection: e ? 'column' : 'row',
      flexWrap: 'wrap',
      alignItems: 'flex-start',
      marginBottom: '-4px',
      minWidth: 100,
    }))
    const b3 = R.span(Qt, ({ theme: e, simple: t = !1 }) => ({
      flex: '0 0 auto',
      fontFamily: e.typography.fonts.mono,
      fontSize: e.typography.size.s1,
      wordBreak: 'break-word',
      whiteSpace: 'normal',
      maxWidth: '100%',
      margin: 0,
      marginRight: '4px',
      marginBottom: '4px',
      paddingTop: '2px',
      paddingBottom: '2px',
      lineHeight: '13px',
      ...(t && { background: 'transparent', border: '0 none', paddingLeft: 0 }),
    }))
    const E3 = R.button(({ theme: e }) => ({
      fontFamily: e.typography.fonts.mono,
      color: e.color.secondary,
      marginBottom: '4px',
      background: 'none',
      border: 'none',
    }))
    const v3 = R.div(Qt, ({ theme: e }) => ({
      fontFamily: e.typography.fonts.mono,
      color: e.color.secondary,
      fontSize: e.typography.size.s1,
      margin: 0,
      whiteSpace: 'nowrap',
      display: 'flex',
      alignItems: 'center',
    }))
    const A3 = R.div(({ theme: e, width: t }) => ({
      width: t,
      minWidth: 200,
      maxWidth: 800,
      padding: 15,
      fontFamily: e.typography.fonts.mono,
      fontSize: e.typography.size.s1,
      boxSizing: 'content-box',
      '& code': { padding: '0 !important' },
    }))
    const x3 = R(Cc)({ marginLeft: 4 })
    const w3 = R(Eo)({ marginLeft: 4 })
    const S3 = h(() => c.createElement('span', null, '-'), 'EmptyArg')
    const r1 = h(
      ({ text: e, simple: t }) => c.createElement(b3, { simple: t }, e),
      'ArgText'
    )
    const C3 = (0, y3.default)(1e3)(e => {
      const t = e.split(/\r?\n/)
      return `${Math.max(...t.map(r => r.length))}ch`
    })
    const D3 = h(e => {
      if (!e) return [e]
      const t = e.split('|').map(r => r.trim())
      return vy(t)
    }, 'getSummaryItems')
    const A0 = h((e, t = !0) => {
      let r = e
      return (
        t || (r = e.slice(0, Iu)),
        r.map(n => c.createElement(r1, { key: n, text: n === '' ? '""' : n }))
      )
    }, 'renderSummaryItems')
    const T3 = h(({ value: e, initialExpandedArgs: t }) => {
      const { summary: r, detail: n } = e
      const [o, a] = z(!1)
      const [i, s] = z(t || !1)
      if (r == null) return null
      const l = typeof r.toString === 'function' ? r.toString() : r
      if (n == null) {
        if (/[(){}[\]<>]/.test(l)) return c.createElement(r1, { text: l })
        const u = D3(l)
        const d = u.length
        return d > Iu
          ? c.createElement(
              v0,
              { isExpanded: i },
              A0(u, i),
              c.createElement(
                E3,
                { onClick: () => s(!i) },
                i ? 'Show less...' : `Show ${d - Iu} more...`
              )
            )
          : c.createElement(v0, null, A0(u))
      }
      return c.createElement(
        Di,
        {
          closeOnOutsideClick: !0,
          placement: 'bottom',
          visible: o,
          onVisibleChange: u => {
            a(u)
          },
          tooltip: c.createElement(
            A3,
            { width: C3(n) },
            c.createElement(On, { language: 'jsx', format: !1 }, n)
          ),
        },
        c.createElement(
          v3,
          { className: 'sbdocs-expandable' },
          c.createElement('span', null, l),
          o ? c.createElement(x3, null) : c.createElement(w3, null)
        )
      )
    }, 'ArgSummary')
    const ou = h(
      ({ value: e, initialExpandedArgs: t }) =>
        e == null
          ? c.createElement(S3, null)
          : c.createElement(T3, { value: e, initialExpandedArgs: t }),
      'ArgValue'
    )
    const k3 = R.span({ fontWeight: 'bold' })
    const O3 = R.span(({ theme: e }) => ({
      color: e.color.negative,
      fontFamily: e.typography.fonts.mono,
      cursor: 'help',
    }))
    const I3 = R.div(({ theme: e }) => ({
      '&&': { p: { margin: '0 0 10px 0' }, a: { color: e.color.secondary } },
      code: {
        ...Qt({ theme: e }),
        fontSize: 12,
        fontFamily: e.typography.fonts.mono,
      },
      '& code': { margin: 0, display: 'inline-block' },
      '& pre > code': { whiteSpace: 'pre-wrap' },
    }))
    const R3 = R.div(({ theme: e, hasDescription: t }) => ({
      color:
        e.base === 'light'
          ? de(0.1, e.color.defaultText)
          : de(0.2, e.color.defaultText),
      marginTop: t ? 4 : 0,
    }))
    const B3 = R.div(({ theme: e, hasDescription: t }) => ({
      color:
        e.base === 'light'
          ? de(0.1, e.color.defaultText)
          : de(0.2, e.color.defaultText),
      marginTop: t ? 12 : 0,
      marginBottom: 12,
    }))
    const _3 = R.td(({ expandable: e }) => ({
      paddingLeft: e ? '40px !important' : '20px !important',
    }))
    const F3 = h(
      e => e && { summary: typeof e === 'string' ? e : e.name },
      'toSummary'
    )
    const Ha = h(e => {
      const [t, r] = z(!1)
      const {
        row: n,
        updateArgs: o,
        compact: a,
        expandable: i,
        initialExpandedArgs: s,
      } = e
      const { name: l, description: u } = n
      const d = n.table || {}
      const m = d.type || F3(n.type)
      const p = d.defaultValue || n.defaultValue
      const f = n.type?.required
      const g = u != null && u !== ''
      return c.createElement(
        'tr',
        { onMouseEnter: () => r(!0), onMouseLeave: () => r(!1) },
        c.createElement(
          _3,
          { expandable: i ?? !1 },
          c.createElement(k3, null, l),
          f ? c.createElement(O3, { title: 'Required' }, '*') : null
        ),
        a
          ? null
          : c.createElement(
              'td',
              null,
              g && c.createElement(I3, null, c.createElement(aD, null, u)),
              d.jsDocTags != null
                ? c.createElement(
                    c.Fragment,
                    null,
                    c.createElement(
                      B3,
                      { hasDescription: g },
                      c.createElement(ou, { value: m, initialExpandedArgs: s })
                    ),
                    c.createElement(g3, { tags: d.jsDocTags })
                  )
                : c.createElement(
                    R3,
                    { hasDescription: g },
                    c.createElement(ou, { value: m, initialExpandedArgs: s })
                  )
            ),
        a
          ? null
          : c.createElement(
              'td',
              null,
              c.createElement(ou, { value: p, initialExpandedArgs: s })
            ),
        o
          ? c.createElement(
              'td',
              null,
              c.createElement(h3, { ...e, isHovered: t })
            )
          : null
      )
    }, 'ArgRow')
    const P3 = R.div(({ inAddonPanel: e, theme: t }) => ({
      height: e ? '100%' : 'auto',
      display: 'flex',
      border: e ? 'none' : `1px solid ${t.appBorderColor}`,
      borderRadius: e ? 0 : t.appBorderRadius,
      padding: e ? 0 : 40,
      alignItems: 'center',
      justifyContent: 'center',
      flexDirection: 'column',
      gap: 15,
      background: t.background.content,
    }))
    const N3 = R.div(({ theme: e }) => ({
      display: 'flex',
      fontSize: e.typography.size.s2 - 1,
      gap: 25,
    }))
    const L3 = h(({ inAddonPanel: e }) => {
      const [t, r] = z(!0)
      return (
        X(() => {
          const n = setTimeout(() => {
            r(!1)
          }, 100)
          return () => clearTimeout(n)
        }, []),
        t
          ? null
          : c.createElement(
              P3,
              { inAddonPanel: e },
              c.createElement(kn, {
                title: e
                  ? 'Interactive story playground'
                  : "Args table with interactive controls couldn't be auto-generated",
                description: c.createElement(
                  c.Fragment,
                  null,
                  "Controls give you an easy to use interface to test your components. Set your story args and you'll see controls appearing here automatically."
                ),
                footer: c.createElement(
                  N3,
                  null,
                  e &&
                    c.createElement(
                      c.Fragment,
                      null,
                      c.createElement(
                        Ze,
                        {
                          href: 'https://storybook.js.org/docs/essentials/controls',
                          target: '_blank',
                          withArrow: !0,
                        },
                        c.createElement(yr, null),
                        ' Read docs'
                      )
                    ),
                  !e &&
                    c.createElement(
                      Ze,
                      {
                        href: 'https://storybook.js.org/docs/essentials/controls',
                        target: '_blank',
                        withArrow: !0,
                      },
                      c.createElement(yr, null),
                      ' Learn how to set that up'
                    )
                ),
              })
            )
      )
    }, 'Empty')
    const j3 = R(bo)(({ theme: e }) => ({
      marginRight: 8,
      marginLeft: -10,
      marginTop: -2,
      height: 12,
      width: 12,
      color:
        e.base === 'light'
          ? de(0.25, e.color.defaultText)
          : de(0.3, e.color.defaultText),
      border: 'none',
      display: 'inline-block',
    }))
    const M3 = R(Sc)(({ theme: e }) => ({
      marginRight: 8,
      marginLeft: -10,
      marginTop: -2,
      height: 12,
      width: 12,
      color:
        e.base === 'light'
          ? de(0.25, e.color.defaultText)
          : de(0.3, e.color.defaultText),
      border: 'none',
      display: 'inline-block',
    }))
    const $3 = R.span(({ theme: e }) => ({
      display: 'flex',
      lineHeight: '20px',
      alignItems: 'center',
    }))
    const q3 = R.td(({ theme: e }) => ({
      position: 'relative',
      letterSpacing: '0.35em',
      textTransform: 'uppercase',
      fontWeight: e.typography.weight.bold,
      fontSize: e.typography.size.s1 - 1,
      color:
        e.base === 'light'
          ? de(0.4, e.color.defaultText)
          : de(0.6, e.color.defaultText),
      background: `${e.background.app} !important`,
      '& ~ td': { background: `${e.background.app} !important` },
    }))
    const U3 = R.td(({ theme: e }) => ({
      position: 'relative',
      fontWeight: e.typography.weight.bold,
      fontSize: e.typography.size.s2 - 1,
      background: e.background.app,
    }))
    const H3 = R.td({ position: 'relative' })
    const V3 = R.tr(({ theme: e }) => ({
      '&:hover > td': {
        backgroundColor: `${Or(0.005, e.background.app)} !important`,
        boxShadow: `${e.color.mediumlight} 0 - 1px 0 0 inset`,
        cursor: 'row-resize',
      },
    }))
    const x0 = R.button({
      background: 'none',
      border: 'none',
      padding: '0',
      font: 'inherit',
      position: 'absolute',
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      height: '100%',
      width: '100%',
      color: 'transparent',
      cursor: 'row-resize !important',
    })
    const au = h(
      ({
        level: e = 'section',
        label: t,
        children: r,
        initialExpanded: n = !0,
        colSpan: o = 3,
      }) => {
        const [a, i] = z(n)
        const s = e === 'subsection' ? U3 : q3
        const l = r?.length || 0
        const u = e === 'subsection' ? `${l} item${l !== 1 ? 's' : ''}` : ''
        const d = `${a ? 'Hide' : 'Show'} ${e === 'subsection' ? l : t} item${l !== 1 ? 's' : ''}`
        return c.createElement(
          c.Fragment,
          null,
          c.createElement(
            V3,
            { title: d },
            c.createElement(
              s,
              { colSpan: 1 },
              c.createElement(x0, { onClick: m => i(!a), tabIndex: 0 }, d),
              c.createElement(
                $3,
                null,
                a ? c.createElement(j3, null) : c.createElement(M3, null),
                t
              )
            ),
            c.createElement(
              H3,
              { colSpan: o - 1 },
              c.createElement(
                x0,
                {
                  onClick: m => i(!a),
                  tabIndex: -1,
                  style: { outline: 'none' },
                },
                d
              ),
              a ? null : u
            )
          ),
          a ? r : null
        )
      },
      'SectionRow'
    )
    const z3 = R.div(({ theme: e }) => ({
      width: '100%',
      borderSpacing: 0,
      color: e.color.defaultText,
    }))
    const Va = R.div(({ theme: e }) => ({
      display: 'flex',
      borderBottom: `1px solid ${e.appBorderColor}`,
      '&:last-child': { borderBottom: 0 },
    }))
    const He = R.div(({ position: e, theme: t }) => {
      const r = {
        display: 'flex',
        flexDirection: 'column',
        gap: 5,
        padding: '10px 15px',
        alignItems: 'flex-start',
      }
      switch (e) {
        case 'first':
          return { ...r, width: '25%', paddingLeft: 20 }
        case 'second':
          return { ...r, width: '35%' }
        case 'third':
          return { ...r, width: '15%' }
        case 'last':
          return { ...r, width: '25%', paddingRight: 20 }
      }
    })
    const _e = R.div(({ theme: e, width: t, height: r }) => ({
      animation: `${e.animation.glow} 1.5s ease-in-out infinite`,
      background: e.appBorderColor,
      width: t || '100%',
      height: r || 16,
      borderRadius: 3,
    }))
    const G3 = h(
      () =>
        c.createElement(
          z3,
          null,
          c.createElement(
            Va,
            null,
            c.createElement(
              He,
              { position: 'first' },
              c.createElement(_e, { width: '60%' })
            ),
            c.createElement(
              He,
              { position: 'second' },
              c.createElement(_e, { width: '30%' })
            ),
            c.createElement(
              He,
              { position: 'third' },
              c.createElement(_e, { width: '60%' })
            ),
            c.createElement(
              He,
              { position: 'last' },
              c.createElement(_e, { width: '60%' })
            )
          ),
          c.createElement(
            Va,
            null,
            c.createElement(
              He,
              { position: 'first' },
              c.createElement(_e, { width: '60%' })
            ),
            c.createElement(
              He,
              { position: 'second' },
              c.createElement(_e, { width: '80%' }),
              c.createElement(_e, { width: '30%' })
            ),
            c.createElement(
              He,
              { position: 'third' },
              c.createElement(_e, { width: '60%' })
            ),
            c.createElement(
              He,
              { position: 'last' },
              c.createElement(_e, { width: '60%' })
            )
          ),
          c.createElement(
            Va,
            null,
            c.createElement(
              He,
              { position: 'first' },
              c.createElement(_e, { width: '60%' })
            ),
            c.createElement(
              He,
              { position: 'second' },
              c.createElement(_e, { width: '80%' }),
              c.createElement(_e, { width: '30%' })
            ),
            c.createElement(
              He,
              { position: 'third' },
              c.createElement(_e, { width: '60%' })
            ),
            c.createElement(
              He,
              { position: 'last' },
              c.createElement(_e, { width: '60%' })
            )
          ),
          c.createElement(
            Va,
            null,
            c.createElement(
              He,
              { position: 'first' },
              c.createElement(_e, { width: '60%' })
            ),
            c.createElement(
              He,
              { position: 'second' },
              c.createElement(_e, { width: '80%' }),
              c.createElement(_e, { width: '30%' })
            ),
            c.createElement(
              He,
              { position: 'third' },
              c.createElement(_e, { width: '60%' })
            ),
            c.createElement(
              He,
              { position: 'last' },
              c.createElement(_e, { width: '60%' })
            )
          )
        ),
      'Skeleton'
    )
    const W3 = R.table(({ theme: e, compact: t, inAddonPanel: r }) => ({
      '&&': {
        borderSpacing: 0,
        color: e.color.defaultText,
        'td, th': {
          padding: 0,
          border: 'none',
          verticalAlign: 'top',
          textOverflow: 'ellipsis',
        },
        fontSize: e.typography.size.s2 - 1,
        lineHeight: '20px',
        textAlign: 'left',
        width: '100%',
        marginTop: r ? 0 : 25,
        marginBottom: r ? 0 : 40,
        'thead th:first-of-type, td:first-of-type': { width: '25%' },
        'th:first-of-type, td:first-of-type': { paddingLeft: 20 },
        'th:nth-of-type(2), td:nth-of-type(2)': {
          ...(t ? null : { width: '35%' }),
        },
        'td:nth-of-type(3)': { ...(t ? null : { width: '15%' }) },
        'th:last-of-type, td:last-of-type': {
          paddingRight: 20,
          ...(t ? null : { width: '25%' }),
        },
        th: {
          color:
            e.base === 'light'
              ? de(0.25, e.color.defaultText)
              : de(0.45, e.color.defaultText),
          paddingTop: 10,
          paddingBottom: 10,
          paddingLeft: 15,
          paddingRight: 15,
        },
        td: {
          paddingTop: '10px',
          paddingBottom: '10px',
          '&:not(:first-of-type)': { paddingLeft: 15, paddingRight: 15 },
          '&:last-of-type': { paddingRight: 20 },
        },
        marginLeft: r ? 0 : 1,
        marginRight: r ? 0 : 1,
        tbody: {
          ...(r
            ? null
            : {
                filter:
                  e.base === 'light'
                    ? 'drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.10))'
                    : 'drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.20))',
              }),
          '> tr > *': {
            background: e.background.content,
            borderTop: `1px solid ${e.appBorderColor}`,
          },
          ...(r
            ? null
            : {
                '> tr:first-of-type > *': {
                  borderBlockStart: `1px solid ${e.appBorderColor}`,
                },
                '> tr:last-of-type > *': {
                  borderBlockEnd: `1px solid ${e.appBorderColor}`,
                },
                '> tr > *:first-of-type': {
                  borderInlineStart: `1px solid ${e.appBorderColor}`,
                },
                '> tr > *:last-of-type': {
                  borderInlineEnd: `1px solid ${e.appBorderColor}`,
                },
                '> tr:first-of-type > td:first-of-type': {
                  borderTopLeftRadius: e.appBorderRadius,
                },
                '> tr:first-of-type > td:last-of-type': {
                  borderTopRightRadius: e.appBorderRadius,
                },
                '> tr:last-of-type > td:first-of-type': {
                  borderBottomLeftRadius: e.appBorderRadius,
                },
                '> tr:last-of-type > td:last-of-type': {
                  borderBottomRightRadius: e.appBorderRadius,
                },
              }),
        },
      },
    }))
    const Y3 = R(ce)(({ theme: e }) => ({ margin: '-4px -12px -4px 0' }))
    const K3 = R.span({ display: 'flex', justifyContent: 'space-between' })
    const X3 = {
      alpha: h((e, t) => (e.name ?? '').localeCompare(t.name ?? ''), 'alpha'),
      requiredFirst: h(
        (e, t) =>
          +!!t.type?.required - +!!e.type?.required ||
          (e.name ?? '').localeCompare(t.name ?? ''),
        'requiredFirst'
      ),
      none: null,
    }
    const J3 = h((e, t) => {
      const r = { ungrouped: [], ungroupedSubsections: {}, sections: {} }
      if (!e) return r
      Object.entries(e).forEach(([a, i]) => {
        const { category: s, subcategory: l } = i?.table || {}
        if (s) {
          const u = r.sections[s] || { ungrouped: [], subsections: {} }
          if (!l) u.ungrouped.push({ key: a, ...i })
          else {
            const d = u.subsections[l] || []
            ;(d.push({ key: a, ...i }), (u.subsections[l] = d))
          }
          r.sections[s] = u
        } else if (l) {
          const u = r.ungroupedSubsections[l] || []
          ;(u.push({ key: a, ...i }), (r.ungroupedSubsections[l] = u))
        } else r.ungrouped.push({ key: a, ...i })
      })
      const n = X3[t]
      const o = h(
        a =>
          n
            ? Object.keys(a).reduce((i, s) => ({ ...i, [s]: a[s].sort(n) }), {})
            : a,
        'sortSubsection'
      )
      return {
        ungrouped: n ? r.ungrouped.sort(n) : r.ungrouped,
        ungroupedSubsections: o(r.ungroupedSubsections),
        sections: Object.keys(r.sections).reduce(
          (a, i) => ({
            ...a,
            [i]: {
              ungrouped: n
                ? r.sections[i].ungrouped.sort(n)
                : r.sections[i].ungrouped,
              subsections: o(r.sections[i].subsections),
            },
          }),
          {}
        ),
      }
    }, 'groupRows')
    const Z3 = h((e, t, r) => {
      try {
        return Zr(e, t, r)
      } catch (n) {
        return (yt.warn(n.message), !1)
      }
    }, 'safeIncludeConditionalArg')
    const Q3 = h(e => {
      const {
        updateArgs: t,
        resetArgs: r,
        compact: n,
        inAddonPanel: o,
        initialExpandedArgs: a,
        sort: i = 'none',
        isLoading: s,
      } = e
      if ('error' in e) {
        const { error: x } = e
        return c.createElement(
          pb,
          null,
          x,
          '\xA0',
          c.createElement(
            Ze,
            {
              href: 'http://storybook.js.org/docs/',
              target: '_blank',
              withArrow: !0,
            },
            c.createElement(yr, null),
            ' Read the docs'
          )
        )
      }
      if (s) return c.createElement(G3, null)
      const {
        rows: l,
        args: u,
        globals: d,
      } = 'rows' in e ? e : { rows: void 0, args: void 0, globals: void 0 }
      const m = J3(
        Ry(l || {}, x => !x?.table?.disable && Z3(x, u || {}, d || {})),
        i
      )
      const p = m.ungrouped.length === 0
      const f = Object.entries(m.sections).length === 0
      const g = Object.entries(m.ungroupedSubsections).length === 0
      if (p && f && g) return c.createElement(L3, { inAddonPanel: o })
      let y = 1
      ;(t && (y += 1), n || (y += 2))
      const E = Object.keys(m.sections).length > 0
      const b = {
        updateArgs: t,
        compact: n,
        inAddonPanel: o,
        initialExpandedArgs: a,
      }
      return c.createElement(
        wi,
        null,
        c.createElement(
          W3,
          {
            compact: n,
            inAddonPanel: o,
            className: 'docblock-argstable sb-unstyled',
          },
          c.createElement(
            'thead',
            { className: 'docblock-argstable-head' },
            c.createElement(
              'tr',
              null,
              c.createElement(
                'th',
                null,
                c.createElement('span', null, 'Name')
              ),
              n
                ? null
                : c.createElement(
                    'th',
                    null,
                    c.createElement('span', null, 'Description')
                  ),
              n
                ? null
                : c.createElement(
                    'th',
                    null,
                    c.createElement('span', null, 'Default')
                  ),
              t
                ? c.createElement(
                    'th',
                    null,
                    c.createElement(
                      K3,
                      null,
                      'Control',
                      ' ',
                      !s &&
                        r &&
                        c.createElement(
                          Y3,
                          { onClick: () => r(), title: 'Reset controls' },
                          c.createElement(xo, { 'aria-hidden': !0 })
                        )
                    )
                  )
                : null
            )
          ),
          c.createElement(
            'tbody',
            { className: 'docblock-argstable-body' },
            m.ungrouped.map(x =>
              c.createElement(Ha, {
                key: x.key,
                row: x,
                arg: u && u[x.key],
                ...b,
              })
            ),
            Object.entries(m.ungroupedSubsections).map(([x, S]) =>
              c.createElement(
                au,
                { key: x, label: x, level: 'subsection', colSpan: y },
                S.map(T =>
                  c.createElement(Ha, {
                    key: T.key,
                    row: T,
                    arg: u && u[T.key],
                    expandable: E,
                    ...b,
                  })
                )
              )
            ),
            Object.entries(m.sections).map(([x, S]) =>
              c.createElement(
                au,
                { key: x, label: x, level: 'section', colSpan: y },
                S.ungrouped.map(T =>
                  c.createElement(Ha, {
                    key: T.key,
                    row: T,
                    arg: u && u[T.key],
                    ...b,
                  })
                ),
                Object.entries(S.subsections).map(([T, _]) =>
                  c.createElement(
                    au,
                    { key: T, label: T, level: 'subsection', colSpan: y },
                    _.map(O =>
                      c.createElement(Ha, {
                        key: O.key,
                        row: O,
                        arg: u && u[O.key],
                        expandable: E,
                        ...b,
                      })
                    )
                  )
                )
              )
            )
          )
        )
      )
    }, 'ArgsTable')
    const Ru = 'addon-controls'
    const n1 = 'controls'
    const eT = Oi({
      from: { transform: 'translateY(40px)' },
      to: { transform: 'translateY(0)' },
    })
    const tT = Oi({ from: { background: 'var(--highlight-bg-color)' }, to: {} })
    const rT = R.div({
      containerType: 'size',
      position: 'sticky',
      bottom: 0,
      height: 39,
      overflow: 'hidden',
      zIndex: 1,
    })
    const nT = R(Tn)(({ theme: e }) => ({
      '--highlight-bg-color': e.base === 'dark' ? '#153B5B' : '#E0F0FF',
      display: 'flex',
      flexDirection: 'row-reverse',
      alignItems: 'center',
      justifyContent: 'space-between',
      flexWrap: 'wrap',
      gap: 6,
      padding: '6px 10px',
      animation: `${eT} 300ms, ${tT} 2s`,
      background: e.background.bar,
      borderTop: `1px solid ${e.appBorderColor}`,
      fontSize: e.typography.size.s2,
      '@container (max-width: 799px)': {
        flexDirection: 'row',
        justifyContent: 'flex-end',
      },
    }))
    const oT = R.div({
      display: 'flex',
      flex: '99 0 auto',
      alignItems: 'center',
      marginLeft: 10,
      gap: 6,
    })
    const aT = R.div(({ theme: e }) => ({
      display: 'flex',
      flex: '1 0 0',
      alignItems: 'center',
      gap: 2,
      color: e.color.mediumdark,
      fontSize: e.typography.size.s2,
    }))
    const iu = R.div({
      '@container (max-width: 799px)': {
        lineHeight: 0,
        textIndent: '-9999px',
        '&::after': {
          content: 'attr(data-short-label)',
          display: 'block',
          lineHeight: 'initial',
          textIndent: '0',
        },
      },
    })
    const iT = R($e.Input)(({ theme: e }) => ({
      '::placeholder': { color: e.color.mediumdark },
      '&:invalid:not(:placeholder-shown)': {
        boxShadow: `${e.color.negative} 0 0 0 1px inset`,
      },
    }))
    const sT = h(
      ({ saveStory: e, createStory: t, resetArgs: r, portalSelector: n }) => {
        const o = c.useRef(null)
        const [a, i] = c.useState(!1)
        const [s, l] = c.useState(!1)
        const [u, d] = c.useState('')
        const [m, p] = c.useState(null)
        const f = h(async () => {
          a || (i(!0), await e().catch(() => {}), i(!1))
        }, 'onSaveStory')
        const g = h(() => {
          ;(l(!0), d(''), setTimeout(() => o.current?.focus(), 0))
        }, 'onShowForm')
        const y = h(E => {
          const b = E.target.value
            .replace(/^[^a-z]/i, '')
            .replace(/[^a-z0-9-_ ]/gi, '')
            .replaceAll(/([-_ ]+[a-z0-9])/gi, x =>
              x.toUpperCase().replace(/[-_ ]/g, '')
            )
          d(b.charAt(0).toUpperCase() + b.slice(1))
        }, 'onChange')
        return c.createElement(
          rT,
          { id: 'save-from-controls' },
          c.createElement(
            nT,
            null,
            c.createElement(
              aT,
              null,
              c.createElement(
                De,
                {
                  as: 'div',
                  hasChrome: !1,
                  trigger: 'hover',
                  tooltip: c.createElement(vt, {
                    note: 'Save changes to story',
                  }),
                },
                c.createElement(
                  ce,
                  {
                    'aria-label': 'Save changes to story',
                    disabled: a,
                    onClick: f,
                  },
                  c.createElement(yo, null),
                  c.createElement(
                    iu,
                    { 'data-short-label': 'Save' },
                    'Update story'
                  )
                )
              ),
              c.createElement(
                De,
                {
                  as: 'div',
                  hasChrome: !1,
                  trigger: 'hover',
                  tooltip: c.createElement(vt, {
                    note: 'Create new story with these settings',
                  }),
                },
                c.createElement(
                  ce,
                  {
                    'aria-label': 'Create new story with these settings',
                    onClick: g,
                  },
                  c.createElement(go, null),
                  c.createElement(
                    iu,
                    { 'data-short-label': 'New' },
                    'Create new story'
                  )
                )
              ),
              c.createElement(
                De,
                {
                  as: 'div',
                  hasChrome: !1,
                  trigger: 'hover',
                  tooltip: c.createElement(vt, { note: 'Reset changes' }),
                },
                c.createElement(
                  ce,
                  { 'aria-label': 'Reset changes', onClick: () => r() },
                  c.createElement(xo, null),
                  c.createElement('span', null, 'Reset')
                )
              )
            ),
            c.createElement(
              oT,
              null,
              c.createElement(
                iu,
                { 'data-short-label': 'Unsaved changes' },
                'You modified this story. Do you want to save your changes?'
              )
            ),
            c.createElement(
              It,
              { width: 350, open: s, onOpenChange: l, portalSelector: n },
              c.createElement(
                $e,
                {
                  onSubmit: h(async E => {
                    if ((E.preventDefault(), !a))
                      try {
                        ;(p(null),
                          i(!0),
                          await t(
                            u
                              .replace(/^[^a-z]/i, '')
                              .replaceAll(/[^a-z0-9]/gi, '')
                          ),
                          l(!1),
                          i(!1))
                      } catch (b) {
                        ;(p(b.message), i(!1))
                      }
                  }, 'onSubmitForm'),
                  id: 'create-new-story-form',
                },
                c.createElement(
                  It.Content,
                  null,
                  c.createElement(
                    It.Header,
                    null,
                    c.createElement(It.Title, null, 'Create new story'),
                    c.createElement(
                      It.Description,
                      null,
                      'This will add a new story to your existing stories file.'
                    )
                  ),
                  c.createElement(iT, {
                    onChange: y,
                    placeholder: 'Story export name',
                    readOnly: a,
                    ref: o,
                    value: u,
                  }),
                  c.createElement(
                    It.Actions,
                    null,
                    c.createElement(
                      Je,
                      {
                        disabled: a || !u,
                        size: 'medium',
                        type: 'submit',
                        variant: 'solid',
                      },
                      'Create'
                    ),
                    c.createElement(
                      It.Dialog.Close,
                      { asChild: !0 },
                      c.createElement(
                        Je,
                        { disabled: a, size: 'medium', type: 'reset' },
                        'Cancel'
                      )
                    )
                  )
                )
              ),
              m && c.createElement(It.Error, null, m)
            )
          )
        )
      },
      'SaveStory'
    )
    const w0 = h(
      e =>
        Object.entries(e).reduce(
          (t, [r, n]) => (n !== void 0 ? Object.assign(t, { [r]: n }) : t),
          {}
        ),
      'clean'
    )
    const lT = R.div({
      display: 'grid',
      gridTemplateRows: '1fr 39px',
      height: '100%',
      maxHeight: '100vh',
      overflowY: 'auto',
    })
    const uT = h(({ saveStory: e, createStory: t }) => {
      const [r, n] = z(!0)
      const [o, a, i, s] = nd()
      const [l] = Rt()
      const u = So()
      const {
        expanded: d,
        sort: m,
        presetColors: p,
        disableSaveFromUI: f = !1,
      } = tr(n1, {})
      const { path: g, previewInitialized: y } = od()
      X(() => {
        y && n(!1)
      }, [y])
      const E = Object.values(u).some(S => S?.control)
      const b = Object.entries(u).reduce((S, [T, _]) => {
        const O = _?.control
        return (
          typeof O !== 'object' || O?.type !== 'color' || O?.presetColors
            ? (S[T] = _)
            : (S[T] = { ..._, control: { ...O, presetColors: p } }),
          S
        )
      }, {})
      const x = Me(() => !!o && !!s && !fr(w0(o), w0(s)), [o, s])
      return c.createElement(
        lT,
        null,
        c.createElement(Q3, {
          key: g,
          compact: !d && E,
          rows: b,
          args: o,
          globals: l,
          updateArgs: a,
          resetArgs: i,
          inAddonPanel: !0,
          sort: m,
          isLoading: r,
        }),
        E &&
          x &&
          H.CONFIG_TYPE === 'DEVELOPMENT' &&
          f !== !0 &&
          c.createElement(sT, { resetArgs: i, saveStory: e, createStory: t })
      )
    }, 'ControlsPanel')
    function o1() {
      const e = tt().getSelectedPanel()
      const t = So()
      const r = Object.values(t).filter(
        n => n?.control && !n?.table?.disable
      ).length
      return c.createElement(
        'div',
        { style: { display: 'flex', alignItems: 'center', gap: 6 } },
        c.createElement('span', null, 'Controls'),
        r === 0
          ? null
          : c.createElement(
              gr,
              { compact: !0, status: e === Ru ? 'active' : 'neutral' },
              r
            )
      )
    }
    h(o1, 'Title')
    const S0 = h(
      e =>
        JSON.stringify(e, (t, r) =>
          typeof r === 'function' ? '__sb_empty_function_arg__' : r
        ),
      'stringifyArgs'
    )
    const K$ = ve.register(Ru, e => {
      if (globalThis?.FEATURES?.controls) {
        const t = ve.getChannel()
        const r = h(async () => {
          const o = e.getCurrentStoryData()
          if (o.type !== 'story') throw new Error('Not a story')
          try {
            const a = await Ri(t, Fi, Io, {
              args: S0(
                Object.entries(o.args || {}).reduce(
                  (i, [s, l]) => (fr(l, o.initialArgs?.[s]) || (i[s] = l), i),
                  {}
                )
              ),
              csfId: o.id,
              importPath: o.importPath,
            })
            e.addNotification({
              id: 'save-story-success',
              icon: c.createElement(ki, { color: wo.positive }),
              content: {
                headline: 'Story saved',
                subHeadline: c.createElement(
                  c.Fragment,
                  null,
                  'Updated story ',
                  c.createElement('b', null, a.sourceStoryName),
                  '.'
                ),
              },
              duration: 8e3,
            })
          } catch (a) {
            throw (
              e.addNotification({
                id: 'save-story-error',
                icon: c.createElement(Oc, { color: wo.negative }),
                content: {
                  headline: 'Failed to save story',
                  subHeadline:
                    a?.message ||
                    'Check the Storybook process on the command line for more details.',
                },
                duration: 8e3,
              }),
              a
            )
          }
        }, 'saveStory')
        const n = h(async o => {
          const a = e.getCurrentStoryData()
          if (a.type !== 'story') throw new Error('Not a story')
          const i = await Ri(t, Fi, Io, {
            args: a.args && S0(a.args),
            csfId: a.id,
            importPath: a.importPath,
            name: o,
          })
          e.addNotification({
            id: 'save-story-success',
            icon: c.createElement(ki, { color: wo.positive }),
            content: {
              headline: 'Story created',
              subHeadline: c.createElement(
                c.Fragment,
                null,
                'Added story ',
                c.createElement('b', null, i.newStoryName),
                ' based on ',
                c.createElement('b', null, i.sourceStoryName),
                '.'
              ),
            },
            duration: 8e3,
            onClick: h(({ onDismiss: s }) => {
              ;(s(), e.selectStory(i.newStoryId))
            }, 'onClick'),
          })
        }, 'createStory')
        ;(ve.add(Ru, {
          title: o1,
          type: et.PANEL,
          paramKey: n1,
          render: h(
            ({ active: o }) =>
              !o || !e.getCurrentStoryData()
                ? null
                : c.createElement(
                    Dn,
                    { active: o },
                    c.createElement(uT, { saveStory: r, createStory: n })
                  ),
            'render'
          ),
        }),
          t.on(Io, o => {
            if (!o.success) return
            const a = e.getCurrentStoryData()
            a.type === 'story' &&
              (e.resetStoryArgs(a),
              o.payload.newStoryId && e.selectStory(o.payload.newStoryId))
          }))
      }
    })
    const cT = 'actions'
    const lo = 'storybook/actions'
    const a1 = `${lo}/panel`
    const Bu = `${lo}/action-event`
    const i1 = `${lo}/action-clear`
    function s1() {
      const e = tt().getSelectedPanel()
      const [{ count: t }, r] = jr(lo, { count: 0 })
      return (
        Co({
          [Bu]: () => {
            r(n => ({ ...n, count: n.count + 1 }))
          },
          [Er]: () => {
            r(n => ({ ...n, count: 0 }))
          },
          [i1]: () => {
            r(n => ({ ...n, count: 0 }))
          },
        }),
        c.createElement(
          'div',
          { style: { display: 'flex', alignItems: 'center', gap: 6 } },
          c.createElement('span', null, 'Actions'),
          t === 0
            ? null
            : c.createElement(
                gr,
                { compact: !0, status: e === a1 ? 'active' : 'neutral' },
                t
              )
        )
      )
    }
    h(s1, 'Title')
    const dT = Object.create
    const uc = Object.defineProperty
    const pT = Object.getOwnPropertyDescriptor
    const l1 = Object.getOwnPropertyNames
    const mT = Object.getPrototypeOf
    const hT = Object.prototype.hasOwnProperty
    const cc = h(
      (e, t) =>
        h(function () {
          return (
            t || (0, e[l1(e)[0]])((t = { exports: {} }).exports, t),
            t.exports
          )
        }, '__require'),
      '__commonJS'
    )
    const fT = h((e, t) => {
      for (const r in t) uc(e, r, { get: t[r], enumerable: !0 })
    }, '__export')
    const gT = h((e, t, r, n) => {
      if ((t && typeof t === 'object') || typeof t === 'function')
        for (const o of l1(t))
          !hT.call(e, o) &&
            o !== r &&
            uc(e, o, {
              get: h(() => t[o], 'get'),
              enumerable: !(n = pT(t, o)) || n.enumerable,
            })
      return e
    }, '__copyProps')
    const yT = h(
      (e, t, r) => (
        (r = e != null ? dT(mT(e)) : {}),
        gT(
          t || !e || !e.__esModule
            ? uc(r, 'default', { value: e, enumerable: !0 })
            : r,
          e
        )
      ),
      '__toESM'
    )
    const bT = cc({
      'node_modules/is-object/index.js'(e, t) {
        'use strict'
        t.exports = h(function (r) {
          return typeof r === 'object' && r !== null
        }, 'isObject')
      },
    })
    const ET = cc({
      'node_modules/is-window/index.js'(e, t) {
        'use strict'
        t.exports = function (r) {
          if (r == null) return !1
          const n = Object(r)
          return n === n.window
        }
      },
    })
    const vT = cc({
      'node_modules/is-dom/index.js'(e, t) {
        const r = bT()
        const n = ET()
        function o(a) {
          return !r(a) || !n(window) || typeof window.Node !== 'function'
            ? !1
            : typeof a.nodeType === 'number' && typeof a.nodeName === 'string'
        }
        ;(h(o, 'isNode'), (t.exports = o))
      },
    })
    const ai = {}
    fT(ai, {
      chromeDark: h(() => AT, 'chromeDark'),
      chromeLight: h(() => xT, 'chromeLight'),
    })
    var AT = {
      BASE_FONT_FAMILY: 'Menlo, monospace',
      BASE_FONT_SIZE: '11px',
      BASE_LINE_HEIGHT: 1.2,
      BASE_BACKGROUND_COLOR: 'rgb(36, 36, 36)',
      BASE_COLOR: 'rgb(213, 213, 213)',
      OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES: 10,
      OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES: 5,
      OBJECT_NAME_COLOR: 'rgb(227, 110, 236)',
      OBJECT_VALUE_NULL_COLOR: 'rgb(127, 127, 127)',
      OBJECT_VALUE_UNDEFINED_COLOR: 'rgb(127, 127, 127)',
      OBJECT_VALUE_REGEXP_COLOR: 'rgb(233, 63, 59)',
      OBJECT_VALUE_STRING_COLOR: 'rgb(233, 63, 59)',
      OBJECT_VALUE_SYMBOL_COLOR: 'rgb(233, 63, 59)',
      OBJECT_VALUE_NUMBER_COLOR: 'hsl(252, 100%, 75%)',
      OBJECT_VALUE_BOOLEAN_COLOR: 'hsl(252, 100%, 75%)',
      OBJECT_VALUE_FUNCTION_PREFIX_COLOR: 'rgb(85, 106, 242)',
      HTML_TAG_COLOR: 'rgb(93, 176, 215)',
      HTML_TAGNAME_COLOR: 'rgb(93, 176, 215)',
      HTML_TAGNAME_TEXT_TRANSFORM: 'lowercase',
      HTML_ATTRIBUTE_NAME_COLOR: 'rgb(155, 187, 220)',
      HTML_ATTRIBUTE_VALUE_COLOR: 'rgb(242, 151, 102)',
      HTML_COMMENT_COLOR: 'rgb(137, 137, 137)',
      HTML_DOCTYPE_COLOR: 'rgb(192, 192, 192)',
      ARROW_COLOR: 'rgb(145, 145, 145)',
      ARROW_MARGIN_RIGHT: 3,
      ARROW_FONT_SIZE: 12,
      ARROW_ANIMATION_DURATION: '0',
      TREENODE_FONT_FAMILY: 'Menlo, monospace',
      TREENODE_FONT_SIZE: '11px',
      TREENODE_LINE_HEIGHT: 1.2,
      TREENODE_PADDING_LEFT: 12,
      TABLE_BORDER_COLOR: 'rgb(85, 85, 85)',
      TABLE_TH_BACKGROUND_COLOR: 'rgb(44, 44, 44)',
      TABLE_TH_HOVER_COLOR: 'rgb(48, 48, 48)',
      TABLE_SORT_ICON_COLOR: 'black',
      TABLE_DATA_BACKGROUND_IMAGE:
        'linear-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(51, 139, 255, 0.0980392) 50%, rgba(51, 139, 255, 0.0980392))',
      TABLE_DATA_BACKGROUND_SIZE: '128px 32px',
    }
    var xT = {
      BASE_FONT_FAMILY: 'Menlo, monospace',
      BASE_FONT_SIZE: '11px',
      BASE_LINE_HEIGHT: 1.2,
      BASE_BACKGROUND_COLOR: 'white',
      BASE_COLOR: 'black',
      OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES: 10,
      OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES: 5,
      OBJECT_NAME_COLOR: 'rgb(136, 19, 145)',
      OBJECT_VALUE_NULL_COLOR: 'rgb(128, 128, 128)',
      OBJECT_VALUE_UNDEFINED_COLOR: 'rgb(128, 128, 128)',
      OBJECT_VALUE_REGEXP_COLOR: 'rgb(196, 26, 22)',
      OBJECT_VALUE_STRING_COLOR: 'rgb(196, 26, 22)',
      OBJECT_VALUE_SYMBOL_COLOR: 'rgb(196, 26, 22)',
      OBJECT_VALUE_NUMBER_COLOR: 'rgb(28, 0, 207)',
      OBJECT_VALUE_BOOLEAN_COLOR: 'rgb(28, 0, 207)',
      OBJECT_VALUE_FUNCTION_PREFIX_COLOR: 'rgb(13, 34, 170)',
      HTML_TAG_COLOR: 'rgb(168, 148, 166)',
      HTML_TAGNAME_COLOR: 'rgb(136, 18, 128)',
      HTML_TAGNAME_TEXT_TRANSFORM: 'lowercase',
      HTML_ATTRIBUTE_NAME_COLOR: 'rgb(153, 69, 0)',
      HTML_ATTRIBUTE_VALUE_COLOR: 'rgb(26, 26, 166)',
      HTML_COMMENT_COLOR: 'rgb(35, 110, 37)',
      HTML_DOCTYPE_COLOR: 'rgb(192, 192, 192)',
      ARROW_COLOR: '#6e6e6e',
      ARROW_MARGIN_RIGHT: 3,
      ARROW_FONT_SIZE: 12,
      ARROW_ANIMATION_DURATION: '0',
      TREENODE_FONT_FAMILY: 'Menlo, monospace',
      TREENODE_FONT_SIZE: '11px',
      TREENODE_LINE_HEIGHT: 1.2,
      TREENODE_PADDING_LEFT: 12,
      TABLE_BORDER_COLOR: '#aaa',
      TABLE_TH_BACKGROUND_COLOR: '#eee',
      TABLE_TH_HOVER_COLOR: 'hsla(0, 0%, 90%, 1)',
      TABLE_SORT_ICON_COLOR: '#6e6e6e',
      TABLE_DATA_BACKGROUND_IMAGE:
        'linear-gradient(to bottom, white, white 50%, rgb(234, 243, 255) 50%, rgb(234, 243, 255))',
      TABLE_DATA_BACKGROUND_SIZE: '128px 32px',
    }
    const u1 = Lr([{}, () => {}])
    const su = {
      WebkitTouchCallout: 'none',
      WebkitUserSelect: 'none',
      KhtmlUserSelect: 'none',
      MozUserSelect: 'none',
      msUserSelect: 'none',
      OUserSelect: 'none',
      userSelect: 'none',
    }
    const Qa = h(
      e => ({
        DOMNodePreview: {
          htmlOpenTag: {
            base: { color: e.HTML_TAG_COLOR },
            tagName: {
              color: e.HTML_TAGNAME_COLOR,
              textTransform: e.HTML_TAGNAME_TEXT_TRANSFORM,
            },
            htmlAttributeName: { color: e.HTML_ATTRIBUTE_NAME_COLOR },
            htmlAttributeValue: { color: e.HTML_ATTRIBUTE_VALUE_COLOR },
          },
          htmlCloseTag: {
            base: { color: e.HTML_TAG_COLOR },
            offsetLeft: { marginLeft: -e.TREENODE_PADDING_LEFT },
            tagName: {
              color: e.HTML_TAGNAME_COLOR,
              textTransform: e.HTML_TAGNAME_TEXT_TRANSFORM,
            },
          },
          htmlComment: { color: e.HTML_COMMENT_COLOR },
          htmlDoctype: { color: e.HTML_DOCTYPE_COLOR },
        },
        ObjectPreview: {
          objectDescription: { fontStyle: 'italic' },
          preview: { fontStyle: 'italic' },
          arrayMaxProperties: e.OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES,
          objectMaxProperties: e.OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES,
        },
        ObjectName: {
          base: { color: e.OBJECT_NAME_COLOR },
          dimmed: { opacity: 0.6 },
        },
        ObjectValue: {
          objectValueNull: { color: e.OBJECT_VALUE_NULL_COLOR },
          objectValueUndefined: { color: e.OBJECT_VALUE_UNDEFINED_COLOR },
          objectValueRegExp: { color: e.OBJECT_VALUE_REGEXP_COLOR },
          objectValueString: { color: e.OBJECT_VALUE_STRING_COLOR },
          objectValueSymbol: { color: e.OBJECT_VALUE_SYMBOL_COLOR },
          objectValueNumber: { color: e.OBJECT_VALUE_NUMBER_COLOR },
          objectValueBoolean: { color: e.OBJECT_VALUE_BOOLEAN_COLOR },
          objectValueFunctionPrefix: {
            color: e.OBJECT_VALUE_FUNCTION_PREFIX_COLOR,
            fontStyle: 'italic',
          },
          objectValueFunctionName: { fontStyle: 'italic' },
        },
        TreeView: {
          treeViewOutline: { padding: 0, margin: 0, listStyleType: 'none' },
        },
        TreeNode: {
          treeNodeBase: {
            color: e.BASE_COLOR,
            backgroundColor: e.BASE_BACKGROUND_COLOR,
            lineHeight: e.TREENODE_LINE_HEIGHT,
            cursor: 'default',
            boxSizing: 'border-box',
            listStyle: 'none',
            fontFamily: e.TREENODE_FONT_FAMILY,
            fontSize: e.TREENODE_FONT_SIZE,
          },
          treeNodePreviewContainer: {},
          treeNodePlaceholder: {
            whiteSpace: 'pre',
            fontSize: e.ARROW_FONT_SIZE,
            marginRight: e.ARROW_MARGIN_RIGHT,
            ...su,
          },
          treeNodeArrow: {
            base: {
              color: e.ARROW_COLOR,
              display: 'inline-block',
              fontSize: e.ARROW_FONT_SIZE,
              marginRight: e.ARROW_MARGIN_RIGHT,
              ...(parseFloat(e.ARROW_ANIMATION_DURATION) > 0
                ? {
                    transition: `transform ${e.ARROW_ANIMATION_DURATION} ease 0s`,
                  }
                : {}),
              ...su,
            },
            expanded: {
              WebkitTransform: 'rotateZ(90deg)',
              MozTransform: 'rotateZ(90deg)',
              transform: 'rotateZ(90deg)',
            },
            collapsed: {
              WebkitTransform: 'rotateZ(0deg)',
              MozTransform: 'rotateZ(0deg)',
              transform: 'rotateZ(0deg)',
            },
          },
          treeNodeChildNodesContainer: {
            margin: 0,
            paddingLeft: e.TREENODE_PADDING_LEFT,
          },
        },
        TableInspector: {
          base: {
            color: e.BASE_COLOR,
            position: 'relative',
            border: `1px solid ${e.TABLE_BORDER_COLOR}`,
            fontFamily: e.BASE_FONT_FAMILY,
            fontSize: e.BASE_FONT_SIZE,
            lineHeight: '120%',
            boxSizing: 'border-box',
            cursor: 'default',
          },
        },
        TableInspectorHeaderContainer: {
          base: {
            top: 0,
            height: '17px',
            left: 0,
            right: 0,
            overflowX: 'hidden',
          },
          table: {
            tableLayout: 'fixed',
            borderSpacing: 0,
            borderCollapse: 'separate',
            height: '100%',
            width: '100%',
            margin: 0,
          },
        },
        TableInspectorDataContainer: {
          tr: { display: 'table-row' },
          td: {
            boxSizing: 'border-box',
            border: 'none',
            height: '16px',
            verticalAlign: 'top',
            padding: '1px 4px',
            WebkitUserSelect: 'text',
            whiteSpace: 'nowrap',
            textOverflow: 'ellipsis',
            overflow: 'hidden',
            lineHeight: '14px',
          },
          div: {
            position: 'static',
            top: '17px',
            bottom: 0,
            overflowY: 'overlay',
            transform: 'translateZ(0)',
            left: 0,
            right: 0,
            overflowX: 'hidden',
          },
          table: {
            positon: 'static',
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
            borderTop: '0 none transparent',
            margin: 0,
            backgroundImage: e.TABLE_DATA_BACKGROUND_IMAGE,
            backgroundSize: e.TABLE_DATA_BACKGROUND_SIZE,
            tableLayout: 'fixed',
            borderSpacing: 0,
            borderCollapse: 'separate',
            width: '100%',
            fontSize: e.BASE_FONT_SIZE,
            lineHeight: '120%',
          },
        },
        TableInspectorTH: {
          base: {
            position: 'relative',
            height: 'auto',
            textAlign: 'left',
            backgroundColor: e.TABLE_TH_BACKGROUND_COLOR,
            borderBottom: `1px solid ${e.TABLE_BORDER_COLOR}`,
            fontWeight: 'normal',
            verticalAlign: 'middle',
            padding: '0 4px',
            whiteSpace: 'nowrap',
            textOverflow: 'ellipsis',
            overflow: 'hidden',
            lineHeight: '14px',
            ':hover': { backgroundColor: e.TABLE_TH_HOVER_COLOR },
          },
          div: {
            whiteSpace: 'nowrap',
            textOverflow: 'ellipsis',
            overflow: 'hidden',
            fontSize: e.BASE_FONT_SIZE,
            lineHeight: '120%',
          },
        },
        TableInspectorLeftBorder: {
          none: { borderLeft: 'none' },
          solid: { borderLeft: `1px solid ${e.TABLE_BORDER_COLOR}` },
        },
        TableInspectorSortIcon: {
          display: 'block',
          marginRight: 3,
          width: 8,
          height: 7,
          marginTop: -7,
          color: e.TABLE_SORT_ICON_COLOR,
          fontSize: 12,
          ...su,
        },
      }),
      'createTheme'
    )
    const _u = 'chromeLight'
    const c1 = Lr(Qa(ai[_u]))
    const pt = h(e => mo(c1)[e], 'useStyles')
    const dc = h(
      e =>
        h(({ theme: t = _u, ...r }) => {
          const n = Me(() => {
            switch (Object.prototype.toString.call(t)) {
              case '[object String]':
                return Qa(ai[t])
              case '[object Object]':
                return Qa(t)
              default:
                return Qa(ai[_u])
            }
          }, [t])
          return c.createElement(
            c1.Provider,
            { value: n },
            c.createElement(e, { ...r })
          )
        }, 'ThemeAcceptor'),
      'themeAcceptor'
    )
    const wT = h(
      ({ expanded: e, styles: t }) =>
        c.createElement(
          'span',
          { style: { ...t.base, ...(e ? t.expanded : t.collapsed) } },
          '\u25B6'
        ),
      'Arrow'
    )
    const ST = Xe(e => {
      e = {
        expanded: !0,
        nodeRenderer: h(
          ({ name: d }) => c.createElement('span', null, d),
          'nodeRenderer'
        ),
        onClick: h(() => {}, 'onClick'),
        shouldShowArrow: !1,
        shouldShowPlaceholder: !0,
        ...e,
      }
      const {
        expanded: t,
        onClick: r,
        children: n,
        nodeRenderer: o,
        title: a,
        shouldShowArrow: i,
        shouldShowPlaceholder: s,
      } = e
      const l = pt('TreeNode')
      const u = o
      return c.createElement(
        'li',
        {
          'aria-expanded': t,
          role: 'treeitem',
          style: l.treeNodeBase,
          title: a,
        },
        c.createElement(
          'div',
          { style: l.treeNodePreviewContainer, onClick: r },
          i || po.count(n) > 0
            ? c.createElement(wT, { expanded: t, styles: l.treeNodeArrow })
            : s &&
                c.createElement(
                  'span',
                  { style: l.treeNodePlaceholder },
                  '\xA0'
                ),
          c.createElement(u, { ...e })
        ),
        c.createElement(
          'ol',
          { role: 'group', style: l.treeNodeChildNodesContainer },
          t ? n : void 0
        )
      )
    })
    const ii = '$'
    const C0 = '*'
    function to(e, t) {
      return !t(e).next().done
    }
    h(to, 'hasChildNodes')
    const CT = h(
      e =>
        Array.from({ length: e }, (t, r) =>
          [ii].concat(Array.from({ length: r }, () => '*')).join('.')
        ),
      'wildcardPathsFromLevel'
    )
    const DT = h((e, t, r, n, o) => {
      const a = []
        .concat(CT(n))
        .concat(r)
        .filter(s => typeof s === 'string')
      const i = []
      return (
        a.forEach(s => {
          const l = s.split('.')
          const u = h((d, m, p) => {
            if (p === l.length) {
              i.push(m)
              return
            }
            const f = l[p]
            if (p === 0) to(d, t) && (f === ii || f === C0) && u(d, ii, p + 1)
            else if (f === C0)
              for (const { name: g, data: y } of t(d))
                to(y, t) && u(y, `${m}.${g}`, p + 1)
            else {
              const g = d[f]
              to(g, t) && u(g, `${m}.${f}`, p + 1)
            }
          }, 'populatePaths')
          u(e, '', 0)
        }),
        i.reduce((s, l) => ((s[l] = !0), s), { ...o })
      )
    }, 'getExpandedPaths')
    var d1 = Xe(e => {
      const { data: t, dataIterator: r, path: n, depth: o, nodeRenderer: a } = e
      const [i, s] = mo(u1)
      const l = to(t, r)
      const u = !!i[n]
      const d = Q(() => l && s(m => ({ ...m, [n]: !u })), [l, s, n, u])
      return c.createElement(
        ST,
        {
          expanded: u,
          onClick: d,
          shouldShowArrow: l,
          shouldShowPlaceholder: o > 0,
          nodeRenderer: a,
          ...e,
        },
        u
          ? [...r(t)].map(({ name: m, data: p, ...f }) =>
              c.createElement(d1, {
                name: m,
                data: p,
                depth: o + 1,
                path: `${n}.${m}`,
                key: m,
                dataIterator: r,
                nodeRenderer: a,
                ...f,
              })
            )
          : null
      )
    })
    const p1 = Xe(
      ({
        name: e,
        data: t,
        dataIterator: r,
        nodeRenderer: n,
        expandPaths: o,
        expandLevel: a,
      }) => {
        const i = pt('TreeView')
        const s = z({})
        const [, l] = s
        return (
          ho(() => l(u => DT(t, r, o, a, u)), [t, r, o, a]),
          c.createElement(
            u1.Provider,
            { value: s },
            c.createElement(
              'ol',
              { role: 'tree', style: i.treeViewOutline },
              c.createElement(d1, {
                name: e,
                data: t,
                dataIterator: r,
                depth: 0,
                path: ii,
                nodeRenderer: n,
              })
            )
          )
        )
      }
    )
    const pc = h(({ name: e, dimmed: t = !1, styles: r = {} }) => {
      const n = pt('ObjectName')
      const o = { ...n.base, ...(t ? n.dimmed : {}), ...r }
      return c.createElement('span', { style: o }, e)
    }, 'ObjectName')
    const ro = h(({ object: e, styles: t }) => {
      const r = pt('ObjectValue')
      const n = h(o => ({ ...r[o], ...t }), 'mkStyle')
      switch (typeof e) {
        case 'bigint':
          return c.createElement(
            'span',
            { style: n('objectValueNumber') },
            String(e),
            'n'
          )
        case 'number':
          return c.createElement(
            'span',
            { style: n('objectValueNumber') },
            String(e)
          )
        case 'string':
          return c.createElement(
            'span',
            { style: n('objectValueString') },
            '"',
            e,
            '"'
          )
        case 'boolean':
          return c.createElement(
            'span',
            { style: n('objectValueBoolean') },
            String(e)
          )
        case 'undefined':
          return c.createElement(
            'span',
            { style: n('objectValueUndefined') },
            'undefined'
          )
        case 'object':
          return e === null
            ? c.createElement('span', { style: n('objectValueNull') }, 'null')
            : e instanceof Date
              ? c.createElement('span', null, e.toString())
              : e instanceof RegExp
                ? c.createElement(
                    'span',
                    { style: n('objectValueRegExp') },
                    e.toString()
                  )
                : Array.isArray(e)
                  ? c.createElement('span', null, `Array(${e.length})`)
                  : e.constructor
                    ? typeof e.constructor.isBuffer === 'function' &&
                      e.constructor.isBuffer(e)
                      ? c.createElement('span', null, `Buffer[${e.length}]`)
                      : c.createElement('span', null, e.constructor.name)
                    : c.createElement('span', null, 'Object')
        case 'function':
          return c.createElement(
            'span',
            null,
            c.createElement(
              'span',
              { style: n('objectValueFunctionPrefix') },
              '\u0192\xA0'
            ),
            c.createElement(
              'span',
              { style: n('objectValueFunctionName') },
              e.name,
              '()'
            )
          )
        case 'symbol':
          return c.createElement(
            'span',
            { style: n('objectValueSymbol') },
            e.toString()
          )
        default:
          return c.createElement('span', null)
      }
    }, 'ObjectValue')
    const m1 = Object.prototype.hasOwnProperty
    const TT = Object.prototype.propertyIsEnumerable
    function si(e, t) {
      const r = Object.getOwnPropertyDescriptor(e, t)
      if (r.get)
        try {
          return r.get()
        } catch {
          return r.get
        }
      return e[t]
    }
    h(si, 'getPropertyValue')
    function Fu(e, t) {
      return e.length === 0
        ? []
        : e.slice(1).reduce((r, n) => r.concat([t, n]), [e[0]])
    }
    h(Fu, 'intersperse')
    const Pu = h(({ data: e }) => {
      const t = pt('ObjectPreview')
      const r = e
      if (
        typeof r !== 'object' ||
        r === null ||
        r instanceof Date ||
        r instanceof RegExp
      )
        return c.createElement(ro, { object: r })
      if (Array.isArray(r)) {
        const n = t.arrayMaxProperties
        const o = r
          .slice(0, n)
          .map((i, s) => c.createElement(ro, { key: s, object: i }))
        r.length > n &&
          o.push(c.createElement('span', { key: 'ellipsis' }, '\u2026'))
        const a = r.length
        return c.createElement(
          c.Fragment,
          null,
          c.createElement(
            'span',
            { style: t.objectDescription },
            a === 0 ? '' : `(${a})\xA0`
          ),
          c.createElement('span', { style: t.preview }, '[', Fu(o, ', '), ']')
        )
      } else {
        const n = t.objectMaxProperties
        const o = []
        for (const i in r)
          if (m1.call(r, i)) {
            let s
            o.length === n - 1 &&
              Object.keys(r).length > n &&
              (s = c.createElement('span', { key: 'ellipsis' }, '\u2026'))
            const l = si(r, i)
            if (
              (o.push(
                c.createElement(
                  'span',
                  { key: i },
                  c.createElement(pc, { name: i || '""' }),
                  ':\xA0',
                  c.createElement(ro, { object: l }),
                  s
                )
              ),
              s)
            )
              break
          }
        const a = r.constructor ? r.constructor.name : 'Object'
        return c.createElement(
          c.Fragment,
          null,
          c.createElement(
            'span',
            { style: t.objectDescription },
            a === 'Object' ? '' : `${a} `
          ),
          c.createElement('span', { style: t.preview }, '{', Fu(o, ', '), '}')
        )
      }
    }, 'ObjectPreview')
    const kT = h(
      ({ name: e, data: t }) =>
        typeof e === 'string'
          ? c.createElement(
              'span',
              null,
              c.createElement(pc, { name: e }),
              c.createElement('span', null, ': '),
              c.createElement(Pu, { data: t })
            )
          : c.createElement(Pu, { data: t }),
      'ObjectRootLabel'
    )
    const OT = h(({ name: e, data: t, isNonenumerable: r = !1 }) => {
      const n = t
      return c.createElement(
        'span',
        null,
        typeof e === 'string'
          ? c.createElement(pc, { name: e, dimmed: r })
          : c.createElement(Pu, { data: e }),
        c.createElement('span', null, ': '),
        c.createElement(ro, { object: n })
      )
    }, 'ObjectLabel')
    const IT = h(
      (e, t) =>
        h(function* (r) {
          if (
            !((typeof r === 'object' && r !== null) || typeof r === 'function')
          )
            return
          const n = Array.isArray(r)
          if (!n && r[Symbol.iterator]) {
            let o = 0
            for (const a of r) {
              if (Array.isArray(a) && a.length === 2) {
                const [i, s] = a
                yield { name: i, data: s }
              } else yield { name: o.toString(), data: a }
              o++
            }
          } else {
            const o = Object.getOwnPropertyNames(r)
            t === !0 && !n ? o.sort() : typeof t === 'function' && o.sort(t)
            for (const a of o)
              if (TT.call(r, a)) {
                const i = si(r, a)
                yield { name: a || '""', data: i }
              } else if (e) {
                let i
                try {
                  i = si(r, a)
                } catch {}
                i !== void 0 &&
                  (yield { name: a, data: i, isNonenumerable: !0 })
              }
            e &&
              r !== Object.prototype &&
              (yield {
                name: '__proto__',
                data: Object.getPrototypeOf(r),
                isNonenumerable: !0,
              })
          }
        }, 'objectIterator'),
      'createIterator'
    )
    const RT = h(
      ({ depth: e, name: t, data: r, isNonenumerable: n }) =>
        e === 0
          ? c.createElement(kT, { name: t, data: r })
          : c.createElement(OT, { name: t, data: r, isNonenumerable: n }),
      'defaultNodeRenderer'
    )
    const BT = h(
      ({
        showNonenumerable: e = !1,
        sortObjectKeys: t,
        nodeRenderer: r,
        ...n
      }) => {
        const o = IT(e, t)
        const a = r || RT
        return c.createElement(p1, { nodeRenderer: a, dataIterator: o, ...n })
      },
      'ObjectInspector'
    )
    const _T = dc(BT)
    function h1(e) {
      if (typeof e === 'object') {
        let t = []
        if (Array.isArray(e)) {
          const n = e.length
          t = [...Array(n).keys()]
        } else e !== null && (t = Object.keys(e))
        const r = t.reduce((n, o) => {
          const a = e[o]
          return (
            typeof a === 'object' &&
              a !== null &&
              Object.keys(a).reduce(
                (i, s) => (i.includes(s) || i.push(s), i),
                n
              ),
            n
          )
        }, [])
        return { rowHeaders: t, colHeaders: r }
      }
    }
    h(h1, 'getHeaders')
    const FT = h(({ rows: e, columns: t, rowsData: r }) => {
      const n = pt('TableInspectorDataContainer')
      const o = pt('TableInspectorLeftBorder')
      return c.createElement(
        'div',
        { style: n.div },
        c.createElement(
          'table',
          { style: n.table },
          c.createElement('colgroup', null),
          c.createElement(
            'tbody',
            null,
            e.map((a, i) =>
              c.createElement(
                'tr',
                { key: a, style: n.tr },
                c.createElement('td', { style: { ...n.td, ...o.none } }, a),
                t.map(s => {
                  const l = r[i]
                  return typeof l === 'object' && l !== null && m1.call(l, s)
                    ? c.createElement(
                        'td',
                        { key: s, style: { ...n.td, ...o.solid } },
                        c.createElement(ro, { object: l[s] })
                      )
                    : c.createElement('td', {
                        key: s,
                        style: { ...n.td, ...o.solid },
                      })
                })
              )
            )
          )
        )
      )
    }, 'DataContainer')
    const PT = h(
      e =>
        c.createElement(
          'div',
          {
            style: {
              position: 'absolute',
              top: 1,
              right: 0,
              bottom: 1,
              display: 'flex',
              alignItems: 'center',
            },
          },
          e.children
        ),
      'SortIconContainer'
    )
    const NT = h(({ sortAscending: e }) => {
      const t = pt('TableInspectorSortIcon')
      const r = e ? '\u25B2' : '\u25BC'
      return c.createElement('div', { style: t }, r)
    }, 'SortIcon')
    const D0 = h(
      ({
        sortAscending: e = !1,
        sorted: t = !1,
        onClick: r = void 0,
        borderStyle: n = {},
        children: o,
        ...a
      }) => {
        const i = pt('TableInspectorTH')
        const [s, l] = z(!1)
        const u = Q(() => l(!0), [])
        const d = Q(() => l(!1), [])
        return c.createElement(
          'th',
          {
            ...a,
            style: { ...i.base, ...n, ...(s ? i.base[':hover'] : {}) },
            onMouseEnter: u,
            onMouseLeave: d,
            onClick: r,
          },
          c.createElement('div', { style: i.div }, o),
          t &&
            c.createElement(PT, null, c.createElement(NT, { sortAscending: e }))
        )
      },
      'TH'
    )
    const LT = h(
      ({
        indexColumnText: e = '(index)',
        columns: t = [],
        sorted: r,
        sortIndexColumn: n,
        sortColumn: o,
        sortAscending: a,
        onTHClick: i,
        onIndexTHClick: s,
      }) => {
        const l = pt('TableInspectorHeaderContainer')
        const u = pt('TableInspectorLeftBorder')
        return c.createElement(
          'div',
          { style: l.base },
          c.createElement(
            'table',
            { style: l.table },
            c.createElement(
              'tbody',
              null,
              c.createElement(
                'tr',
                null,
                c.createElement(
                  D0,
                  {
                    borderStyle: u.none,
                    sorted: r && n,
                    sortAscending: a,
                    onClick: s,
                  },
                  e
                ),
                t.map(d =>
                  c.createElement(
                    D0,
                    {
                      borderStyle: u.solid,
                      key: d,
                      sorted: r && o === d,
                      sortAscending: a,
                      onClick: i.bind(null, d),
                    },
                    d
                  )
                )
              )
            )
          )
        )
      },
      'HeaderContainer'
    )
    const jT = h(({ data: e, columns: t }) => {
      const r = pt('TableInspector')
      const [
        { sorted: n, sortIndexColumn: o, sortColumn: a, sortAscending: i },
        s,
      ] = z({
        sorted: !1,
        sortIndexColumn: !1,
        sortColumn: void 0,
        sortAscending: !1,
      })
      const l = Q(() => {
        s(({ sortIndexColumn: g, sortAscending: y }) => ({
          sorted: !0,
          sortIndexColumn: !0,
          sortColumn: void 0,
          sortAscending: g ? !y : !0,
        }))
      }, [])
      const u = Q(g => {
        s(({ sortColumn: y, sortAscending: E }) => ({
          sorted: !0,
          sortIndexColumn: !1,
          sortColumn: g,
          sortAscending: g === y ? !E : !0,
        }))
      }, [])
      if (typeof e !== 'object' || e === null)
        return c.createElement('div', null)
      let { rowHeaders: d, colHeaders: m } = h1(e)
      t !== void 0 && (m = t)
      let p = d.map(g => e[g])
      let f
      if (
        (a !== void 0
          ? (f = p.map((g, y) =>
              typeof g === 'object' && g !== null ? [g[a], y] : [void 0, y]
            ))
          : o && (f = d.map((g, y) => [d[y], y])),
        f !== void 0)
      ) {
        const g = h(
          (E, b) => (x, S) => {
            const T = E(x)
            const _ = E(S)
            const O = typeof T
            const k = typeof _
            const B = h((L, j) => (L < j ? -1 : L > j ? 1 : 0), 'lt')
            let P
            if (O === k) P = B(T, _)
            else {
              const L = {
                string: 0,
                number: 1,
                object: 2,
                symbol: 3,
                boolean: 4,
                undefined: 5,
                function: 6,
              }
              P = B(L[O], L[k])
            }
            return (b || (P = -P), P)
          },
          'comparator'
        )
        const y = f.sort(g(E => E[0], i)).map(E => E[1])
        ;((d = y.map(E => d[E])), (p = y.map(E => p[E])))
      }
      return c.createElement(
        'div',
        { style: r.base },
        c.createElement(LT, {
          columns: m,
          sorted: n,
          sortIndexColumn: o,
          sortColumn: a,
          sortAscending: i,
          onTHClick: u,
          onIndexTHClick: l,
        }),
        c.createElement(FT, { rows: d, columns: m, rowsData: p })
      )
    }, 'TableInspector')
    const MT = dc(jT)
    const $T = 80
    const f1 = h(
      e =>
        e.childNodes.length === 0 ||
        (e.childNodes.length === 1 &&
          e.childNodes[0].nodeType === Node.TEXT_NODE &&
          e.textContent.length < $T),
      'shouldInline'
    )
    const qT = h(
      ({ tagName: e, attributes: t, styles: r }) =>
        c.createElement(
          'span',
          { style: r.base },
          '<',
          c.createElement('span', { style: r.tagName }, e),
          (() => {
            if (t) {
              const n = []
              for (let o = 0; o < t.length; o++) {
                const a = t[o]
                n.push(
                  c.createElement(
                    'span',
                    { key: o },
                    ' ',
                    c.createElement(
                      'span',
                      { style: r.htmlAttributeName },
                      a.name
                    ),
                    '="',
                    c.createElement(
                      'span',
                      { style: r.htmlAttributeValue },
                      a.value
                    ),
                    '"'
                  )
                )
              }
              return n
            }
          })(),
          '>'
        ),
      'OpenTag'
    )
    const T0 = h(
      ({ tagName: e, isChildNode: t = !1, styles: r }) =>
        c.createElement(
          'span',
          { style: Object.assign({}, r.base, t && r.offsetLeft) },
          '</',
          c.createElement('span', { style: r.tagName }, e),
          '>'
        ),
      'CloseTag'
    )
    const UT = {
      1: 'ELEMENT_NODE',
      3: 'TEXT_NODE',
      7: 'PROCESSING_INSTRUCTION_NODE',
      8: 'COMMENT_NODE',
      9: 'DOCUMENT_NODE',
      10: 'DOCUMENT_TYPE_NODE',
      11: 'DOCUMENT_FRAGMENT_NODE',
    }
    const HT = h(({ isCloseTag: e, data: t, expanded: r }) => {
      const n = pt('DOMNodePreview')
      if (e)
        return c.createElement(T0, {
          styles: n.htmlCloseTag,
          isChildNode: !0,
          tagName: t.tagName,
        })
      switch (t.nodeType) {
        case Node.ELEMENT_NODE:
          return c.createElement(
            'span',
            null,
            c.createElement(qT, {
              tagName: t.tagName,
              attributes: t.attributes,
              styles: n.htmlOpenTag,
            }),
            f1(t) ? t.textContent : !r && '\u2026',
            !r &&
              c.createElement(T0, {
                tagName: t.tagName,
                styles: n.htmlCloseTag,
              })
          )
        case Node.TEXT_NODE:
          return c.createElement('span', null, t.textContent)
        case Node.CDATA_SECTION_NODE:
          return c.createElement(
            'span',
            null,
            '<![CDATA[' + t.textContent + ']]>'
          )
        case Node.COMMENT_NODE:
          return c.createElement(
            'span',
            { style: n.htmlComment },
            '<!--',
            t.textContent,
            '-->'
          )
        case Node.PROCESSING_INSTRUCTION_NODE:
          return c.createElement('span', null, t.nodeName)
        case Node.DOCUMENT_TYPE_NODE:
          return c.createElement(
            'span',
            { style: n.htmlDoctype },
            '<!DOCTYPE ',
            t.name,
            t.publicId ? ` PUBLIC "${t.publicId}"` : '',
            !t.publicId && t.systemId ? ' SYSTEM' : '',
            t.systemId ? ` "${t.systemId}"` : '',
            '>'
          )
        case Node.DOCUMENT_NODE:
          return c.createElement('span', null, t.nodeName)
        case Node.DOCUMENT_FRAGMENT_NODE:
          return c.createElement('span', null, t.nodeName)
        default:
          return c.createElement('span', null, UT[t.nodeType])
      }
    }, 'DOMNodePreview')
    const VT = h(function* (e) {
      if (e && e.childNodes) {
        if (f1(e)) return
        for (let t = 0; t < e.childNodes.length; t++) {
          const r = e.childNodes[t]
          ;(r.nodeType === Node.TEXT_NODE &&
            r.textContent.trim().length === 0) ||
            (yield { name: `${r.tagName}[${t}]`, data: r })
        }
        e.tagName &&
          (yield {
            name: 'CLOSE_TAG',
            data: { tagName: e.tagName },
            isCloseTag: !0,
          })
      }
    }, 'domIterator')
    const zT = h(
      e => c.createElement(p1, { nodeRenderer: HT, dataIterator: VT, ...e }),
      'DOMInspector'
    )
    const GT = dc(zT)
    const WT = yT(vT())
    const YT = h(
      ({ table: e = !1, data: t, ...r }) =>
        e
          ? c.createElement(MT, { data: t, ...r })
          : (0, WT.default)(t)
            ? c.createElement(GT, { data: t, ...r })
            : c.createElement(_T, { data: t, ...r }),
      'Inspector'
    )
    const KT = R.div({
      display: 'flex',
      padding: 0,
      borderLeft: '5px solid transparent',
      borderBottom: '1px solid transparent',
      transition: 'all 0.1s',
      alignItems: 'flex-start',
      whiteSpace: 'pre',
    })
    const XT = R.div(({ theme: e }) => ({
      backgroundColor: Zn(0.5, e.appBorderColor),
      color: e.color.inverseText,
      fontSize: e.typography.size.s1,
      fontWeight: e.typography.weight.bold,
      lineHeight: 1,
      padding: '1px 5px',
      borderRadius: 20,
      margin: '2px 0px',
    }))
    const JT = R.div({ flex: 1, padding: '0 0 0 5px' })
    const g1 = vc(({ children: e, className: t }, r) =>
      c.createElement(
        Si,
        { ref: r, horizontal: !0, vertical: !0, className: t },
        e
      )
    )
    g1.displayName = 'UnstyledWrapped'
    const ZT = R(g1)({ margin: 0, padding: '10px 5px 20px' })
    const QT = ed(({ theme: e, ...t }) =>
      c.createElement(YT, {
        theme: e.addonActionsTheme || 'chromeLight',
        table: !1,
        ...t,
      })
    )
    const ek = h(({ actions: e, onClear: t }) => {
      const r = ye(null)
      const n = r.current
      const o = n && n.scrollHeight - n.scrollTop === n.clientHeight
      return (
        X(() => {
          o && (r.current.scrollTop = r.current.scrollHeight)
        }, [o, e.length]),
        c.createElement(
          ft,
          null,
          c.createElement(
            ZT,
            { ref: r },
            e.map(a =>
              c.createElement(
                KT,
                { key: a.id },
                a.count > 1 && c.createElement(XT, null, a.count),
                c.createElement(
                  JT,
                  null,
                  c.createElement(QT, {
                    sortObjectKeys: !0,
                    showNonenumerable: !1,
                    name: a.data.name,
                    data: a.data.args ?? a.data,
                  })
                )
              )
            )
          ),
          c.createElement(Cn, { actionItems: [{ title: 'Clear', onClick: t }] })
        )
      )
    }, 'ActionLogger')
    const tk = h((e, t) => {
      try {
        return fr(e, t)
      } catch {
        return !1
      }
    }, 'safeDeepEqual')
    const y1 = class extends Et {
      constructor(t) {
        ;(super(t),
          (this.handleStoryChange = h(() => {
            const { actions: r } = this.state
            r.length > 0 &&
              r[0].options.clearOnStoryChange &&
              this.clearActions()
          }, 'handleStoryChange')),
          (this.addAction = h(r => {
            this.setState(n => {
              const o = [...n.actions]
              const a = o.length && o[o.length - 1]
              return (
                a && tk(a.data, r.data)
                  ? a.count++
                  : ((r.count = 1), o.push(r)),
                { actions: o.slice(0, r.options.limit) }
              )
            })
          }, 'addAction')),
          (this.clearActions = h(() => {
            const { api: r } = this.props
            ;(r.emit(i1), this.setState({ actions: [] }))
          }, 'clearActions')),
          (this.mounted = !1),
          (this.state = { actions: [] }))
      }
      componentDidMount() {
        this.mounted = !0
        const { api: t } = this.props
        ;(t.on(Bu, this.addAction), t.on(Er, this.handleStoryChange))
      }
      componentWillUnmount() {
        this.mounted = !1
        const { api: t } = this.props
        ;(t.off(Er, this.handleStoryChange), t.off(Bu, this.addAction))
      }
      render() {
        const { actions: t = [] } = this.state
        const { active: r } = this.props
        const n = { actions: t, onClear: this.clearActions }
        return r ? c.createElement(ek, { ...n }) : null
      }
    }
    h(y1, 'ActionLogger')
    const rk = y1
    const D7 = ve.register(lo, e => {
      globalThis?.FEATURES?.actions &&
        ve.add(a1, {
          title: s1,
          type: et.PANEL,
          render: h(
            ({ active: t }) => c.createElement(rk, { api: e, active: !!t }),
            'render'
          ),
          paramKey: cT,
        })
    })
    const gi = 'storybook/interactions'
    const mc = `${gi}/panel`
    const nk = 'writing-tests/integrations/vitest-addon'
    const ok = `${nk}#what-happens-when-there-are-different-test-results-in-multiple-environments`
    const ak =
      'writing-stories/play-function#writing-stories-with-the-play-function'
    const Lt = 'internal_render_call'
    const Pr = 'storybook/a11y'
    const F7 = `${Pr}/panel`
    const P7 = `${Pr}/result`
    const N7 = `${Pr}/request`
    const L7 = `${Pr}/running`
    const j7 = `${Pr}/error`
    const M7 = `${Pr}/manual`
    const $7 = `${Pr}/select`
    const ik = 'writing-tests/accessibility-testing'
    const q7 = `${ik}#why-are-my-tests-failing-in-different-environments`
    const b1 = 'storybook/test'
    const U7 = `${b1}/test-provider`
    const sk = 'STORYBOOK_ADDON_TEST_CHANNEL'
    const lk = 'writing-tests/integrations/vitest-addon'
    const H7 = `${lk}#what-happens-if-vitest-itself-has-an-error`
    const uk = {
      id: b1,
      initialState: {
        config: { coverage: !1, a11y: !1 },
        watching: !1,
        cancelling: !1,
        fatalError: void 0,
        indexUrl: void 0,
        previewAnnotations: [],
        currentRun: {
          triggeredBy: void 0,
          config: { coverage: !1, a11y: !1 },
          componentTestCount: { success: 0, error: 0 },
          a11yCount: { success: 0, warning: 0, error: 0 },
          storyIds: void 0,
          totalTestCount: void 0,
          startedAt: void 0,
          finishedAt: void 0,
          unhandledErrors: [],
          coverageSummary: void 0,
        },
      },
    }
    const V7 = `UNIVERSAL_STORE:${uk.id}`
    const ck = 'storybook/component-test'
    const kr = {
      CALL: 'storybook/instrumenter/call',
      SYNC: 'storybook/instrumenter/sync',
      START: 'storybook/instrumenter/start',
      BACK: 'storybook/instrumenter/back',
      GOTO: 'storybook/instrumenter/goto',
      NEXT: 'storybook/instrumenter/next',
      END: 'storybook/instrumenter/end',
    }
    const dk = it(hC(), 1)
    function E1({ onlyFirst: e = !1 } = {}) {
      const t = [
        '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))',
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))',
      ].join('|')
      return new RegExp(t, e ? void 0 : 'g')
    }
    h(E1, 'ansiRegex')
    const pk = E1()
    function v1(e) {
      if (typeof e !== 'string')
        throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``)
      return e.replace(pk, '')
    }
    h(v1, 'stripAnsi')
    function A1(e) {
      return hc(e) || fc(e)
    }
    h(A1, 'isTestAssertionError')
    function hc(e) {
      return (
        e &&
        typeof e === 'object' &&
        'name' in e &&
        typeof e.name === 'string' &&
        e.name === 'AssertionError'
      )
    }
    h(hc, 'isChaiError')
    function fc(e) {
      return (
        e &&
        typeof e === 'object' &&
        'message' in e &&
        typeof e.message === 'string' &&
        v1(e.message).startsWith('expect(')
      )
    }
    h(fc, 'isJestError')
    function x1(e) {
      return new dk.default({
        escapeXML: !0,
        fg: e.color.defaultText,
        bg: e.background.content,
      })
    }
    h(x1, 'createAnsiToHtmlFilter')
    function yi() {
      const e = Qe()
      return x1(e)
    }
    h(yi, 'useAnsiToHtmlFilter')
    const mk = R.div(
      ({ theme: { color: e, typography: t, background: r } }) => ({
        textAlign: 'start',
        padding: '11px 15px',
        fontSize: `${t.size.s2 - 1}px`,
        fontWeight: t.weight.regular,
        lineHeight: '1rem',
        background: r.app,
        borderBottom: `1px solid ${e.border}`,
        color: e.defaultText,
        backgroundClip: 'padding-box',
        position: 'relative',
      })
    )
    const hk = h(
      ({ storyUrl: e }) =>
        c.createElement(
          mk,
          null,
          'Debugger controls are not available on composed Storybooks.',
          ' ',
          c.createElement(
            Ze,
            {
              href: `${e}&addonPanel=${mc}`,
              target: '_blank',
              rel: 'noopener noreferrer',
              withArrow: !0,
            },
            'Open in external Storybook'
          )
        ),
      'DetachedDebuggerMessage'
    )
    const fk = R.div(({ theme: e }) => ({
      display: 'flex',
      fontSize: e.typography.size.s2 - 1,
      gap: 25,
    }))
    const gk = h(() => {
      const [e, t] = z(!0)
      const r = tt().getDocsUrl({ subpath: ak, versioned: !0, renderer: !0 })
      return (
        X(() => {
          const n = setTimeout(() => {
            t(!1)
          }, 100)
          return () => clearTimeout(n)
        }, []),
        e
          ? null
          : c.createElement(
              'div',
              null,
              c.createElement(kn, {
                title: 'Interactions',
                description: c.createElement(
                  c.Fragment,
                  null,
                  "Interactions allow you to verify the functional aspects of UIs. Write a play function for your story and you'll see it run here."
                ),
                footer: c.createElement(
                  fk,
                  null,
                  c.createElement(
                    Ze,
                    { href: r, target: '_blank', withArrow: !0 },
                    c.createElement(yr, null),
                    ' Read docs'
                  )
                ),
              })
            )
      )
    }, 'Empty')
    const yk = it(Yu())
    const bk = it(Ku())
    function li(e) {
      let t
      let r
      let n = ''
      if (e)
        if (typeof e === 'object')
          if (Array.isArray(e))
            for (t = 0; t < e.length; t++)
              e[t] && (r = li(e[t])) && (n && (n += ' '), (n += r))
          else for (t in e) e[t] && (r = li(t)) && (n && (n += ' '), (n += r))
        else typeof e !== 'boolean' && !e.call && (n && (n += ' '), (n += e))
      return n
    }
    h(li, 'toVal')
    function kt() {
      for (var e = 0, t, r = ''; e < arguments.length; )
        (t = li(arguments[e++])) && (r && (r += ' '), (r += t))
      return r
    }
    h(kt, 'default')
    const gc = h(
      e =>
        Array.isArray(e) || (ArrayBuffer.isView(e) && !(e instanceof DataView)),
      'isArray'
    )
    const w1 = h(
      e =>
        e !== null &&
        typeof e === 'object' &&
        !gc(e) &&
        !(e instanceof Date) &&
        !(e instanceof RegExp) &&
        !(e instanceof Error) &&
        !(e instanceof WeakMap) &&
        !(e instanceof WeakSet),
      'isObject'
    )
    const Ek = h(
      e => w1(e) || gc(e) || typeof e === 'function' || e instanceof Promise,
      'isKnownObject'
    )
    const S1 = h(e => {
      const t = /unique/
      return Promise.race([e, t]).then(
        r => (r === t ? ['pending'] : ['fulfilled', r]),
        r => ['rejected', r]
      )
    }, 'getPromiseState')
    var Pt = h(async (e, t, r, n, o, a) => {
      const i = { key: e, depth: r, value: t, type: 'value', parent: void 0 }
      if (t && Ek(t) && r < 100) {
        const s = []
        let l = 'object'
        if (gc(t)) {
          for (let u = 0; u < t.length; u++)
            s.push(async () => {
              const d = await Pt(u.toString(), t[u], r + 1, n)
              return ((d.parent = i), d)
            })
          l = 'array'
        } else {
          const u = Object.getOwnPropertyNames(t)
          n && u.sort()
          for (let d = 0; d < u.length; d++) {
            let m
            try {
              m = t[u[d]]
            } catch {}
            s.push(async () => {
              const p = await Pt(u[d], m, r + 1, n)
              return ((p.parent = i), p)
            })
          }
          if (
            (typeof t === 'function' && (l = 'function'), t instanceof Promise)
          ) {
            const [d, m] = await S1(t)
            ;(s.push(async () => {
              const p = await Pt('<state>', d, r + 1, n)
              return ((p.parent = i), p)
            }),
              d !== 'pending' &&
                s.push(async () => {
                  const p = await Pt('<value>', m, r + 1, n)
                  return ((p.parent = i), p)
                }),
              (l = 'promise'))
          }
          if (t instanceof Map) {
            const d = Array.from(t.entries()).map(m => {
              const [p, f] = m
              return { '<key>': p, '<value>': f }
            })
            ;(s.push(async () => {
              const m = await Pt('<entries>', d, r + 1, n)
              return ((m.parent = i), m)
            }),
              s.push(async () => {
                const m = await Pt('size', t.size, r + 1, n)
                return ((m.parent = i), m)
              }),
              (l = 'map'))
          }
          if (t instanceof Set) {
            const d = Array.from(t.entries()).map(m => m[1])
            ;(s.push(async () => {
              const m = await Pt('<entries>', d, r + 1, n)
              return ((m.parent = i), m)
            }),
              s.push(async () => {
                const m = await Pt('size', t.size, r + 1, n)
                return ((m.parent = i), m)
              }),
              (l = 'set'))
          }
        }
        ;(t !== Object.prototype &&
          a &&
          s.push(async () => {
            const u = await Pt(
              '<prototype>',
              Object.getPrototypeOf(t),
              r + 1,
              n,
              !0
            )
            return ((u.parent = i), u)
          }),
          (i.type = l),
          (i.children = s),
          (i.isPrototype = o))
      }
      return i
    }, 'buildAST')
    const vk = h(
      (e, t, r) =>
        Pt('root', e, 0, t === !1 ? t : !0, void 0, r === !1 ? r : !0),
      'parse'
    )
    const k0 = it(yC())
    const Ak = it(EC())
    const xk = ['children']
    const Nu = c.createContext({ theme: 'chrome', colorScheme: 'light' })
    const wk = h(e => {
      const { children: t } = e
      const r = (0, Ak.default)(e, xk)
      const n = c.useContext(Nu)
      return c.createElement(
        Nu.Provider,
        { value: (0, k0.default)((0, k0.default)({}, n), r) },
        t
      )
    }, 'ThemeProvider')
    const bi = h((e, t = {}) => {
      const r = c.useContext(Nu)
      const n = e.theme || r.theme || 'chrome'
      const o = e.colorScheme || r.colorScheme || 'light'
      const a = kt(t[n], t[o])
      return { currentColorScheme: o, currentTheme: n, themeClass: a }
    }, 'useTheme')
    const O0 = it(AC())
    const lu = it(xC())
    const Sk = it(SC())
    const Ck = c.createContext({ isChild: !1, depth: 0, hasHover: !0 })
    const uu = Ck
    const nt = {
      tree: 'Tree-tree-fbbbe38',
      item: 'Tree-item-353d6f3',
      group: 'Tree-group-d3c3d8a',
      label: 'Tree-label-d819155',
      focusWhite: 'Tree-focusWhite-f1e00c2',
      arrow: 'Tree-arrow-03ab2e7',
      hover: 'Tree-hover-3cc4e5d',
      open: 'Tree-open-3f1a336',
      dark: 'Tree-dark-1b4aa00',
      chrome: 'Tree-chrome-bcbcac6',
      light: 'Tree-light-09174ee',
    }
    const Dk = [
      'theme',
      'hover',
      'colorScheme',
      'children',
      'label',
      'className',
      'onUpdate',
      'onSelect',
      'open',
    ]
    var ui = h(e => {
      const {
        theme: t,
        hover: r,
        colorScheme: n,
        children: o,
        label: a,
        className: i,
        onUpdate: s,
        onSelect: l,
        open: u,
      } = e
      const d = (0, Sk.default)(e, Dk)
      const { themeClass: m, currentTheme: p } = bi(
        { theme: t, colorScheme: n },
        nt
      )
      const [f, g] = z(u)
      X(() => {
        g(u)
      }, [u])
      const y = h(F => {
        ;(g(F), s && s(F))
      }, 'updateState')
      const E = c.Children.count(o) > 0
      const b = h((F, M) => {
        if (F.isSameNode(M || null)) return
        ;(F.querySelector('[tabindex="-1"]')?.focus(),
          F.setAttribute('aria-selected', 'true'),
          M?.removeAttribute('aria-selected'))
      }, 'updateFocus')
      const x = h((F, M) => {
        let q = F
        for (; q && q.parentElement; ) {
          if (q.getAttribute('role') === M) return q
          q = q.parentElement
        }
        return null
      }, 'getParent')
      const S = h(F => {
        const M = x(F, 'tree')
        return M ? Array.from(M.querySelectorAll('li')) : []
      }, 'getListElements')
      const T = h(F => {
        const M = x(F, 'group')
        const q = M?.previousElementSibling
        if (q && q.getAttribute('tabindex') === '-1') {
          const V = q.parentElement
          const G = F.parentElement
          b(V, G)
        }
      }, 'moveBack')
      const _ = h((F, M) => {
        const q = S(F)
        ;(q.forEach(V => {
          V.removeAttribute('aria-selected')
        }),
          M === 'start' && q[0] && b(q[0]),
          M === 'end' && q[q.length - 1] && b(q[q.length - 1]))
      }, 'moveHome')
      const O = h((F, M) => {
        const q = S(F) || []
        for (let V = 0; V < q.length; V++) {
          const G = q[V]
          if (G.getAttribute('aria-selected') === 'true') {
            M === 'up' && q[V - 1]
              ? b(q[V - 1], G)
              : M === 'down' && q[V + 1] && b(q[V + 1], G)
            return
          }
        }
        b(q[0])
      }, 'moveFocusAdjacent')
      const k = h((F, M) => {
        const q = F.target
        ;((F.key === 'Enter' || F.key === ' ') && y(!f),
          F.key === 'ArrowRight' && f && !M
            ? O(q, 'down')
            : F.key === 'ArrowRight' && y(!0),
          F.key === 'ArrowLeft' && (!f || M)
            ? T(q)
            : F.key === 'ArrowLeft' && y(!1),
          F.key === 'ArrowDown' && O(q, 'down'),
          F.key === 'ArrowUp' && O(q, 'up'),
          F.key === 'Home' && _(q, 'start'),
          F.key === 'End' && _(q, 'end'))
      }, 'handleKeypress')
      const B = h((F, M) => {
        const q = F.target
        const V = x(q, 'treeitem')
        const G = S(q) || []
        let se = !1
        for (let pe = 0; pe < G.length; pe++) {
          const ae = G[pe]
          if (ae.getAttribute('aria-selected') === 'true') {
            V && ((se = !0), b(V, ae))
            break
          }
        }
        ;(!se && V && b(V), M || y(!f))
      }, 'handleClick')
      const P = h(F => {
        const M = F.currentTarget
        !M.contains(document.activeElement) &&
          M.getAttribute('role') === 'tree' &&
          M.setAttribute('tabindex', '0')
      }, 'handleBlur')
      const L = h(F => {
        const M = F.target
        if (M.getAttribute('role') === 'tree') {
          const q = M.querySelector('[aria-selected="true"]')
          ;(q ? b(q) : O(M, 'down'), M.setAttribute('tabindex', '-1'))
        }
      }, 'handleFocus')
      const j = h(() => {
        l?.()
      }, 'handleButtonFocus')
      const U = h(F => {
        const M = F * 0.9 + 0.3
        return { paddingLeft: `${M}em`, width: `calc(100% - ${M}em)` }
      }, 'getPaddingStyles')
      const { isChild: $, depth: v, hasHover: A } = c.useContext(uu)
      const D = A ? r : !1
      if (!$)
        return c.createElement(
          'ul',
          (0, lu.default)(
            {
              role: 'tree',
              tabIndex: 0,
              className: kt(nt.tree, nt.group, m, i),
              onFocus: L,
              onBlur: P,
            },
            d
          ),
          c.createElement(
            uu.Provider,
            { value: { isChild: !0, depth: 0, hasHover: D } },
            c.createElement(ui, e)
          )
        )
      if (!E)
        return c.createElement(
          'li',
          (0, lu.default)({ role: 'treeitem', className: nt.item }, d),
          c.createElement(
            'div',
            {
              role: 'button',
              className: kt(nt.label, {
                [nt.hover]: D,
                [nt.focusWhite]: p === 'firefox',
              }),
              tabIndex: -1,
              style: U(v),
              onKeyDown: h(F => {
                k(F, $)
              }, 'onKeyDown'),
              onClick: h(F => B(F, !0), 'onClick'),
              onFocus: j,
            },
            c.createElement('span', null, a)
          )
        )
      const N = kt(nt.arrow, { [nt.open]: f })
      return c.createElement(
        'li',
        { role: 'treeitem', 'aria-expanded': f, className: nt.item },
        c.createElement(
          'div',
          {
            role: 'button',
            tabIndex: -1,
            className: kt(nt.label, {
              [nt.hover]: D,
              [nt.focusWhite]: p === 'firefox',
            }),
            style: U(v),
            onClick: h(F => B(F), 'onClick'),
            onKeyDown: h(F => k(F), 'onKeyDown'),
            onFocus: j,
          },
          c.createElement(
            'span',
            null,
            c.createElement('span', { 'aria-hidden': !0, className: N }),
            c.createElement('span', null, a)
          )
        ),
        c.createElement(
          'ul',
          (0, lu.default)({ role: 'group', className: kt(i, nt.group) }, d),
          f &&
            c.Children.map(o, F =>
              c.createElement(
                uu.Provider,
                { value: { isChild: !0, depth: v + 1, hasHover: D } },
                F
              )
            )
        )
      )
    }, 'Tree')
    ui.defaultProps = { open: !1, hover: !0 }
    const Tk = it(Yu())
    const kk = it(Ku())
    const fe = {
      'object-inspector': 'ObjectInspector-object-inspector-0c33e82',
      objectInspector: 'ObjectInspector-object-inspector-0c33e82',
      'object-label': 'ObjectInspector-object-label-b81482b',
      objectLabel: 'ObjectInspector-object-label-b81482b',
      text: 'ObjectInspector-text-25f57f3',
      key: 'ObjectInspector-key-4f712bb',
      value: 'ObjectInspector-value-f7ec2e5',
      string: 'ObjectInspector-string-c496000',
      regex: 'ObjectInspector-regex-59d45a3',
      error: 'ObjectInspector-error-b818698',
      boolean: 'ObjectInspector-boolean-2dd1642',
      number: 'ObjectInspector-number-a6daabb',
      undefined: 'ObjectInspector-undefined-3a68263',
      null: 'ObjectInspector-null-74acb50',
      function: 'ObjectInspector-function-07bbdcd',
      'function-decorator': 'ObjectInspector-function-decorator-3d22c24',
      functionDecorator: 'ObjectInspector-function-decorator-3d22c24',
      prototype: 'ObjectInspector-prototype-f2449ee',
      dark: 'ObjectInspector-dark-0c96c97',
      chrome: 'ObjectInspector-chrome-2f3ca98',
      light: 'ObjectInspector-light-78bef54',
    }
    const Ok = ['ast', 'theme', 'showKey', 'colorScheme', 'className']
    const ot = h((e, t, r, n, o) => {
      const a = e.includes('-') ? `"${e}"` : e
      const i = o <= 0
      return c.createElement(
        'span',
        { className: fe.text },
        !i &&
          n &&
          c.createElement(
            c.Fragment,
            null,
            c.createElement('span', { className: fe.key }, a),
            c.createElement('span', null, ':\xA0')
          ),
        c.createElement('span', { className: r }, t)
      )
    }, 'buildValue')
    const C1 = h(e => {
      const { ast: t, theme: r, showKey: n, colorScheme: o, className: a } = e
      const i = (0, kk.default)(e, Ok)
      const { themeClass: s } = bi({ theme: r, colorScheme: o }, fe)
      const [l, u] = z(c.createElement('span', null))
      let d = c.createElement('span', null)
      return (
        X(() => {
          t.value instanceof Promise &&
            h(async m => {
              u(ot(t.key, `Promise { "${await S1(m)}" }`, fe.key, n, t.depth))
            }, 'waitForPromiseResult')(t.value)
        }, [t, n]),
        typeof t.value === 'number' || typeof t.value === 'bigint'
          ? (d = ot(t.key, String(t.value), fe.number, n, t.depth))
          : typeof t.value === 'boolean'
            ? (d = ot(t.key, String(t.value), fe.boolean, n, t.depth))
            : typeof t.value === 'string'
              ? (d = ot(t.key, `"${t.value}"`, fe.string, n, t.depth))
              : typeof t.value > 'u'
                ? (d = ot(t.key, 'undefined', fe.undefined, n, t.depth))
                : typeof t.value === 'symbol'
                  ? (d = ot(t.key, t.value.toString(), fe.string, n, t.depth))
                  : typeof t.value === 'function'
                    ? (d = ot(t.key, `${t.value.name}()`, fe.key, n, t.depth))
                    : typeof t.value === 'object' &&
                      (t.value === null
                        ? (d = ot(t.key, 'null', fe.null, n, t.depth))
                        : Array.isArray(t.value)
                          ? (d = ot(
                              t.key,
                              `Array(${t.value.length})`,
                              fe.key,
                              n,
                              t.depth
                            ))
                          : t.value instanceof Date
                            ? (d = ot(
                                t.key,
                                `Date ${t.value.toString()}`,
                                fe.value,
                                n,
                                t.depth
                              ))
                            : t.value instanceof RegExp
                              ? (d = ot(
                                  t.key,
                                  t.value.toString(),
                                  fe.regex,
                                  n,
                                  t.depth
                                ))
                              : t.value instanceof Error
                                ? (d = ot(
                                    t.key,
                                    t.value.toString(),
                                    fe.error,
                                    n,
                                    t.depth
                                  ))
                                : w1(t.value)
                                  ? (d = ot(
                                      t.key,
                                      '{\u2026}',
                                      fe.key,
                                      n,
                                      t.depth
                                    ))
                                  : (d = ot(
                                      t.key,
                                      t.value.constructor.name,
                                      fe.key,
                                      n,
                                      t.depth
                                    ))),
        c.createElement(
          'span',
          (0, Tk.default)({ className: kt(s, a) }, i),
          l,
          d
        )
      )
    }, 'ObjectValue')
    C1.defaultProps = { showKey: !0 }
    const D1 = C1
    const gn = it(Yu())
    const Ik = it(Ku())
    const Rk = [
      'ast',
      'theme',
      'previewMax',
      'open',
      'colorScheme',
      'className',
    ]
    const uo = h((e, t, r) => {
      const n = []
      for (let o = 0; o < e.length; o++) {
        const a = e[o]
        if (
          (a.isPrototype ||
            (n.push(c.createElement(D1, { key: a.key, ast: a, showKey: r })),
            o < e.length - 1 ? n.push(', ') : n.push(' ')),
          a.isPrototype && o === e.length - 1 && (n.pop(), n.push(' ')),
          o === t - 1 && e.length > t)
        ) {
          n.push('\u2026 ')
          break
        }
      }
      return n
    }, 'buildPreview')
    const Bk = h((e, t, r, n) => {
      const o = e.value.length
      return t
        ? c.createElement('span', null, 'Array(', o, ')')
        : c.createElement(
            c.Fragment,
            null,
            c.createElement(
              'span',
              null,
              `${n === 'firefox' ? 'Array' : ''}(${o}) [ `
            ),
            uo(e.children, r, !1),
            c.createElement('span', null, ']')
          )
    }, 'getArrayLabel')
    const _k = h(
      (e, t, r, n) =>
        e.isPrototype
          ? c.createElement(
              'span',
              null,
              `Object ${n === 'firefox' ? '{ \u2026 }' : ''}`
            )
          : t
            ? c.createElement('span', null, '{\u2026}')
            : c.createElement(
                c.Fragment,
                null,
                c.createElement(
                  'span',
                  null,
                  `${n === 'firefox' ? 'Object ' : ''}{ `
                ),
                uo(e.children, r, !0),
                c.createElement('span', null, '}')
              ),
      'getObjectLabel'
    )
    const Fk = h(
      (e, t, r) =>
        t
          ? c.createElement(
              'span',
              null,
              `Promise { "${String(e.children[0].value)}" }`
            )
          : c.createElement(
              c.Fragment,
              null,
              c.createElement('span', null, 'Promise { '),
              uo(e.children, r, !0),
              c.createElement('span', null, '}')
            ),
      'getPromiseLabel'
    )
    const Pk = h((e, t, r, n) => {
      const { size: o } = e.value
      return t
        ? c.createElement('span', null, `Map(${o})`)
        : c.createElement(
            c.Fragment,
            null,
            c.createElement(
              'span',
              null,
              `Map${n === 'chrome' ? `(${o})` : ''} { `
            ),
            uo(e.children, r, !0),
            c.createElement('span', null, '}')
          )
    }, 'getMapLabel')
    const Nk = h((e, t, r) => {
      const { size: n } = e.value
      return t
        ? c.createElement('span', null, 'Set(', n, ')')
        : c.createElement(
            c.Fragment,
            null,
            c.createElement('span', null, `Set(${e.value.size}) {`),
            uo(e.children, r, !0),
            c.createElement('span', null, '}')
          )
    }, 'getSetLabel')
    const T1 = h(e => {
      const {
        ast: t,
        theme: r,
        previewMax: n,
        open: o,
        colorScheme: a,
        className: i,
      } = e
      const s = (0, Ik.default)(e, Rk)
      const { themeClass: l, currentTheme: u } = bi(
        { theme: r, colorScheme: a },
        fe
      )
      const d = t.isPrototype || !1
      const m = kt(fe.objectLabel, l, i, { [fe.prototype]: d })
      const p = t.depth <= 0
      const f = h(
        () =>
          c.createElement(
            'span',
            { className: d ? fe.prototype : fe.key },
            p ? '' : `${t.key}: `
          ),
        'Key'
      )
      return t.type === 'array'
        ? c.createElement(
            'span',
            (0, gn.default)({ className: m }, s),
            c.createElement(f, null),
            Bk(t, o, n, u)
          )
        : t.type === 'function'
          ? c.createElement(
              'span',
              (0, gn.default)({ className: m }, s),
              c.createElement(f, null),
              u === 'chrome' &&
                c.createElement(
                  'span',
                  { className: fe.functionDecorator },
                  '\u0192 '
                ),
              c.createElement(
                'span',
                { className: kt({ [fe.function]: !d }) },
                `${t.value.name}()`
              )
            )
          : t.type === 'promise'
            ? c.createElement(
                'span',
                (0, gn.default)({ className: m }, s),
                c.createElement(f, null),
                Fk(t, o, n)
              )
            : t.type === 'map'
              ? c.createElement(
                  'span',
                  (0, gn.default)({ className: m }, s),
                  c.createElement(f, null),
                  Pk(t, o, n, u)
                )
              : t.type === 'set'
                ? c.createElement(
                    'span',
                    (0, gn.default)({ className: m }, s),
                    c.createElement(f, null),
                    Nk(t, o, n)
                  )
                : c.createElement(
                    'span',
                    (0, gn.default)({ className: m }, s),
                    c.createElement(f, null),
                    _k(t, o, n, u)
                  )
    }, 'ObjectLabel')
    T1.defaultProps = { previewMax: 8, open: !1 }
    const Lk = T1
    var yc = h(e => {
      const { ast: t, expandLevel: r, depth: n } = e
      const [o, a] = z()
      const [i, s] = z(n < r)
      return (
        X(() => {
          h(async () => {
            if (t.type !== 'value') {
              const l = t.children.map(m => m())
              const u = await Promise.all(l)
              const d = (0, O0.default)(
                (0, O0.default)({}, t),
                {},
                { children: u }
              )
              a(d)
            }
          }, 'resolve')()
        }, [t]),
        o
          ? c.createElement(
              ui,
              {
                hover: !1,
                open: i,
                label: c.createElement(Lk, { open: i, ast: o }),
                onSelect: h(() => {
                  let l
                  ;(l = e.onSelect) === null || l === void 0 || l.call(e, t)
                }, 'onSelect'),
                onUpdate: h(l => {
                  s(l)
                }, 'onUpdate'),
              },
              o.children.map(l =>
                c.createElement(yc, {
                  key: l.key,
                  ast: l,
                  depth: n + 1,
                  expandLevel: r,
                  onSelect: e.onSelect,
                })
              )
            )
          : c.createElement(ui, {
              hover: !1,
              label: c.createElement(D1, { ast: t }),
              onSelect: h(() => {
                let l
                ;(l = e.onSelect) === null || l === void 0 || l.call(e, t)
              }, 'onSelect'),
            })
      )
    }, 'ObjectInspectorItem')
    yc.defaultProps = { expandLevel: 0, depth: 0 }
    const jk = yc
    const Mk = [
      'data',
      'expandLevel',
      'sortKeys',
      'includePrototypes',
      'className',
      'theme',
      'colorScheme',
      'onSelect',
    ]
    const k1 = h(e => {
      const {
        data: t,
        expandLevel: r,
        sortKeys: n,
        includePrototypes: o,
        className: a,
        theme: i,
        colorScheme: s,
        onSelect: l,
      } = e
      const u = (0, bk.default)(e, Mk)
      const [d, m] = z(void 0)
      const {
        themeClass: p,
        currentTheme: f,
        currentColorScheme: g,
      } = bi({ theme: i, colorScheme: s }, fe)
      return (
        X(() => {
          h(async () => {
            m(await vk(t, n, o))
          }, 'runParser')()
        }, [t, n, o]),
        c.createElement(
          'div',
          (0, yk.default)({ className: kt(fe.objectInspector, a, p) }, u),
          d &&
            c.createElement(
              wk,
              { theme: f, colorScheme: g },
              c.createElement(jk, { ast: d, expandLevel: r, onSelect: l })
            )
        )
      )
    }, 'ObjectInspector')
    k1.defaultProps = { expandLevel: 0, sortKeys: !0, includePrototypes: !0 }
    const $k = {
      base: '#444',
      nullish: '#7D99AA',
      string: '#16B242',
      number: '#5D40D0',
      boolean: '#f41840',
      objectkey: '#698394',
      instance: '#A15C20',
      function: '#EA7509',
      muted: '#7D99AA',
      tag: { name: '#6F2CAC', suffix: '#1F99E5' },
      date: '#459D9C',
      error: { name: '#D43900', message: '#444' },
      regex: { source: '#A15C20', flags: '#EA7509' },
      meta: '#EA7509',
      method: '#0271B6',
    }
    const qk = {
      base: '#eee',
      nullish: '#aaa',
      string: '#5FE584',
      number: '#6ba5ff',
      boolean: '#ff4191',
      objectkey: '#accfe6',
      instance: '#E3B551',
      function: '#E3B551',
      muted: '#aaa',
      tag: { name: '#f57bff', suffix: '#8EB5FF' },
      date: '#70D4D3',
      error: { name: '#f40', message: '#eee' },
      regex: { source: '#FAD483', flags: '#E3B551' },
      meta: '#FAD483',
      method: '#5EC1FF',
    }
    const je = h(() => {
      const { base: e } = Qe()
      return e === 'dark' ? qk : $k
    }, 'useThemeColors')
    const Uk = /[^A-Z0-9]/i
    const I0 = /[\s.,â€¦]+$/gm
    const O1 = h((e, t) => {
      if (e.length <= t) return e
      for (let r = t - 1; r >= 0; r -= 1)
        if (Uk.test(e[r]) && r > 10)
          return `${e.slice(0, r).replace(I0, '')}\u2026`
      return `${e.slice(0, t).replace(I0, '')}\u2026`
    }, 'ellipsize')
    const Hk = h(e => {
      try {
        return JSON.stringify(e, null, 1)
      } catch {
        return String(e)
      }
    }, 'stringify')
    const I1 = h(
      (e, t) =>
        e.flatMap((r, n) =>
          n === e.length - 1 ? [r] : [r, c.cloneElement(t, { key: `sep${n}` })]
        ),
      'interleave'
    )
    const _r = h(
      ({ value: e, nested: t, showObjectInspector: r, callsById: n, ...o }) => {
        switch (!0) {
          case e === null:
            return c.createElement(Vk, { ...o })
          case e === void 0:
            return c.createElement(zk, { ...o })
          case Array.isArray(e):
            return c.createElement(Kk, { ...o, value: e, callsById: n })
          case typeof e === 'string':
            return c.createElement(Gk, { ...o, value: e })
          case typeof e === 'number':
            return c.createElement(Wk, { ...o, value: e })
          case typeof e === 'boolean':
            return c.createElement(Yk, { ...o, value: e })
          case Object.prototype.hasOwnProperty.call(e, '__date__'):
            return c.createElement(eO, { ...o, ...e.__date__ })
          case Object.prototype.hasOwnProperty.call(e, '__error__'):
            return c.createElement(tO, { ...o, ...e.__error__ })
          case Object.prototype.hasOwnProperty.call(e, '__regexp__'):
            return c.createElement(rO, { ...o, ...e.__regexp__ })
          case Object.prototype.hasOwnProperty.call(e, '__function__'):
            return c.createElement(Zk, { ...o, ...e.__function__ })
          case Object.prototype.hasOwnProperty.call(e, '__symbol__'):
            return c.createElement(nO, { ...o, ...e.__symbol__ })
          case Object.prototype.hasOwnProperty.call(e, '__element__'):
            return c.createElement(Qk, { ...o, ...e.__element__ })
          case Object.prototype.hasOwnProperty.call(e, '__class__'):
            return c.createElement(Jk, { ...o, ...e.__class__ })
          case Object.prototype.hasOwnProperty.call(e, '__callId__'):
            return c.createElement(bc, {
              call: n?.get(e.__callId__),
              callsById: n,
            })
          case Object.prototype.toString.call(e) === '[object Object]':
            return c.createElement(Xk, {
              value: e,
              showInspector: r,
              callsById: n,
              ...o,
            })
          default:
            return c.createElement(oO, { value: e, ...o })
        }
      },
      'Node'
    )
    var Vk = h(e => {
      const t = je()
      return c.createElement(
        'span',
        { style: { color: t.nullish }, ...e },
        'null'
      )
    }, 'NullNode')
    var zk = h(e => {
      const t = je()
      return c.createElement(
        'span',
        { style: { color: t.nullish }, ...e },
        'undefined'
      )
    }, 'UndefinedNode')
    var Gk = h(({ value: e, ...t }) => {
      const r = je()
      return c.createElement(
        'span',
        { style: { color: r.string }, ...t },
        JSON.stringify(O1(e, 50))
      )
    }, 'StringNode')
    var Wk = h(({ value: e, ...t }) => {
      const r = je()
      return c.createElement('span', { style: { color: r.number }, ...t }, e)
    }, 'NumberNode')
    var Yk = h(({ value: e, ...t }) => {
      const r = je()
      return c.createElement(
        'span',
        { style: { color: r.boolean }, ...t },
        String(e)
      )
    }, 'BooleanNode')
    var Kk = h(({ value: e, nested: t = !1, callsById: r }) => {
      const n = je()
      if (t)
        return c.createElement('span', { style: { color: n.base } }, '[\u2026]')
      const o = e.slice(0, 3).map((i, s) =>
        c.createElement(_r, {
          key: `${s}--${JSON.stringify(i)}`,
          value: i,
          nested: !0,
          callsById: r,
        })
      )
      const a = I1(o, c.createElement('span', null, ', '))
      return e.length <= 3
        ? c.createElement('span', { style: { color: n.base } }, '[', a, ']')
        : c.createElement(
            'span',
            { style: { color: n.base } },
            '(',
            e.length,
            ') [',
            a,
            ', \u2026]'
          )
    }, 'ArrayNode')
    var Xk = h(
      ({ showInspector: e, value: t, callsById: r, nested: n = !1 }) => {
        const o = Qe().base === 'dark'
        const a = je()
        if (e)
          return c.createElement(
            c.Fragment,
            null,
            c.createElement(k1, {
              id: 'interactions-object-inspector',
              data: t,
              includePrototypes: !1,
              colorScheme: o ? 'dark' : 'light',
            })
          )
        if (n)
          return c.createElement(
            'span',
            { style: { color: a.base } },
            '{\u2026}'
          )
        const i = I1(
          Object.entries(t)
            .slice(0, 2)
            .map(([s, l]) =>
              c.createElement(
                ft,
                { key: s },
                c.createElement(
                  'span',
                  { style: { color: a.objectkey } },
                  s,
                  ': '
                ),
                c.createElement(_r, { value: l, callsById: r, nested: !0 })
              )
            ),
          c.createElement('span', null, ', ')
        )
        return Object.keys(t).length <= 2
          ? c.createElement('span', { style: { color: a.base } }, '{ ', i, ' }')
          : c.createElement(
              'span',
              { style: { color: a.base } },
              '(',
              Object.keys(t).length,
              ') ',
              '{ ',
              i,
              ', \u2026 }'
            )
      },
      'ObjectNode'
    )
    var Jk = h(({ name: e }) => {
      const t = je()
      return c.createElement('span', { style: { color: t.instance } }, e)
    }, 'ClassNode')
    var Zk = h(({ name: e }) => {
      const t = je()
      return e
        ? c.createElement('span', { style: { color: t.function } }, e)
        : c.createElement(
            'span',
            { style: { color: t.nullish, fontStyle: 'italic' } },
            'anonymous'
          )
    }, 'FunctionNode')
    var Qk = h(
      ({
        prefix: e,
        localName: t,
        id: r,
        classNames: n = [],
        innerText: o,
      }) => {
        const a = e ? `${e}:${t}` : t
        const i = je()
        return c.createElement(
          'span',
          { style: { wordBreak: 'keep-all' } },
          c.createElement(
            'span',
            { key: `${a}_lt`, style: { color: i.muted } },
            '<'
          ),
          c.createElement(
            'span',
            { key: `${a}_tag`, style: { color: i.tag.name } },
            a
          ),
          c.createElement(
            'span',
            { key: `${a}_suffix`, style: { color: i.tag.suffix } },
            r ? `#${r}` : n.reduce((s, l) => `${s}.${l}`, '')
          ),
          c.createElement(
            'span',
            { key: `${a}_gt`, style: { color: i.muted } },
            '>'
          ),
          !r &&
            n.length === 0 &&
            o &&
            c.createElement(
              c.Fragment,
              null,
              c.createElement('span', { key: `${a}_text` }, o),
              c.createElement(
                'span',
                { key: `${a}_close_lt`, style: { color: i.muted } },
                '<'
              ),
              c.createElement(
                'span',
                { key: `${a}_close_tag`, style: { color: i.tag.name } },
                '/',
                a
              ),
              c.createElement(
                'span',
                { key: `${a}_close_gt`, style: { color: i.muted } },
                '>'
              )
            )
        )
      },
      'ElementNode'
    )
    var eO = h(({ value: e }) => {
      let t = new Date(e)
      isNaN(Number(t)) && (Z.warn('Invalid date value:', e), (t = null))
      const r = je()
      if (!t)
        return c.createElement(
          'span',
          { style: { whiteSpace: 'nowrap', color: r.date } },
          'Invalid date'
        )
      const [n, o, a] = t.toISOString().split(/[T.Z]/)
      return c.createElement(
        'span',
        { style: { whiteSpace: 'nowrap', color: r.date } },
        n,
        c.createElement('span', { style: { opacity: 0.7 } }, 'T'),
        o === '00:00:00'
          ? c.createElement('span', { style: { opacity: 0.7 } }, o)
          : o,
        a === '000'
          ? c.createElement('span', { style: { opacity: 0.7 } }, '.', a)
          : `.${a}`,
        c.createElement('span', { style: { opacity: 0.7 } }, 'Z')
      )
    }, 'DateNode')
    var tO = h(({ name: e, message: t }) => {
      const r = je()
      return c.createElement(
        'span',
        { style: { color: r.error.name } },
        e,
        t && ': ',
        t &&
          c.createElement(
            'span',
            {
              style: { color: r.error.message },
              title: t.length > 50 ? t : '',
            },
            O1(t, 50)
          )
      )
    }, 'ErrorNode')
    var rO = h(({ flags: e, source: t }) => {
      const r = je()
      return c.createElement(
        'span',
        { style: { whiteSpace: 'nowrap', color: r.regex.flags } },
        '/',
        c.createElement('span', { style: { color: r.regex.source } }, t),
        '/',
        e
      )
    }, 'RegExpNode')
    var nO = h(({ description: e }) => {
      const t = je()
      return c.createElement(
        'span',
        { style: { whiteSpace: 'nowrap', color: t.instance } },
        'Symbol(',
        e && c.createElement('span', { style: { color: t.meta } }, '"', e, '"'),
        ')'
      )
    }, 'SymbolNode')
    var oO = h(({ value: e }) => {
      const t = je()
      return c.createElement('span', { style: { color: t.meta } }, Hk(e))
    }, 'OtherNode')
    const aO = h(({ label: e }) => {
      const t = je()
      const { typography: r } = Qe()
      return c.createElement(
        'span',
        {
          style: {
            color: t.base,
            fontFamily: r.fonts.base,
            fontSize: r.size.s2 - 1,
          },
        },
        e
      )
    }, 'StepNode')
    var bc = h(({ call: e, callsById: t }) => {
      if (!e) return null
      if (e.method === 'step' && e.path?.length === 0)
        return c.createElement(aO, { label: e.args[0] })
      const r = e.path?.flatMap((a, i) => {
        const s = a.__callId__
        return [
          s
            ? c.createElement(bc, {
                key: `elem${i}`,
                call: t?.get(s),
                callsById: t,
              })
            : c.createElement('span', { key: `elem${i}` }, a),
          c.createElement('wbr', { key: `wbr${i}` }),
          c.createElement('span', { key: `dot${i}` }, '.'),
        ]
      })
      const n = e.args?.flatMap((a, i, s) => {
        const l = c.createElement(_r, {
          key: `node${i}`,
          value: a,
          callsById: t,
        })
        return i < s.length - 1
          ? [
              l,
              c.createElement('span', { key: `comma${i}` }, ',\xA0'),
              c.createElement('wbr', { key: `wbr${i}` }),
            ]
          : [l]
      })
      const o = je()
      return c.createElement(
        c.Fragment,
        null,
        c.createElement('span', { style: { color: o.base } }, r),
        c.createElement('span', { style: { color: o.method } }, e.method),
        c.createElement(
          'span',
          { style: { color: o.base } },
          '(',
          c.createElement('wbr', null),
          n,
          c.createElement('wbr', null),
          ')'
        )
      )
    }, 'MethodCall')
    const R0 = h((e, t = 0) => {
      for (let r = t, n = 1; r < e.length; r += 1)
        if ((e[r] === '(' ? (n += 1) : e[r] === ')' && (n -= 1), n === 0))
          return e.slice(t, r)
      return ''
    }, 'getParams')
    const cu = h(e => {
      try {
        return e === 'undefined' ? void 0 : JSON.parse(e)
      } catch {
        return e
      }
    }, 'parseValue')
    const iO = R.span(({ theme: e }) => ({
      color: e.base === 'light' ? e.color.positiveText : e.color.positive,
    }))
    const sO = R.span(({ theme: e }) => ({
      color: e.base === 'light' ? e.color.negativeText : e.color.negative,
    }))
    const du = h(
      ({ value: e, parsed: t }) =>
        t
          ? c.createElement(_r, {
              showObjectInspector: !0,
              value: e,
              style: { color: '#D43900' },
            })
          : c.createElement(sO, null, e),
      'Received'
    )
    const pu = h(
      ({ value: e, parsed: t }) =>
        t
          ? typeof e === 'string' && e.startsWith('called with')
            ? c.createElement(c.Fragment, null, e)
            : c.createElement(_r, {
                showObjectInspector: !0,
                value: e,
                style: { color: '#16B242' },
              })
          : c.createElement(iO, null, e),
      'Expected'
    )
    const B0 = h(({ message: e, style: t = {} }) => {
      const r = yi()
      const n = e.split(`
`)
      return c.createElement(
        'pre',
        {
          style: {
            margin: 0,
            padding: '8px 10px 8px 36px',
            fontSize: At.size.s1,
            ...t,
          },
        },
        n.flatMap((o, a) => {
          if (o.startsWith('expect(')) {
            const m = R0(o, 7)
            const p = m ? 7 + m.length : 0
            const f = m && o.slice(p).match(/\.(to|last|nth)[A-Z]\w+\(/)
            if (f) {
              const g = p + (f.index ?? 0) + f[0].length
              const y = R0(o, g)
              if (y)
                return [
                  'expect(',
                  c.createElement(du, { key: `received_${m}`, value: m }),
                  o.slice(p, g),
                  c.createElement(pu, { key: `expected_${y}`, value: y }),
                  o.slice(g + y.length),
                  c.createElement('br', { key: `br${a}` }),
                ]
            }
          }
          if (o.match(/^\s*- /))
            return [
              c.createElement(pu, { key: o + a, value: o }),
              c.createElement('br', { key: `br${a}` }),
            ]
          if (o.match(/^\s*\+ /) || o.match(/^Received: $/))
            return [
              c.createElement(du, { key: o + a, value: o }),
              c.createElement('br', { key: `br${a}` }),
            ]
          const [, i, s] = o.match(/^(Expected|Received): (.*)$/) || []
          if (i && s)
            return i === 'Expected'
              ? [
                  'Expected: ',
                  c.createElement(pu, { key: o + a, value: cu(s), parsed: !0 }),
                  c.createElement('br', { key: `br${a}` }),
                ]
              : [
                  'Received: ',
                  c.createElement(du, { key: o + a, value: cu(s), parsed: !0 }),
                  c.createElement('br', { key: `br${a}` }),
                ]
          const [, l, u] =
            o.match(
              /(Expected number|Received number|Number) of calls: (\d+)$/i
            ) || []
          if (l && u)
            return [
              `${l} of calls: `,
              c.createElement(_r, { key: o + a, value: Number(u) }),
              c.createElement('br', { key: `br${a}` }),
            ]
          const [, d] = o.match(/^Received has value: (.+)$/) || []
          return d
            ? [
                'Received has value: ',
                c.createElement(_r, { key: o + a, value: cu(d) }),
                c.createElement('br', { key: `br${a}` }),
              ]
            : [
                c.createElement('span', {
                  key: o + a,
                  dangerouslySetInnerHTML: { __html: r.toHtml(o) },
                }),
                c.createElement('br', { key: `br${a}` }),
              ]
        })
      )
    }, 'MatcherResult')
    const lO = R.div({
      width: 14,
      height: 14,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
    })
    const R1 = h(({ status: e }) => {
      const t = Qe()
      switch (e) {
        case 'done':
          return c.createElement(yo, {
            color: t.color.positive,
            'data-testid': 'icon-done',
          })
        case 'error':
          return c.createElement(Uc, {
            color: t.color.negative,
            'data-testid': 'icon-error',
          })
        case 'active':
          return c.createElement(jc, {
            color: t.color.secondary,
            'data-testid': 'icon-active',
          })
        case 'waiting':
          return c.createElement(
            lO,
            { 'data-testid': 'icon-waiting' },
            c.createElement(vo, { color: de(0.5, '#CCCCCC'), size: 6 })
          )
        default:
          return null
      }
    }, 'StatusIcon')
    const uO = R.div({
      fontFamily: At.fonts.mono,
      fontSize: At.size.s1,
      overflowWrap: 'break-word',
      inlineSize: 'calc( 100% - 40px )',
    })
    const cO = R('div', {
      shouldForwardProp: h(
        e => !['call', 'pausedAt'].includes(e.toString()),
        'shouldForwardProp'
      ),
    })(
      ({ theme: e, call: t }) => ({
        position: 'relative',
        display: 'flex',
        flexDirection: 'column',
        borderBottom: `1px solid ${e.appBorderColor}`,
        fontFamily: At.fonts.base,
        fontSize: 13,
        ...(t.status === 'error' && {
          backgroundColor:
            e.base === 'dark'
              ? de(0.93, e.color.negative)
              : e.background.warning,
        }),
        paddingLeft: (t.ancestors?.length ?? 0) * 20,
      }),
      ({ theme: e, call: t, pausedAt: r }) =>
        r === t.id && {
          '&::before': {
            content: '""',
            position: 'absolute',
            top: -5,
            zIndex: 1,
            borderTop: '4.5px solid transparent',
            borderLeft: `7px solid ${e.color.warning}`,
            borderBottom: '4.5px solid transparent',
          },
          '&::after': {
            content: '""',
            position: 'absolute',
            top: -1,
            zIndex: 1,
            width: '100%',
            borderTop: `1.5px solid ${e.color.warning}`,
          },
        }
    )
    const dO = R.div(({ theme: e, isInteractive: t }) => ({
      display: 'flex',
      '&:hover': t ? {} : { background: e.background.hoverable },
    }))
    const pO = R('button', {
      shouldForwardProp: h(
        e => !['call'].includes(e.toString()),
        'shouldForwardProp'
      ),
    })(({ theme: e, disabled: t, call: r }) => ({
      flex: 1,
      display: 'grid',
      background: 'none',
      border: 0,
      gridTemplateColumns: '15px 1fr',
      alignItems: 'center',
      minHeight: 40,
      margin: 0,
      padding: '8px 15px',
      textAlign: 'start',
      cursor: t || r.status === 'error' ? 'default' : 'pointer',
      '&:focus-visible': {
        outline: 0,
        boxShadow: `inset 3px 0 0 0 ${r.status === 'error' ? e.color.warning : e.color.secondary}`,
        background:
          r.status === 'error' ? 'transparent' : e.background.hoverable,
      },
      '& > div': { opacity: r.status === 'waiting' ? 0.5 : 1 },
    }))
    const mO = R.div({ display: 'flex', alignItems: 'center', padding: 6 })
    const hO = R(ce)(({ theme: e }) => ({
      color: e.textMutedColor,
      margin: '0 3px',
    }))
    const fO = R(vt)(({ theme: e }) => ({
      fontFamily: e.typography.fonts.base,
    }))
    const mu = R('div')(({ theme: e }) => ({
      padding: '8px 10px 8px 36px',
      fontSize: At.size.s1,
      color: e.color.defaultText,
      pre: { margin: 0, padding: 0 },
    }))
    const gO = R.span(({ theme: e }) => ({
      color: e.base === 'dark' ? '#5EC1FF' : '#0271B6',
    }))
    const yO = R.span(({ theme: e }) => ({
      color: e.base === 'dark' ? '#eee' : '#444',
    }))
    const bO = R.p(({ theme: e }) => ({
      color: e.base === 'dark' ? e.color.negative : e.color.negativeText,
      fontSize: e.typography.size.s2,
      maxWidth: 500,
      textWrap: 'balance',
    }))
    const EO = h(({ exception: e }) => {
      const t = yi()
      if (!e) return null
      if (e.callId === Lt)
        return Y(
          mu,
          null,
          Y('pre', null, Y(gO, null, e.name, ':'), ' ', Y(yO, null, e.message)),
          Y(
            bO,
            null,
            'The component failed to render properly. Automated component tests will not run until this is resolved. Check the full error message in Storybook\u2019s canvas to debug.'
          )
        )
      if (fc(e)) return Y(B0, { ...e })
      if (hc(e))
        return Y(
          mu,
          null,
          Y(B0, {
            message: `${e.message}${
              e.diff
                ? `

${e.diff}`
                : ''
            }`,
            style: { padding: 0 },
          }),
          Y('p', null, 'See the full stack trace in the browser console.')
        )
      const r = e.message.split(`

`)
      const n = r.length > 1
      return Y(
        mu,
        null,
        Y('pre', { dangerouslySetInnerHTML: { __html: t.toHtml(r[0]) } }),
        n && Y('p', null, 'See the full stack trace in the browser console.')
      )
    }, 'Exception')
    const vO = h(
      ({
        call: e,
        callsById: t,
        controls: r,
        controlStates: n,
        childCallIds: o,
        isHidden: a,
        isCollapsed: i,
        toggleCollapsed: s,
        pausedAt: l,
      }) => {
        const [u, d] = z(!1)
        const m = !n.goto || !e.interceptable || !!e.ancestors?.length
        return a || e.id === Lt
          ? null
          : Y(
              cO,
              { call: e, pausedAt: l },
              Y(
                dO,
                { isInteractive: m },
                Y(
                  pO,
                  {
                    'aria-label': 'Interaction step',
                    call: e,
                    onClick: () => r.goto(e.id),
                    disabled: m,
                    onMouseEnter: () => n.goto && d(!0),
                    onMouseLeave: () => n.goto && d(!1),
                  },
                  Y(R1, { status: u ? 'active' : e.status }),
                  Y(
                    uO,
                    { style: { marginLeft: 6, marginBottom: 1 } },
                    Y(bc, { call: e, callsById: t })
                  )
                ),
                Y(
                  mO,
                  null,
                  (o?.length ?? 0) > 0 &&
                    Y(
                      De,
                      {
                        hasChrome: !1,
                        tooltip: Y(fO, {
                          note: `${i ? 'Show' : 'Hide'} interactions`,
                        }),
                      },
                      Y(
                        hO,
                        {
                          onClick: s,
                          'aria-label': i
                            ? 'Expand interaction'
                            : 'Collapse interaction',
                        },
                        i ? Y(bo, null) : Y(Dc, null)
                      )
                    )
                )
              ),
              e.status === 'error' &&
                e.exception?.callId === e.id &&
                Y(EO, { exception: e.exception })
            )
      },
      'Interaction'
    )
    const AO = {
      rendering: 'mediumdark',
      playing: 'warning',
      completed: 'positive',
      errored: 'negative',
      aborted: 'purple',
    }
    const xO = {
      rendering: 'Wait',
      playing: 'Runs',
      completed: 'Pass',
      errored: 'Fail',
      aborted: 'Bail',
    }
    const wO = R.div(({ theme: e, status: t }) => ({
      display: 'inline-block',
      padding: '4px 6px 4px 8px',
      borderRadius: '4px',
      backgroundColor: e.color[AO[t]],
      color: 'white',
      fontFamily: At.fonts.base,
      textTransform: 'uppercase',
      fontSize: At.size.s1,
      letterSpacing: 3,
      fontWeight: At.weight.bold,
      minWidth: 65,
      textAlign: 'center',
    }))
    const SO = h(({ status: e }) => {
      const t = xO[e]
      return c.createElement(
        wO,
        { 'aria-label': 'Status of the test run', status: e },
        t
      )
    }, 'StatusBadge')
    const CO = R.div(({ theme: e }) => ({
      boxShadow: `${e.appBorderColor} 0 -1px 0 0 inset`,
      background: e.background.app,
      position: 'sticky',
      top: 0,
      zIndex: 1,
    }))
    const DO = R.nav({
      height: 40,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingLeft: 15,
    })
    const TO = R(Je)(({ theme: e }) => ({
      borderRadius: 4,
      padding: 6,
      color: e.textMutedColor,
      '&:not(:disabled)': {
        '&:hover,&:focus-visible': { color: e.color.secondary },
      },
    }))
    const Jn = R(vt)(({ theme: e }) => ({
      fontFamily: e.typography.fonts.base,
    }))
    const no = R(ce)(({ theme: e }) => ({
      color: e.textMutedColor,
      margin: '0 3px',
    }))
    const kO = R(Ci)({ marginTop: 0 })
    const OO = R(xi)(({ theme: e }) => ({
      color: e.textMutedColor,
      justifyContent: 'flex-end',
      textAlign: 'right',
      whiteSpace: 'nowrap',
      marginTop: 'auto',
      marginBottom: 1,
      paddingRight: 15,
      fontSize: 13,
    }))
    const _0 = R.div({ display: 'flex', alignItems: 'center' })
    const IO = R(no)({ marginLeft: 9 })
    const RO = R(TO)({
      marginLeft: 9,
      marginRight: 9,
      marginBottom: 1,
      lineHeight: '12px',
    })
    const BO = R(no)(({ theme: e, animating: t, disabled: r }) => ({
      opacity: r ? 0.5 : 1,
      svg: {
        animation: t ? `${e.animation.rotate360} 200ms ease-out` : void 0,
      },
    }))
    const _O = h(
      ({
        controls: e,
        controlStates: t,
        status: r,
        storyFileName: n,
        onScrollToEnd: o,
      }) => {
        const a = r === 'errored' ? 'Scroll to error' : 'Scroll to end'
        const i = Qe()
        return c.createElement(
          CO,
          null,
          c.createElement(
            Tn,
            { backgroundColor: i.background.app },
            c.createElement(
              DO,
              { 'aria-label': 'Component tests toolbar' },
              c.createElement(
                _0,
                null,
                c.createElement(SO, { status: r }),
                c.createElement(RO, { onClick: o, disabled: !o }, a),
                c.createElement(kO, null),
                c.createElement(
                  De,
                  {
                    trigger: 'hover',
                    hasChrome: !1,
                    tooltip: c.createElement(Jn, { note: 'Go to start' }),
                  },
                  c.createElement(
                    IO,
                    {
                      'aria-label': 'Go to start',
                      onClick: e.start,
                      disabled: !t.start,
                    },
                    c.createElement($c, null)
                  )
                ),
                c.createElement(
                  De,
                  {
                    trigger: 'hover',
                    hasChrome: !1,
                    tooltip: c.createElement(Jn, { note: 'Go back' }),
                  },
                  c.createElement(
                    no,
                    {
                      'aria-label': 'Go back',
                      onClick: e.back,
                      disabled: !t.back,
                    },
                    c.createElement(Lc, null)
                  )
                ),
                c.createElement(
                  De,
                  {
                    trigger: 'hover',
                    hasChrome: !1,
                    tooltip: c.createElement(Jn, { note: 'Go forward' }),
                  },
                  c.createElement(
                    no,
                    {
                      'aria-label': 'Go forward',
                      onClick: e.next,
                      disabled: !t.next,
                    },
                    c.createElement(Mc, null)
                  )
                ),
                c.createElement(
                  De,
                  {
                    trigger: 'hover',
                    hasChrome: !1,
                    tooltip: c.createElement(Jn, { note: 'Go to end' }),
                  },
                  c.createElement(
                    no,
                    {
                      'aria-label': 'Go to end',
                      onClick: e.end,
                      disabled: !t.end,
                    },
                    c.createElement(Ic, null)
                  )
                ),
                c.createElement(
                  De,
                  {
                    trigger: 'hover',
                    hasChrome: !1,
                    tooltip: c.createElement(Jn, { note: 'Rerun' }),
                  },
                  c.createElement(
                    BO,
                    { 'aria-label': 'Rerun', onClick: e.rerun },
                    c.createElement(Vc, null)
                  )
                )
              ),
              n && c.createElement(_0, null, c.createElement(OO, null, n))
            )
          )
        )
      },
      'Subnav'
    )
    const FO = R.div(
      ({ theme: { color: e, typography: t, background: r } }) => ({
        textAlign: 'start',
        padding: '11px 15px',
        fontSize: `${t.size.s2 - 1}px`,
        fontWeight: t.weight.regular,
        lineHeight: '1rem',
        background: r.app,
        borderBottom: `1px solid ${e.border}`,
        color: e.defaultText,
        backgroundClip: 'padding-box',
        position: 'relative',
        code: {
          fontSize: `${t.size.s1 - 1}px`,
          color: 'inherit',
          margin: '0 0.2em',
          padding: '0 0.2em',
          background: 'rgba(255, 255, 255, 0.8)',
          borderRadius: '2px',
          boxShadow: '0 0 0 1px rgba(0, 0, 0, 0.1)',
        },
      })
    )
    const PO = h(({ browserTestStatus: e }) => {
      const t = tt().getDocsUrl({ subpath: ok, versioned: !0, renderer: !0 })
      const [r, n] =
        e === 'error'
          ? ['the CLI', 'this browser']
          : ['this browser', 'the CLI']
      return c.createElement(
        FO,
        null,
        'This interaction test passed in ',
        r,
        ', but the tests failed in ',
        n,
        '.',
        ' ',
        c.createElement(
          Ze,
          { href: t, target: '_blank', withArrow: !0 },
          'Learn what could cause this'
        )
      )
    }, 'TestDiscrepancyMessage')
    const NO = R.div(({ theme: e }) => ({
      height: '100%',
      background: e.background.content,
    }))
    const F0 = R.div(({ theme: e }) => ({
      borderBottom: `1px solid ${e.appBorderColor}`,
      backgroundColor:
        e.base === 'dark' ? de(0.93, e.color.negative) : e.background.warning,
      padding: 15,
      fontSize: e.typography.size.s2 - 1,
      lineHeight: '19px',
    }))
    const hu = R.code(({ theme: e }) => ({
      margin: '0 1px',
      padding: 3,
      fontSize: e.typography.size.s1 - 1,
      lineHeight: 1,
      verticalAlign: 'top',
      background: 'rgba(0, 0, 0, 0.05)',
      border: `1px solid ${e.appBorderColor}`,
      borderRadius: 3,
    }))
    const P0 = R.div({ paddingBottom: 4, fontWeight: 'bold' })
    const LO = R.p({ margin: 0, padding: '0 0 20px' })
    const N0 = R.pre(({ theme: e }) => ({
      margin: 0,
      padding: 0,
      '&:not(:last-child)': { paddingBottom: 16 },
      fontSize: e.typography.size.s1 - 1,
    }))
    const jO = Xe(
      h(function ({
        storyUrl: e,
        status: t,
        calls: r,
        controls: n,
        controlStates: o,
        interactions: a,
        fileName: i,
        hasException: s,
        caughtException: l,
        unhandledErrors: u,
        pausedAt: d,
        onScrollToEnd: m,
        endRef: p,
        hasResultMismatch: f,
        browserTestStatus: g,
      }) {
        const y = yi()
        const E = a.some(b => b.id !== Lt)
        return Y(
          NO,
          null,
          f && Y(PO, { browserTestStatus: g }),
          o.detached && (E || s) && Y(hk, { storyUrl: e }),
          Y(_O, {
            controls: n,
            controlStates: o,
            status: t,
            storyFileName: i,
            onScrollToEnd: m,
          }),
          Y(
            'div',
            { 'aria-label': 'Interactions list' },
            a.map(b =>
              Y(vO, {
                key: b.id,
                call: b,
                callsById: r,
                controls: n,
                controlStates: o,
                childCallIds: b.childCallIds,
                isHidden: b.isHidden,
                isCollapsed: b.isCollapsed,
                toggleCollapsed: b.toggleCollapsed,
                pausedAt: d,
              })
            )
          ),
          l &&
            !A1(l) &&
            Y(
              F0,
              null,
              Y(
                P0,
                null,
                'Caught exception in ',
                Y(hu, null, 'play'),
                ' function'
              ),
              Y(N0, {
                'data-chromatic': 'ignore',
                dangerouslySetInnerHTML: { __html: y.toHtml(Lu(l)) },
              })
            ),
          u &&
            Y(
              F0,
              null,
              Y(P0, null, 'Unhandled Errors'),
              Y(
                LO,
                null,
                'Found ',
                u.length,
                ' unhandled error',
                u.length > 1 ? 's' : '',
                ' ',
                'while running the play function. This might cause false positive assertions. Resolve unhandled errors or ignore unhandled errors with setting the',
                Y(hu, null, 'test.dangerouslyIgnoreUnhandledErrors'),
                ' ',
                'parameter to ',
                Y(hu, null, 'true'),
                '.'
              ),
              u.map((b, x) =>
                Y(N0, { key: x, 'data-chromatic': 'ignore' }, Lu(b))
              )
            ),
          Y('div', { ref: p }),
          t === 'completed' && !l && !E && Y(gk, null)
        )
      }, 'InteractionsPanel')
    )
    function Lu(e) {
      return e.stack || `${e.name}: ${e.message}`
    }
    h(Lu, 'printSerializedError')
    const Qn = {
      detached: !1,
      start: !1,
      back: !1,
      goto: !1,
      next: !1,
      end: !1,
    }
    const L0 = {
      rendering: 'rendering',
      playing: 'playing',
      completed: 'completed',
      errored: 'errored',
      aborted: 'aborted',
    }
    const MO = {
      done: 'status-value:success',
      error: 'status-value:error',
      active: 'status-value:pending',
      waiting: 'status-value:pending',
    }
    const $O = h(({ log: e, calls: t, collapsed: r, setCollapsed: n }) => {
      const o = new Map()
      const a = new Map()
      return e
        .map(({ callId: i, ancestors: s, status: l }) => {
          let u = !1
          return (
            s.forEach(d => {
              ;(r.has(d) && (u = !0), a.set(d, (a.get(d) || []).concat(i)))
            }),
            { ...t.get(i), status: l, isHidden: u }
          )
        })
        .map(i => {
          const s =
            i.status === 'error' &&
            i.ancestors &&
            o.get(i.ancestors.slice(-1)[0])?.status === 'active'
              ? 'active'
              : i.status
          return (
            o.set(i.id, { ...i, status: s }),
            {
              ...i,
              status: s,
              childCallIds: a.get(i.id),
              isCollapsed: r.has(i.id),
              toggleCollapsed: h(
                () =>
                  n(
                    l => (
                      l.has(i.id) ? l.delete(i.id) : l.add(i.id),
                      new Set(l)
                    )
                  ),
                'toggleCollapsed'
              ),
            }
          )
        })
    }, 'getInteractions')
    const za = h(
      (e, { log: t, calls: r, collapsed: n, setCollapsed: o }) =>
        $O({ log: t, calls: r, collapsed: n, setCollapsed: o }).reduce(
          (a, i) => (
            i.id === Lt
              ? a.interactions.push(i)
              : e.status !== 'rendering' &&
                ((a.controlStates = e.controlStates),
                a.interactions.push(i),
                i.method !== 'step' && a.interactionsCount++),
            a
          ),
          { ...e, controlStates: Qn, interactions: [], interactionsCount: 0 }
        ),
      'getPanelState'
    )
    const fu = h(
      (e, t) => ({
        id: Lt,
        method: 'render',
        args: [],
        cursor: 0,
        storyId: e,
        ancestors: [],
        path: [],
        interceptable: !0,
        retain: !1,
        exception: t,
      }),
      'getInternalRenderCall'
    )
    const Ga = h(
      e => ({ callId: Lt, status: e, ancestors: [] }),
      'getInternalRenderLogItem'
    )
    const qO = Xe(
      h(function ({ refId: e, storyId: t, storyUrl: r }) {
        const { statusValue: n, testRunId: o } = rd(A => {
          const D = e ? void 0 : A[t]?.[ck]
          return { statusValue: D?.value, testRunId: D?.data?.testRunId }
        })
        const [a, i] = jr(gi, {
          status: 'rendering',
          controlStates: Qn,
          interactions: [],
          interactionsCount: 0,
          hasException: !1,
          pausedAt: void 0,
          caughtException: void 0,
          unhandledErrors: void 0,
        })
        const [s, l] = z(void 0)
        const [u, d] = z(new Set())
        const [m, p] = z(!1)
        const {
          status: f = 'rendering',
          controlStates: g = Qn,
          interactions: y = [],
          pausedAt: E = void 0,
          caughtException: b = void 0,
          unhandledErrors: x = void 0,
        } = a
        const S = ye([Ga('active')])
        const T = ye(new Map([[Lt, fu(t)]]))
        const _ = h(({ status: A, ...D }) => T.current.set(D.id, D), 'setCall')
        const O = ye()
        X(() => {
          let A
          return (
            H.IntersectionObserver &&
              ((A = new H.IntersectionObserver(
                ([D]) => l(D.isIntersecting ? void 0 : D.target),
                { root: H.document.querySelector('#panel-tab-content') }
              )),
              O.current && A.observe(O.current)),
            () => A?.disconnect()
          )
        }, [])
        const k = ye(0)
        const B = Co(
          {
            [kr.CALL]: _,
            [kr.SYNC]: A => {
              ;((S.current = [Ga('done'), ...A.logItems]),
                i(D =>
                  za(
                    {
                      ...D,
                      controlStates: A.controlStates,
                      pausedAt: A.pausedAt,
                    },
                    {
                      log: S.current,
                      calls: T.current,
                      collapsed: u,
                      setCollapsed: d,
                    }
                  )
                ))
            },
            [gt]: A => {
              A.newPhase === 'preparing' ||
                A.newPhase === 'loading' ||
                ((k.current = Math.max(k.current, A.renderId || 0)),
                k.current === A.renderId &&
                  (A.newPhase === 'rendering'
                    ? ((S.current = [Ga('active')]),
                      T.current.set(Lt, fu(t)),
                      i({
                        status: 'rendering',
                        controlStates: Qn,
                        pausedAt: void 0,
                        interactions: [],
                        interactionsCount: 0,
                        hasException: !1,
                        caughtException: void 0,
                        unhandledErrors: void 0,
                      }))
                    : i(D => {
                        const N = A.newPhase in L0 ? L0[A.newPhase] : D.status
                        return za(
                          { ...D, status: N, pausedAt: void 0 },
                          {
                            log: S.current,
                            calls: T.current,
                            collapsed: u,
                            setCollapsed: d,
                          }
                        )
                      })))
            },
            [Bo]: A => {
              ;((S.current = [Ga('error')]),
                T.current.set(Lt, fu(t, { ...A, callId: Lt })),
                i(D =>
                  za(
                    {
                      ...D,
                      hasException: !0,
                      caughtException: void 0,
                      controlStates: Qn,
                      pausedAt: void 0,
                    },
                    {
                      log: S.current,
                      calls: T.current,
                      collapsed: u,
                      setCollapsed: d,
                    }
                  )
                ))
            },
            [ko]: A => {
              i(D => ({ ...D, caughtException: A, hasException: !0 }))
            },
            [_o]: A => {
              i(D => ({ ...D, unhandledErrors: A, hasException: !0 }))
            },
          },
          [u]
        )
        X(() => {
          i(A =>
            za(A, {
              log: S.current,
              calls: T.current,
              collapsed: u,
              setCollapsed: d,
            })
          )
        }, [i, u])
        const P = Me(
          () => ({
            start: h(() => B(kr.START, { storyId: t }), 'start'),
            back: h(() => B(kr.BACK, { storyId: t }), 'back'),
            goto: h(A => B(kr.GOTO, { storyId: t, callId: A }), 'goto'),
            next: h(() => B(kr.NEXT, { storyId: t }), 'next'),
            end: h(() => B(kr.END, { storyId: t }), 'end'),
            rerun: h(() => {
              B(br, { storyId: t })
            }, 'rerun'),
          }),
          [B, t]
        )
        const L = tr('fileName', '')
        const [j] = L.toString().split('/').slice(-1)
        const U = h(
          () => s?.scrollIntoView({ behavior: 'smooth', block: 'end' }),
          'scrollToTarget'
        )
        const $ = !!b || !!x || y.some(A => A.status === 'error')
        const v = Me(
          () =>
            f !== 'playing' && (y.length > 0 || $)
              ? $
                ? 'error'
                : 'done'
              : f === 'playing'
                ? 'active'
                : void 0,
          [f, y, $]
        )
        return (
          X(() => {
            if (v && n && n !== 'status-value:pending' && n !== MO[v]) {
              const A = setTimeout(
                () =>
                  p(
                    D => (
                      D ||
                        B(sk, {
                          type: 'test-discrepancy',
                          payload: {
                            browserStatus: v === 'done' ? 'PASS' : 'FAIL',
                            cliStatus: v === 'done' ? 'FAIL' : 'PASS',
                            storyId: t,
                            testRunId: o,
                          },
                        }),
                      !0
                    )
                  ),
                2e3
              )
              return () => clearTimeout(A)
            } else p(!1)
          }, [B, v, n, t, o]),
          c.createElement(
            ft,
            { key: 'component-tests' },
            c.createElement(jO, {
              storyUrl: r,
              status: f,
              hasResultMismatch: m,
              browserTestStatus: v,
              calls: T.current,
              controls: P,
              controlStates: { ...g, detached: !!e || g.detached },
              interactions: y,
              fileName: j,
              hasException: $,
              caughtException: b,
              unhandledErrors: x,
              pausedAt: E,
              endRef: O,
              onScrollToEnd: s && U,
            })
          )
        )
      }, 'PanelMemoized')
    )
    function B1() {
      const e = tt().getSelectedPanel()
      const [t = {}] = jr(gi)
      const { status: r, hasException: n, interactionsCount: o } = t
      return c.createElement(
        'div',
        { style: { display: 'flex', alignItems: 'center', gap: 6 } },
        c.createElement('span', null, 'Interactions'),
        o && r !== 'errored' && !n
          ? c.createElement(
              gr,
              { compact: !0, status: e === mc ? 'active' : 'neutral' },
              o
            )
          : null,
        r === 'errored' || n ? c.createElement(R1, { status: 'error' }) : null
      )
    }
    h(B1, 'PanelTitle')
    const Bq = ve.register(gi, () => {
      if (globalThis?.FEATURES?.interactions) {
        const e = h(({ state: t }) => {
          const r =
            (t.refId && t.refs[t.refId]?.url) || document.location.origin
          const { pathname: n, search: o = '' } = t.location
          const a = n + (t.refId ? o.replace(`/${t.refId}_`, '/') : o)
          return { refId: t.refId, storyId: t.storyId, storyUrl: r + a }
        }, 'filter')
        ve.add(mc, {
          type: et.PANEL,
          title: h(() => c.createElement(B1, null), 'title'),
          match: h(({ viewMode: t }) => t === 'story', 'match'),
          render: h(
            ({ active: t }) =>
              c.createElement(
                Dn,
                { active: !!t },
                c.createElement(td, { filter: e }, r =>
                  c.createElement(qO, { ...r })
                )
              ),
            'render'
          ),
        })
      }
    })
    const ju = 'storybook/background'
    const ei = 'backgrounds'
    const Mq = { UPDATE: `${ju}/update` }
    const UO = {
      light: { name: 'light', value: '#F8F8F8' },
      dark: { name: 'dark', value: '#333' },
    }
    const HO = Xe(
      h(function () {
        const e = tr(ei)
        const [t, r, n] = Rt()
        const [o, a] = z(!1)
        const { options: i = UO, disable: s = !0 } = e || {}
        if (s) return null
        const l = t[ei] || {}
        const u = l.value
        const d = l.grid || !1
        const m = i[u]
        const p = !!n?.[ei]
        const f = Object.keys(i).length
        return c.createElement(VO, {
          length: f,
          backgroundMap: i,
          item: m,
          updateGlobals: r,
          backgroundName: u,
          setIsTooltipVisible: a,
          isLocked: p,
          isGridActive: d,
          isTooltipVisible: o,
        })
      }, 'BackgroundSelector')
    )
    var VO = Xe(
      h(function (e) {
        const {
          item: t,
          length: r,
          updateGlobals: n,
          setIsTooltipVisible: o,
          backgroundMap: a,
          backgroundName: i,
          isLocked: s,
          isGridActive: l,
          isTooltipVisible: u,
        } = e
        const d = Q(
          m => {
            n({ [ei]: m })
          },
          [n]
        )
        return c.createElement(
          ft,
          null,
          c.createElement(
            ce,
            {
              key: 'grid',
              active: l,
              disabled: s,
              title: 'Apply a grid to the preview',
              onClick: () => d({ value: i, grid: !l }),
            },
            c.createElement(Rc, null)
          ),
          r > 0
            ? c.createElement(
                De,
                {
                  key: 'background',
                  placement: 'top',
                  closeOnOutsideClick: !0,
                  tooltip: ({ onHide: m }) =>
                    c.createElement(In, {
                      links: [
                        ...(t
                          ? [
                              {
                                id: 'reset',
                                title: 'Reset background',
                                icon: c.createElement(Ao, null),
                                onClick: h(() => {
                                  ;(d(void 0), m())
                                }, 'onClick'),
                              },
                            ]
                          : []),
                        ...Object.entries(a).map(([p, f]) => ({
                          id: p,
                          title: f.name,
                          icon: c.createElement(vo, {
                            color: f?.value || 'grey',
                          }),
                          active: p === i,
                          onClick: h(() => {
                            ;(d({ value: p, grid: l }), m())
                          }, 'onClick'),
                        })),
                      ].flat(),
                    }),
                  onVisibleChange: o,
                },
                c.createElement(
                  ce,
                  {
                    disabled: s,
                    key: 'background',
                    title: 'Change the background of the preview',
                    active: !!t || u,
                  },
                  c.createElement(Nc, null)
                )
              )
            : null
        )
      }, 'PureTool')
    )
    const $q = ve.register(ju, () => {
      globalThis?.FEATURES?.backgrounds &&
        ve.add(ju, {
          title: 'Backgrounds',
          type: et.TOOL,
          match: h(
            ({ viewMode: e, tabId: t }) =>
              !!(e && e.match(/^(story|docs)$/)) && !t,
            'match'
          ),
          render: h(() => c.createElement(HO, null), 'render'),
        })
    })
    const En = 'storybook/measure-addon'
    const _1 = `${En}/tool`
    const Wq = {
      RESULT: `${En}/result`,
      REQUEST: `${En}/request`,
      CLEAR: `${En}/clear`,
    }
    const zO = h(() => {
      const [e, t] = Rt()
      const { measureEnabled: r } = e || {}
      const n = tt()
      const o = Q(() => t({ measureEnabled: !r }), [t, r])
      return (
        X(() => {
          n.setAddonShortcut(En, {
            label: 'Toggle Measure [M]',
            defaultShortcut: ['M'],
            actionName: 'measure',
            showInMenu: !1,
            action: o,
          })
        }, [o, n]),
        c.createElement(
          ce,
          { key: _1, active: r, title: 'Enable measure', onClick: o },
          c.createElement(qc, null)
        )
      )
    }, 'Tool')
    const Yq = ve.register(En, () => {
      globalThis?.FEATURES?.measure &&
        ve.add(_1, {
          type: et.TOOL,
          title: 'Measure',
          match: h(({ viewMode: e, tabId: t }) => e === 'story' && !t, 'match'),
          render: h(() => c.createElement(zO, null), 'render'),
        })
    })
    const Mu = 'storybook/outline'
    const j0 = 'outline'
    const GO = Xe(
      h(function () {
        const [e, t] = Rt()
        const r = tt()
        const n = [!0, 'true'].includes(e[j0])
        const o = Q(() => t({ [j0]: !n }), [n])
        return (
          X(() => {
            r.setAddonShortcut(Mu, {
              label: 'Toggle Outline',
              defaultShortcut: ['alt', 'O'],
              actionName: 'outline',
              showInMenu: !1,
              action: o,
            })
          }, [o, r]),
          c.createElement(
            ce,
            {
              key: 'outline',
              active: n,
              title: 'Apply outlines to the preview',
              onClick: o,
            },
            c.createElement(Pc, null)
          )
        )
      }, 'OutlineSelector')
    )
    const tU = ve.register(Mu, () => {
      globalThis?.FEATURES?.outline &&
        ve.add(Mu, {
          title: 'Outline',
          type: et.TOOL,
          match: h(
            ({ viewMode: e, tabId: t }) =>
              !!(e && e.match(/^(story|docs)$/)) && !t,
            'match'
          ),
          render: h(() => c.createElement(GO, null), 'render'),
        })
    })
    const vn = 'storybook/viewport'
    const ti = 'viewport'
    const lU = `${vn}/panel`
    const WO = `${vn}/tool`
    const YO = {
      mobile1: {
        name: 'Small mobile',
        styles: { height: '568px', width: '320px' },
        type: 'mobile',
      },
      mobile2: {
        name: 'Large mobile',
        styles: { height: '896px', width: '414px' },
        type: 'mobile',
      },
      tablet: {
        name: 'Tablet',
        styles: { height: '1112px', width: '834px' },
        type: 'tablet',
      },
      desktop: {
        name: 'Desktop',
        styles: { height: '1024px', width: '1280px' },
        type: 'desktop',
      },
    }
    const oo = {
      name: 'Reset viewport',
      styles: { height: '100%', width: '100%' },
      type: 'desktop',
    }
    const F1 = h((e, t) => e.indexOf(t), 'getCurrentViewportIndex')
    const KO = h((e, t) => {
      const r = F1(e, t)
      return r === e.length - 1 ? e[0] : e[r + 1]
    }, 'getNextViewport')
    const XO = h((e, t) => {
      const r = F1(e, t)
      return r < 1 ? e[e.length - 1] : e[r - 1]
    }, 'getPreviousViewport')
    const JO = h(async (e, t, r, n) => {
      ;(await e.setAddonShortcut(vn, {
        label: 'Previous viewport',
        defaultShortcut: ['alt', 'shift', 'V'],
        actionName: 'previous',
        action: h(() => {
          r({ viewport: XO(n, t) })
        }, 'action'),
      }),
        await e.setAddonShortcut(vn, {
          label: 'Next viewport',
          defaultShortcut: ['alt', 'V'],
          actionName: 'next',
          action: h(() => {
            r({ viewport: KO(n, t) })
          }, 'action'),
        }),
        await e.setAddonShortcut(vn, {
          label: 'Reset viewport',
          defaultShortcut: ['alt', 'control', 'V'],
          actionName: 'reset',
          action: h(() => {
            r({ viewport: { value: void 0, isRotated: !1 } })
          }, 'action'),
        }))
    }, 'registerShortcuts')
    const ZO = R.div({ display: 'inline-flex', alignItems: 'center' })
    const M0 = R.div(({ theme: e }) => ({
      display: 'inline-block',
      textDecoration: 'none',
      padding: 10,
      fontWeight: e.typography.weight.bold,
      fontSize: e.typography.size.s2 - 1,
      lineHeight: '1',
      height: 40,
      border: 'none',
      borderTop: '3px solid transparent',
      borderBottom: '3px solid transparent',
      background: 'transparent',
    }))
    const QO = R(ce)(() => ({ display: 'inline-flex', alignItems: 'center' }))
    const eI = R.div(({ theme: e }) => ({
      fontSize: e.typography.size.s2 - 1,
      marginLeft: 10,
    }))
    const tI = {
      desktop: c.createElement(wc, null),
      mobile: c.createElement(Fc, null),
      tablet: c.createElement(zc, null),
      other: c.createElement(ft, null),
    }
    const rI = h(({ api: e }) => {
      const t = tr(ti)
      const [r, n, o] = Rt()
      const [a, i] = z(!1)
      const { options: s = YO, disable: l } = t || {}
      const u = r?.[ti] || {}
      const d = typeof u === 'string' ? u : u.value
      const m = typeof u === 'string' ? !1 : u.isRotated
      const p = s[d] || oo
      const f = a || p !== oo
      const g = ti in o
      const y = Object.keys(s).length
      if (
        (X(() => {
          JO(e, d, n, Object.keys(s))
        }, [s, d, n, e]),
        p.styles === null || !s || y < 1)
      )
        return null
      if (typeof p.styles === 'function')
        return (
          console.warn(
            'Addon Viewport no longer supports dynamic styles using a function, use css calc() instead'
          ),
          null
        )
      const E = m ? p.styles.height : p.styles.width
      const b = m ? p.styles.width : p.styles.height
      return l
        ? null
        : c.createElement(nI, {
            item: p,
            updateGlobals: n,
            viewportMap: s,
            viewportName: d,
            isRotated: m,
            setIsTooltipVisible: i,
            isLocked: g,
            isActive: f,
            width: E,
            height: b,
          })
    }, 'ViewportTool')
    var nI = c.memo(
      h(function (e) {
        const {
          item: t,
          viewportMap: r,
          viewportName: n,
          isRotated: o,
          updateGlobals: a,
          setIsTooltipVisible: i,
          isLocked: s,
          isActive: l,
          width: u,
          height: d,
        } = e
        const m = Q(p => a({ [ti]: p }), [a])
        return c.createElement(
          ft,
          null,
          c.createElement(
            De,
            {
              placement: 'bottom',
              tooltip: ({ onHide: p }) =>
                c.createElement(In, {
                  links: [
                    ...(length > 0 && t !== oo
                      ? [
                          {
                            id: 'reset',
                            title: 'Reset viewport',
                            icon: c.createElement(Ao, null),
                            onClick: h(() => {
                              ;(m(void 0), p())
                            }, 'onClick'),
                          },
                        ]
                      : []),
                    ...Object.entries(r).map(([f, g]) => ({
                      id: f,
                      title: g.name,
                      icon: tI[g.type],
                      active: f === n,
                      onClick: h(() => {
                        ;(m({ value: f, isRotated: !1 }), p())
                      }, 'onClick'),
                    })),
                  ].flat(),
                }),
              closeOnOutsideClick: !0,
              onVisibleChange: i,
            },
            c.createElement(
              QO,
              {
                disabled: s,
                key: 'viewport',
                title: 'Change the size of the preview',
                active: l,
                onDoubleClick: () => {
                  m({ value: void 0, isRotated: !1 })
                },
              },
              c.createElement(Bc, null),
              t !== oo
                ? c.createElement(eI, null, t.name, ' ', o ? '(L)' : '(P)')
                : null
            )
          ),
          c.createElement(Xc, {
            styles: {
              'iframe[data-is-storybook="true"]': { width: u, height: d },
            },
          }),
          t !== oo
            ? c.createElement(
                ZO,
                null,
                c.createElement(
                  M0,
                  { title: 'Viewport width' },
                  u.replace('px', '')
                ),
                s
                  ? '/'
                  : c.createElement(
                      ce,
                      {
                        key: 'viewport-rotate',
                        title: 'Rotate viewport',
                        onClick: () => {
                          m({ value: n, isRotated: !o })
                        },
                      },
                      c.createElement(Gc, null)
                    ),
                c.createElement(
                  M0,
                  { title: 'Viewport height' },
                  d.replace('px', '')
                )
              )
            : null
        )
      }, 'PureTool')
    )
    const mU = ve.register(vn, e => {
      globalThis?.FEATURES?.viewport &&
        ve.add(WO, {
          title: 'viewport / media-queries',
          type: et.TOOL,
          match: h(({ viewMode: t, tabId: r }) => t === 'story' && !r, 'match'),
          render: h(() => Y(rI, { api: e }), 'render'),
        })
    })
    const oI = 'tag-filters'
    const aI = 'static-filter'
    const hU = ve.register(oI, e => {
      const t = Object.entries(H.TAGS_OPTIONS ?? {}).reduce((r, n) => {
        const [o, a] = n
        return (a.excludeFromSidebar && (r[o] = !0), r)
      }, {})
      e.experimental_setFilter(aI, r => {
        const n = r.tags ?? []
        return (
          (n.includes('dev') || r.type === 'docs') &&
          n.filter(o => t[o]).length === 0
        )
      })
    })
  })()
} catch (e) {
  console.error(
    '[Storybook] One of your manager-entries failed: ' + import.meta.url,
    e
  )
}
